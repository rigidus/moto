<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Модуль HeadHunter</title>
<!-- 2017-09-08 Пт 04:52 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="rigidus" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<!-- -*- fill-column: 87 -*- -->
<!-- org-toggle-inline-images -->

<script type="text/javascript" src="http://orgmode.org/org-info.js">
/**
 *
 * @source: http://orgmode.org/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://orgmode.org/org-info.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://orgmode.org/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "overview");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Модуль HeadHunter</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Цель</a></li>
<li><a href="#sec-2">2. Что это такое?</a></li>
<li><a href="#sec-3">3. Сценарии использования</a>
<ul>
<li><a href="#sec-3-1">3.1. Сценарии использования Соискателя</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. Составление резюме</a></li>
<li><a href="#sec-3-1-2">3.1.2. Опубликование резюме</a></li>
<li><a href="#sec-3-1-3">3.1.3. Поиск вакансий и правила отбора</a></li>
<li><a href="#sec-3-1-4">3.1.4. Просмотр вакансий, отсев, ранжирование и заметки</a></li>
<li><a href="#sec-3-1-5">3.1.5. Рассылка откликов</a></li>
<li><a href="#sec-3-1-6">3.1.6. Нахождение вакансии в момент телефонного звонка</a></li>
<li><a href="#sec-3-1-7">3.1.7. Автоматическое назначение собеседования</a></li>
<li><a href="#sec-3-1-8">3.1.8. Выполнение тестовых заданий</a></li>
<li><a href="#sec-3-1-9">3.1.9. Собеседование с работодателем и отзывы о собеседованиях</a></li>
<li><a href="#sec-3-1-10">3.1.10. Выбор лучшего предложения по многим критериям</a></li>
<li><a href="#sec-3-1-11">3.1.11. Вакансия становится неактуальной</a></li>
<li><a href="#sec-3-1-12">3.1.12. Отзывы соискателей о компаниях и вакансиях</a></li>
<li><a href="#sec-3-1-13">3.1.13. Маршрут</a></li>
<li><a href="#sec-3-1-14">3.1.14. Побочные сценарии соискателя</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. Сценарии использования Работодателя</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. Составление вакансий</a></li>
<li><a href="#sec-3-2-2">3.2.2. Опубликование вакансий</a></li>
<li><a href="#sec-3-2-3">3.2.3. Автоматический поиск резюме, создание правил отбора резюме и автоматических действий над ними</a></li>
<li><a href="#sec-3-2-4">3.2.4. Ручной поиск и просмотр резюме, отсев, ранжирование, внесение заметок по соискателям</a></li>
<li><a href="#sec-3-2-5">3.2.5. Рассылка приглашений</a></li>
<li><a href="#sec-3-2-6">3.2.6. Телефонные интервью</a></li>
<li><a href="#sec-3-2-7">3.2.7. Заполнение анкеты</a></li>
<li><a href="#sec-3-2-8">3.2.8. Собеседование с соискателем</a></li>
<li><a href="#sec-3-2-9">3.2.9. Предложение соискателю тестовых заданий</a></li>
<li><a href="#sec-3-2-10">3.2.10. Проверка тестовых заданий</a></li>
<li><a href="#sec-3-2-11">3.2.11. Анализ статистических отчетов</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3. Хотелки (набор несогласованных идей, чтобы не забыть)</a></li>
<li><a href="#sec-3-4">3.4. <span class="todo nilTODO">TODO</span> TODO</a></li>
</ul>
</li>
<li><a href="#sec-4">4. <span class="todo nilTODO">TODO</span> Сущности</a>
<ul>
<li><a href="#sec-4-1">4.1. Сущность вакансии</a></li>
<li><a href="#sec-4-2">4.2. Состояния вакансий</a></li>
<li><a href="#sec-4-3">4.3. <span class="todo nilTODO">TODO</span> Сущность резюме соискателя (<code>entity:resume</code>)</a></li>
<li><a href="#sec-4-4">4.4. <span class="todo nilTODO">TODO</span> Вспомогательные сущности резюме</a>
<ul>
<li><a href="#sec-4-4-1">4.4.1. Основное образование</a></li>
<li><a href="#sec-4-4-2">4.4.2. Иностранные языки</a></li>
<li><a href="#sec-4-4-3">4.4.3. Опыт работы</a></li>
<li><a href="#sec-4-4-4">4.4.4. Ключевые навыки</a></li>
<li><a href="#sec-4-4-5">4.4.5. Рекоммендации</a></li>
<li><a href="#sec-4-4-6">4.4.6. Портфолио</a></li>
</ul>
</li>
<li><a href="#sec-4-5">4.5. Сущность правила (<code>entity:rule</code>)</a></li>
<li><a href="#sec-4-6">4.6. Аккаунт на источнике вакансий</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Компоненты</a>
<ul>
<li><a href="#sec-5-1">5.1. Получение, разбор и сохранение вакансий</a></li>
<li><a href="#sec-5-2">5.2. Посылка откликов и работа с ними</a></li>
<li><a href="#sec-5-3">5.3. Создание и управление резюме</a></li>
<li><a href="#sec-5-4">5.4. Интерфейс модуля</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Тесты</a></li>
<li><a href="#sec-7">7. Точки входа</a></li>
<li><a href="#sec-8">8. Сборка</a>
<ul>
<li><a href="#sec-8-1">8.1. Макроутилиты</a></li>
<li><a href="#sec-8-2">8.2. Фунциональные утилиты</a>
<ul>
<li><a href="#sec-8-2-1">8.2.1. Point-free определения:</a></li>
<li><a href="#sec-8-2-2">8.2.2. Flip, карринг, композиции:</a></li>
<li><a href="#sec-8-2-3">8.2.3. Свёртки и "развёртки":</a></li>
<li><a href="#sec-8-2-4">8.2.4. Отображения и фильтрации:</a></li>
<li><a href="#sec-8-2-5">8.2.5. Функции для списков на основе карринга и свёрток:</a></li>
<li><a href="#sec-8-2-6">8.2.6. Функции для чисел:</a></li>
<li><a href="#sec-8-2-7">8.2.7. И для булевых чисел:</a></li>
<li><a href="#sec-8-2-8">8.2.8. Многие другие функции представляются свёртками, например:</a></li>
<li><a href="#sec-8-2-9">8.2.9. Свёртки для деревьев:</a></li>
</ul>
</li>
<li><a href="#sec-8-3">8.3. Другие утилиты</a></li>
<li><a href="#sec-8-4">8.4. Утилиты</a></li>
<li><a href="#sec-8-5">8.5. Глобальные определения</a></li>
<li><a href="#sec-8-6">8.6. Сущности и автоматы</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Crypto</a></li>
</ul>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/css/css.css" />

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Цель</h2>
<div class="outline-text-2" id="text-1">
<p>
Мы все ищем работу на профильных сайтах время от времени. Иногда на это уходит
значительное время, т.к. мы выполняем множество рутинных действий, которых могли бы
избежать. Попробуем автоматизировать этот процесс, так чтобы работа, по-возможности,
искалась сама, без непосредственного участия соискателя.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Что это такое?</h2>
<div class="outline-text-2" id="text-2">
<p>
Это средство автоматизации процесса поиска работы, выполненное в форме экспертной
системы. Оно умеет обучаться при взаимодействия со своим пользователем. Обучение
производится с помощью внесения пользователем правил обработки входящего потока
вакансий.
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Сценарии использования</h2>
<div class="outline-text-2" id="text-3">
<p>
Рассмотрим поиск работы как бизнес-процесс. В этом процессе несколько участников,
самый важный из которых я - <code>Соискатель</code> :) Еще есть работодатель, но о его интересах
мы думаем меньше, потому что когда я ищу работу, единственное, что я хочу от
работодателя - чтобы он предложил мне <code>Вакансию</code>. На эту вакансию я откликаюсь своим
<code>Резюме</code>.
</p>

<p>
<code>Вакансия</code> - наиболее часто используемый на первом этапе объект. Она содержит в себе
множество полей, таких как, например, "описание", но важно определить, что с
<code>Вакансией</code> можно делать, то есть ее, так называемое "поведение". Оказывается, что
поведение зависит от "состояния" <code>Вакансии</code>, например, нельзя еще раз откликнуться на
<code>Вакансию</code>, работодатель которой пригласил меня на собеседование. Правда, можно
откликнуться другим резюме, и это внезапно говорит нам, что "поведением", зависящим
от состояния обладает на самом деле пара <code>Вакансия</code> + <code>Резюме</code>.
</p>

<p>
Как видим, на этом этапе, мы, похоже, уже не вписываемся в классическое
Объектно-Ориентированное Программирование: в ООП поведением обладает <code>класс</code>, и
выражается оно набором методов класса. Если же мы начнем менять этот набор методов в
зависимости от поля "состояние" в объекте - нам придется либо вставлять проверки в
каждый метод, либо иметь набор классов-наследников и приводить объекты к нужному
классу динамически. И то и другое мне не очень нравится.
</p>

<p>
Ну а когда у нас поведением обладает пара объектов <code>Вакансия</code> + <code>Резюме</code> проблема
объектной декомпозиции становится совершенно непонятной. Возможно, тот кто это
читает, знает как решить ее, в этом случае прошу написать мне об этом.
</p>

<p>
Ну а пока я не узнал, как это сделать в классическом ООП, я воспользуюсь для решения
этой проблемы обобщенными функциями языка Лисп, где метод может принадлежать
одновременно нескольким классам. Для понимания, как это работает я отсылаю всех
заинтересовавшихся к главе 16 "Обобщенные функции" книги <a href="http://rigidus.ru/resources/pcl.pdf">Practical Common Lisp</a>.
</p>

<p>
Итак, пара "Вакансия+Резюме" может находится в нескольких <code>состояниях</code>:
</p>
<ul class="org-ul">
<li>неотсортирована - т.е. свежеполученная с сайта по поиску работы вакансия
</li>
<li>неинтересная - я даже не собираюсь ее рассматривать
</li>
<li>интересная - вакансия, которая мне интересна, но я не еще отправил на нее отзыв
</li>
<li>отправлен отзыв (мной)
</li>
<li>отзыв просмотрен (работодателем)
</li>
<li>работодатель отказал
</li>
<li>работодатель пригласил на интервью
</li>
<li>прохождение интервью (там возможны тестовые задания)
</li>
<li>получено предложение работы
</li>
</ul>

<p>
Состояния образуют ориентированный граф, а множество пар <code>Вакансия+Резюме</code> в
состояниях после "отзыв отправлен" - фронт работ, в котором понятно что нужно делать
по каждой паре. Ну а интерфейс должен обеспечивать доступ к выборкам пар и действиям
над ними и всякие дополнительные возможности - например, напоминания что по каким-то
вакансиям нет движения уже 3 дня.
</p>

<p>
Чтобы перевести пару из одного состояния в другое, было бы достаточно просто изменить
значение поля <code>state</code>. Конечно, чтобы иметь возможность делать что-то, когда это поле
меняется, стоит сделать ему getter и setter, но еще более масштабируемый вариант -
это отправлять паре сообщение. Сообщения можно класть в очередь и обрабатывать
отложенно, и это облегчает разделение системы в соответствии с Service Oriented
Architecture (SOA).
</p>

<p>
Если по графу состояний понятно, какие возможны действия по каждой вакансии, то часть
этих действий можно автоматизировать - например, так называемый "преселект", когда мы
выкидываем вакансии, которые соискателю заведомо неинтересны (например, можно
отбросить вакансии без указания зарплаты). Также можно анализировать текст вакансии,
и если стек технологий, оплата и месторасположение устраивает - автоматически
отправлять отзыв. Поскольку к отзыву прикрепляется <code>Резюме</code> - напрашивается решение
автоматически формировать <code>Резюме</code>, например, выкидывая из него те куски, в которых
идет речь о технологиях, которые не требуются в целевой вакансии.
</p>

<p>
Это не очень сложно - вакансии, как правило, пишутся довольно формальным языком, в
них всегда есть разделы "Требования", "Будет плюсом", "Условия". От Соискателя в этом
случае требуется только узнать о том, что его пригласили на собеседование, ну и
пройти его, конечно.
</p>

<p>
Сценарии использования Работодателя можно автоматизировать похожим образом, с той
лишь разницей, что работодатель осуществляет операции над <code>Отзывом</code> Соискателя, к
которому прикреплено <code>Резюме</code> и другие личные данные соискателя (например, портфолио
дизайнера). Этот <code>Отзыв</code> может находится в таких состояниях:
</p>
<ul class="org-ul">
<li>непросмотрен
</li>
<li>неинтересный
</li>
<li>интересный
</li>
<li>отправлено приглашение
</li>
<li>приглашение просмотрено
</li>
<li>отправлено тестовое задание
</li>
<li>получено решение тестового задания, но оно еще не проверено
</li>
<li>назначено собеседование
</li>
<li>сделано предложение (с такими-то условиями)
</li>
<li>предложение принято (вакансия закрыта)
</li>
<li>предложение не принято Соискателем
</li>
</ul>

<p>
Исходя из всего этого, мы можем написать в первую очередь поддержку сценариев
использования для соискателя, а потом и работодателя:
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Сценарии использования Соискателя</h3>
<div class="outline-text-3" id="text-3-1">
<p>
С точки зрения соискателя процесс найма выглядит так:
</p>

<ul class="org-ul">
<li>Этап составления резюме
</li>
<li>Этап опубликования резюме
</li>
<li>Этап поиска
<ul class="org-ul">
<li>Поиск и просмотр вакансий, отсев, ранжирование
</li>
<li>Рассылка откликов
</li>
</ul>
</li>
<li>Этап телефонных переговоров
<ul class="org-ul">
<li>Получение звонков, обсуждение деталей по телефону
</li>
<li>Договоренность о еще одном звонке
</li>
<li>Тестовое задание на почту
</li>
<li>Договоренность о skype-интервью
</li>
</ul>
</li>
<li>Этап удаленного тестирования
<ul class="org-ul">
<li>Skype-интервью
</li>
<li>Ожидание тестового задания
</li>
<li>Выполнение тестового задания
</li>
</ul>
</li>
<li>Этап очного собеседования
<ul class="org-ul">
<li>Приглашение на интервью
</li>
<li>Интервью
</li>
</ul>
</li>
<li>Этап отбора предложений
<ul class="org-ul">
<li>Получение предложений
</li>
<li>Выбор предложения
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Составление резюме</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
В простейшем случае, Соискатель просто размещает свое резюме. Однако продвинутые
соискатели формируют резюме под конкретную вакансию и мы можем автоматизировать
этот процесс несколькими способами.
</p>

<p>
Простейший пример персонализации резюме по отношению к вакансии - это указывать в
резюме верхнюю границу той зарплатной вилки, которая указана в вакансии.
</p>

<p>
Мы можем предложить пользователю составить шаблон резюме и правила, по которым
шаблон превращается в готовое резюме. Правила могут анализировать вакансию и
выполнять заполнение шаблона в зависимости от того, что находится в требованиях к
вакансии. В предельном случае у нас получается Domain Specific Language для
написания резюме и анализа вакансий.
</p>

<p>
Мне нравится этот подход, и он хорошо сработает для меня, но я понимаю, что врядли
другие Соискатели будут обрадованы, если им предложить выучить специализированный
язык :)
</p>

<p>
Поэтому в качестве паралельного решения мы можем поиграть с методами искусственного
интеллекта: разбить резюме по абзацам, представить каждый абзац как "мешок слов" и
попытаться понять, о чем идет речь в каждом абзаце. И если, например, Соискатель
знает PHP и JAVA, а вакансия указывает в требованиях только PHP, то можно
автоматически выкинуть лишние, не относящиеся к PHP куски.
</p>

<p>
С точки зрения интерфейса, нужно дать возможность Соискателю прикреплять разные
резюме к вакансиям (т.е. создавать пары <code>Резюме+Вакансия</code>) и назначать правила
отправки для конкретного резюме.
</p>

<p>
Таким образом, мы можем определить правила, по которым определяется, будет ли
конкретное (возможно сгенерированное тем или иным способом) резюме отправлено
работодателю.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Опубликование резюме</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
Может сущестовать достаточно много сайтов по поиску работы и для наилучшего охвата
имеет смысл публиковать резюме на всех. Но у каждого из таких сайтов могут быть
свои правила, которые приходится учитывать и обрабатывать все возникающие ошибки.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> Поиск вакансий и правила отбора</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
Нам необязательно парсить все вакансии, которые находятся на сайтах поиска
работы. На самом деле мы вполне можем попросить Соискателей указать, какого рода
вакансии и в каких областях являются для них интересными. Следуя принципу "eat your
own dog food" я ориентируюсь прежде всего на IT-сферу.
</p>

<p>
Найденные Вакансии полезно упорядочить по зарплате.
</p>

<p>
Внутри вакансий можно искать по критериям, которые пользователь может задавать сам,
в форме правил, выполняющих действия над вакансией, если она совпадает с правилом.
</p>

<p>
Мне бы хотелось сразу получать представление, насколько свежая вакансия. Наиболее
наглядно это делает интерактивный график.
</p>

<p>
Мне было бы интересно, сколько интервью было проведено и запланировано по
вакансии - эту информацию можно узнать из анализа активности по ней других
Соискателей. Технически можно даже просить оставить отзыв по Вакансии тех
Соискателей, которые дошли до стадии "интервью"
</p>

<p>
Мне было бы интересно, как менялась вакансия с момента ее размещения компанией. К
примеру можно находить и отслеживать похожие вакансии по расстоянию
Левенштейна. Динамика изменения зарплатного предложения может многое сказать об
отношении к вакансии.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4"><span class="section-number-4">3.1.4</span> Просмотр вакансий, отсев, ранжирование и заметки</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
Когда я читаю вакансию, я бы хотел, чтобы она переходила в статус "просмотрено" (и
к ней добавлялась дата просмотра)
</p>

<p>
Читая вакансию, мне бы хотелось устанавливать ей приоритет и вносить заметки, чтобы
отслеживать такие моменты, как например: необходимость позвонить позже, или все,
что мне сказал hr-специалист по телефону.
</p>

<p>
Если я отправляю отзыв на вакансию или звоню по телефону - я бы хотел, чтобы эти
действия сопровождались временем и изменением статуса, чтобы потом можно было
отследить историю взаимодействия с HR.
</p>

<p>
При этом, мне хотелось бы видеть на дашборде те вакансии, с которыми я договорился
о встрече и те, по которым нет движения долгое время, чтобы ничего не забывалось.
</p>

<p>
Я хочу получать напоминания о моем следующем шаге в отношении тех вакансий, которые
мне интересны.
</p>

<p>
Мне бы хотелось видеть на каком я этапе в тех вакансиях, которые меня интересуют.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-5" class="outline-4">
<h4 id="sec-3-1-5"><span class="section-number-4">3.1.5</span> Рассылка откликов</h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
Отклик на вакансию - это как раз тот момент, когда вместе связываются Вакансия и
Резюме. Часто к отклику можно приложить так называемое "сопроводительное письмо",
которое тоже можно составлять используя те же методы что и для составления Резюме,
например, по шаблону или используя специальный язык. Правильный отзыв вероятно может
довольно сильно влиять на вероятность приглашения на собеседование.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-6" class="outline-4">
<h4 id="sec-3-1-6"><span class="section-number-4">3.1.6</span> Нахождение вакансии в момент телефонного звонка</h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
После отправки отклика звонит работодатель и приглашает на интервью. В этот момент
я хочу найти эту вакансию, и в зависимости от того до чего мы договорились с
работодателем выставить ей некоторое состояние или внести заметки, поставить тег,
и.т.п.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-7" class="outline-4">
<h4 id="sec-3-1-7"><span class="section-number-4">3.1.7</span> Автоматическое назначение собеседования</h4>
<div class="outline-text-4" id="text-3-1-7">
<p>
В ряде случаев информация о собеседовании может прийти на email пользователя. Это
позволяет вообще исключить человека из этого сценария - единственное что
необходимо - уведомить о созданной встрече, добавив ее в календарь.
</p>

<p>
Здесь можно помечать о том прекрасном мире, где для того чтобы сменить работу
вообще не нужно будет ходить по собеседованиям, а о переходе в другую компанию
будут договариваться автоматические персональные ассистенты Соискателя и
Работодателя :)
</p>
</div>
</div>

<div id="outline-container-sec-3-1-8" class="outline-4">
<h4 id="sec-3-1-8"><span class="section-number-4">3.1.8</span> Выполнение тестовых заданий</h4>
<div class="outline-text-4" id="text-3-1-8">
<p>
Обычно работодатель не слишком заморачивается тестовыми заданиями. Соискатель,
выполнивший тестовое задание, может сохранить его, привязав к вакансии. За это ему
можно начислять баллы или иным способом поощрять.
</p>

<p>
Таким образом с вакансиями можно связывать тестовые задания и их решения, что упрощает
прохождение собеседований. За такую информацию пользователь может платить (балламы или
иным способом)
</p>
</div>
</div>

<div id="outline-container-sec-3-1-9" class="outline-4">
<h4 id="sec-3-1-9"><span class="section-number-4">3.1.9</span> Собеседование с работодателем и отзывы о собеседованиях</h4>
<div class="outline-text-4" id="text-3-1-9">
<p>
После прохождения собеседования Соискатель мог бы оставлять отзыв. Другие
пользователи могли бы оценивать качество отзыва
</p>
</div>
</div>

<div id="outline-container-sec-3-1-10" class="outline-4">
<h4 id="sec-3-1-10"><span class="section-number-4">3.1.10</span> Выбор лучшего предложения по многим критериям</h4>
<div class="outline-text-4" id="text-3-1-10">
<p>
Пользователи могли бы использовать интерфейсы к методам многофакторного анализа
(симплекс-метод, дерево принятия решений) чтобы определить лучшее предложение. Это
гораздо более рациональный подход по сравнению с тем что применяется сейчас, и
кроме того дает Работодателям значимую информацию о том, как улучшить свое
предложение.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-11" class="outline-4">
<h4 id="sec-3-1-11"><span class="section-number-4">3.1.11</span> Вакансия становится неактуальной</h4>
<div class="outline-text-4" id="text-3-1-11">
<p>
Вакансия может стать неактуальной если работодатель снимет ее, но работодатели
могут забывать это сделать, поэтому можно предусмотреть тайм-аут.
</p>

<p>
Вакансия также может сниматься по достижению некоторого кол-ва голосов соискателей,
которые дозвонились но им сказали, что вакансия уже неактуальна.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-12" class="outline-4">
<h4 id="sec-3-1-12"><span class="section-number-4">3.1.12</span> Отзывы соискателей о компаниях и вакансиях</h4>
<div class="outline-text-4" id="text-3-1-12">
<p>
Можно сэкономить кучу времени и денег просто не нанимаясь в те компании, в которых
"все плохо". В этом плане соискатели могут помочь друг другу. Возможно и компании
тоже будут прислушиваться к такому фидбеку.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-13" class="outline-4">
<h4 id="sec-3-1-13"><span class="section-number-4">3.1.13</span> Маршрут</h4>
<div class="outline-text-4" id="text-3-1-13">
<p>
Иногда я хочу спланировать маршрут поездки по собеседованиям. Это сервис с картами,
которые можно сделать позже.
</p>

<p>
Полезно распечтывать карты, соответствующие вакансиям.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-14" class="outline-4">
<h4 id="sec-3-1-14"><span class="section-number-4">3.1.14</span> Побочные сценарии соискателя</h4>
<div class="outline-text-4" id="text-3-1-14">
<p>
Вакансии на сайтах размещаются компаниями, которых я назову <code>Работодателями</code> и
привязываются к ним. Мне, как Соискателю, интересно посмотреть какие вакансии
размещала ранее конкретная компания, какие она размещает теперь, как изменялись
зарплаты - и тому подобная аналитическая информация.
</p>

<p>
Я также хочу чтобы система проходила по вакансиям и в зависимости от сочетания условий
выполняла какие-то действия:
</p>
<ul class="org-ul">
<li>напоминание мне о собеседованиях, звонках (календарь)
</li>
<li>автоматическое ранжирование вакансий (по перспективам найма, зарплате и.т.п)
</li>
</ul>

<p>
Система может анализировать компании с т.з. выставляемых вакансий и формирует
профиль компании. По выставляемым вакансиям можно сделать интересные выводы -
например, когда у компании внезапно появляются вакансии на одного сеньера и
нескольких линейных разработчиков - это напоминает открытие нового отдела/проекта.
</p>

<p>
Система может классифицировать сохраненные вакансии по формальным признакам, таким как:
</p>
<ul class="org-ul">
<li>новые вакансии
</li>
<li>измененные
</li>
<li>закрытые (о закрытости вакансии можно судить по ряду критериев)
</li>
<li>особенно интересные
</li>
<li>необычные
</li>
</ul>

<p>
В случае изменений или появления новых интересующих пользователя вакансий можно
пользователю отправляеть уведомление (через систему очередей сообщений и по email).
</p>

<p>
Исходя из анализа описания вакансии можно определить требуемую технологию и
требуемую степень владения ею.
</p>

<p>
Еще можно сделать:
</p>

<p>
Предоставление рекомендаций и отбор вакансий на основе модифицируемых правил и
фактах предметной области, таких как "работодатель - компания по разработке ПО" или
"ИТ-поддержка не является приоритетом компании"
</p>

<p>
Предсказание поведения (путей достижения целей) компании (в процессе найма и вне
его) на основе моделей и целей.
</p>

<p>
Выбор вариантов поведения в ответ на предьявляемые требования (цикл
распознавание-действие в продукционной системе). Для автоматического построния
резюме под вакансию из шаблонов.
</p>

<p>
Построение концептуальных моделей и преобразования в них - выбор стратегии действий и
постановка целей.
</p>

<p>
Выбор способа представления знаний (правила, фреймы, концептуальные графы)
</p>

<p>
Выбор стратегии поиска.
</p>

<p>
Включение терма из набора технологий в заголовке вакансии - присвоение
классификатора (тега), который будет виден еще до открытия вакансии.
</p>

<p>
Правила вывода - сопоставление с профилем Соискателя
</p>

<p>
Вычисление различий (дифф) требований вакансии и профильных навыков резюме - для
подбора или построения оптимального резюме
</p>

<p>
Интерактивное построение профиля (ответы на вопросы). Необходим видимый прогресс и
предварительная классификация предложений
</p>

<p>
Построение новых правил на основе известных в автоматическом режиме - "домысливание
правил".
</p>

<p>
Когда вакансия переносится в архив - мы должны отслеживать это на стороннем сайте и
реагировать, устанавливая статус <code>archive</code>.
</p>

<p>
Когда мы собираем вакансии, распарсивая их с других сайтов, мы должны отслеживать
их состояние на этих сайтах.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Сценарии использования Работодателя</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Когда Рекрутер ищет вакансии, он пользуется несколькими путями:
</p>
<ul class="org-ul">
<li>Личные знакомства
</li>
<li>Рекомендации
</li>
<li>Социальные сети
<ul class="org-ul">
<li>LinkedIn
</li>
<li>vkontakte
</li>
</ul>
</li>
<li>Помощь коллег
</li>
<li>Специализированные сайты
</li>
</ul>

<p>
Как правило, Рекрутер менее компетентен в предметной области, чем нанимаемый
сотрудник, поэтому для него имеет большой вес мнение рекомендателей и коллег
соискателя. Вероятно, рекомендательный сервис был бы очень актуален.
</p>

<p>
Компании-работодатели выбирают одну из моделей найма, в соответствии со своим
бюджетом и задачами:
</p>
<ul class="org-ul">
<li>Всегда (на любую позицию) нанимать (переманивать) лучших
</li>
<li>Нанимать начинающих в подчинение лучшим
</li>
<li>Нанимать начинающих (конвеерная разработка, большая текучка)
</li>
<li>Нанимать тех, кто понравится лидеру отдела
</li>
<li>Нанимать тех, кто лучше соответствует корпоративной культуре
</li>
</ul>

<p>
Для каждой из этих моделей характерны свои необходимые сервисы. К примеру, для
модели "нанимать лучших" совершенно необходимо вести и актуализировать базу этих
"лучших", чтобы вовремя сделать предложение кандидату. О примерах внедрения таких
сервисов мне ничего не известно. Также интересно уточнить у Рекрутеров из
<code>разных</code> компаний их методы работы.
</p>

<p>
Для Рекрутера процесс найма выглядит (в общих чертах) так.
</p>

<ul class="org-ul">
<li>Этап составления вакансий
</li>
<li>Этап опубликования вакансий
</li>
<li>Этап поиска резюме
<ul class="org-ul">
<li>По ключевым словам
</li>
<li>По фильтру
</li>
<li>Используя автоподбор
</li>
</ul>
</li>
<li>Этап анализа откликов (неразобранные, подумать, приглашенные, отклоненные)
</li>
<li>Телефонный звонок соискателю (с целью уточнить детали или пригласить)
</li>
<li>Возможно отправка тестового задания
</li>
<li>Получение тестового задания
</li>
<li>Проверка тестового задания
</li>
<li>Скайп-интервью
</li>
<li>Этап собеседования
<ul class="org-ul">
<li>Опционально: заполнение анкеты
</li>
<li>Собеседование с Рекрутером (об условиях)
</li>
<li>Тесты (например: на знание языка, ООП, БД, многопоточность)
</li>
<li>Тестовое задание
</li>
<li>Проверка тестового задания
</li>
<li>Собеседование с тех. спецом, (как правило нач. отдела)
</li>
</ul>
</li>
</ul>

<p>
Рекрутер анализирует обратную связь о составляемых им вакансиях - у него есть
статистическая информация о кол-ве просмотров вакансий и количестве поступивших
откликов. Из этих данных можно, например, сделать вывод, что предложенная зарплата
неактуальна на рынке.
</p>

<p>
Также Рекрутер заинтересован в технической поддержке при решении задач типа:
</p>
<ul class="org-ul">
<li>Мониторинг резюме (сообщения о обновлении резюме, просмотр старой версии)
</li>
<li>Ведение базы кандидатов (часто в экселе)
</li>
</ul>

<p>
Рекрутер заинтересован в том, чтобы иметь возможность построить процесс найма
под себя.
</p>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> Составление вакансий</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Составлять вакансию можно многими разными способами, но мы стремимся максимально
упростить эту задачу для Рекрутера. Поэтому, разумно было бы сделать мастер,
который проведет Рекрутера по примерно таким шагам:
</p>
<ul class="org-ul">
<li>Название вакансии
</li>
<li>Информация о компании
</li>
<li>Обязанности будущего сотрудника
</li>
<li>Требования к будущему сотруднику
</li>
<li>Условия работы
</li>
<li>Дополнительная информация
</li>
</ul>
<p>
На hh.ru предлагается заполнить такие поля:
</p>
<ul class="org-ul">
<li>Тип вакансии
<ul class="org-ul">
<li>Открытая - доступна 1 публикация в любом регионе
</li>
<li>Закрытая
</li>
</ul>
</li>
<li>Название вакансии
<ul class="org-ul">
<li>Загрузить шаблон вакансии
</li>
<li>Указать код вакансии
</li>
</ul>
</li>
<li>Специализации
<ul class="org-ul">
<li>Указать профобласти
</li>
</ul>
</li>
<li>Вакансия в городе
</li>
<li>Адрес офиса
<ul class="org-ul">
<li>Добавить новый адрес
</li>
<li>Показывать кандидатам только станцию метро
</li>
</ul>
</li>
<li>Предполагаемый уровень месячного дохода
<ul class="org-ul">
<li>От
</li>
<li>До
</li>
</ul>
</li>
<li>Описание (не менее 200 символов)
<ul class="org-ul">
<li>Обязанности
</li>
<li>Требования
</li>
<li>Условия
</li>
</ul>
</li>
<li>Ключевые навыки
</li>
<li>Опыт работы. Здесь у hh все сделано
довольно по идиотски, т.к. выбор производится радиокнопкой, и я
не могу, например, выбрать от 3 лет до бесконечности.
<ul class="org-ul">
<li>Нет опыта
</li>
<li>От 1 года до 3 лет
</li>
<li>От 3 до 6 лет
</li>
<li>Более 6 лет
</li>
</ul>
</li>
<li>График работы
<ul class="org-ul">
<li>Полный день
</li>
<li>Сменный график
</li>
<li>Гибкий график
</li>
<li>Удаленная работа
</li>
<li>Вахтовый метод
</li>
</ul>
</li>
<li>Тип занятости
<ul class="org-ul">
<li>Полная занятость
</li>
<li>Частичная занятость
</li>
<li>Проектная.Временная работа
</li>
<li>Волонтерство
</li>
<li>Стажировка
</li>
</ul>
</li>
<li>Прикрепить вопросы к вакансии
Пока вы не создали ни одного теста
Вопросы и тесты – это инструмент для быстрого отбора резюме, а также
оценки навыков и знаний кандидатов. Создайте собственный вопросник
или воспользуйтесь готовыми из библиотеки
<ul class="org-ul">
<li>Создание списка вопросов
<ul class="org-ul">
<li>Название
</li>
<li>Описание
</li>
<li>Подробное описание - видно только HR-ам
</li>
<li>Вопросы
<ul class="org-ul">
<li>Ответ правильный, если выбраны
<ul class="org-ul">
<li>Все правильные ответы
</li>
<li>Хотя бы один правильный ответ
</li>
</ul>
</li>
<li>Свой вариант ответа
<ul class="org-ul">
<li>Возможен
</li>
<li>Невозможен
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Настройки публикации
<ul class="org-ul">
<li>Менеджер вакансии
<ul class="org-ul">
<li>Уведомлять об откликах и сообщениях на почту этого менеджера
</li>
</ul>
</li>
<li>Разрешить отклик для соискателей без резюме Мы знаем, что не у
всех нужных вам специалистов есть резюме на hh.ru. Но терять этих
соискателей не хочется. Поэтому мы нашли решение.  Для того, чтобы
получать отклики от соискателей без резюме достаточно выбрать эту
опцию при публикации вакансии&#x2026;. Все отклики без резюме будут
доступны вам в специальной папке на странице откликов на вакансию.
</li>
<li>Вакансия доступна для соискателей с инвалидностью
</li>
<li>Требовать сопроводительное письмо
</li>
<li>Возможность переписки
Как работает переписка с соискателем: Теперь на нашем сайте
приглашенные соискатели могут написать вам сообщение, а вы сможете
ответить через специальную форму.
</li>
<li>Сохранить вакансию как шаблон
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> Опубликование вакансий</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Необходимо дать возможность Рекрутеру сохранять и дополнять шаблоны
вакансий. Нужно также отслеживать время публикации, истечение оплаченных сроков
размещения и тому подобную бизнес-информацию.
</p>

<p>
Рекрутер должен понимать, какие вакансии в данный момент опубликованы, лежат в
архиве, кроме того можно снабдить вакансии тегами, чтобы их было удобнее
группировать и выполнять действия над группами вакансий - это может пригодится
крупным рекрутинговым агенствам.
</p>

<p>
К каждой вакансии можно привязать менеджера, который за нее отвечает - это шаг к
интеграции с CRM-системой, через API. Соответственно мы можем, например,
отслеживать Рекрутеров, у которых нет активных вакансий.
</p>

<p>
Вакансии можно фильтровать по ключевым словам, регионам и тому подобному.
</p>

<p>
На странице вакансии есть все то то видит и Соискатель, плюс:
</p>
<ul class="org-ul">
<li>ссылка на всех, кто откликнулся
</li>
<li>кнопка "разместить повторно"
</li>
<li>Кнопка "удалить вакансию"
</li>
<li>Резюме обновлено - дата, время
</li>
<li>Комментарии
<ul class="org-ul">
<li>Добавить комментарий
</li>
</ul>
</li>
<li>Оценка
<ul class="org-ul">
<li>Пригласить на встречу
</li>
</ul>
</li>
<li>Отклики
<ul class="org-ul">
<li>Не получил ответа
</li>
</ul>
</li>
</ul>

<p>
Важный момент - для вакансий, срок публикации которых истек, должна быть явная и
заметная возможность опубликовать вакансию снова.
</p>

<p>
Еще одна недоработка hh - неудобно искать отклики для тех вакансий, срок которых
продлевается. А я бы хотел видеть историю по каждому откликнувшемуся.
</p>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> Автоматический поиск резюме, создание правил отбора резюме и автоматических действий над ними</h4>
</div>
<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> Ручной поиск и просмотр резюме, отсев, ранжирование, внесение заметок по соискателям</h4>
</div>
<div id="outline-container-sec-3-2-5" class="outline-4">
<h4 id="sec-3-2-5"><span class="section-number-4">3.2.5</span> Рассылка приглашений</h4>
</div>
<div id="outline-container-sec-3-2-6" class="outline-4">
<h4 id="sec-3-2-6"><span class="section-number-4">3.2.6</span> Телефонные интервью</h4>
</div>
<div id="outline-container-sec-3-2-7" class="outline-4">
<h4 id="sec-3-2-7"><span class="section-number-4">3.2.7</span> Заполнение анкеты</h4>
</div>
<div id="outline-container-sec-3-2-8" class="outline-4">
<h4 id="sec-3-2-8"><span class="section-number-4">3.2.8</span> Собеседование с соискателем</h4>
</div>
<div id="outline-container-sec-3-2-9" class="outline-4">
<h4 id="sec-3-2-9"><span class="section-number-4">3.2.9</span> Предложение соискателю тестовых заданий</h4>
</div>
<div id="outline-container-sec-3-2-10" class="outline-4">
<h4 id="sec-3-2-10"><span class="section-number-4">3.2.10</span> Проверка тестовых заданий</h4>
</div>
<div id="outline-container-sec-3-2-11" class="outline-4">
<h4 id="sec-3-2-11"><span class="section-number-4">3.2.11</span> Анализ статистических отчетов</h4>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Хотелки (набор несогласованных идей, чтобы не забыть)</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Надо уметь удалять сниппеты и добавлять их в избранное
</p>

<p>
Есть множество конкурирующих сайтов для поиска работы, информацию с которых
можно аггрегировать.
</p>

<p>
При поиске работы основной сценарий использования - <code>поиск вакансий</code>, и практически все
сайты его предоставляют. Однако мне бы хотелось дополнительно иметь дополнительный
функционал:
</p>

<ul class="org-ul">
<li>заметки по каждой вакансии
</li>
<li>статусы или теги, такие как:
<ul class="org-ul">
<li><code>просмотрено</code> (с датой),
</li>
<li><code>отобрано</code>,
</li>
<li><code>не-берут-трубку</code>,
</li>
<li><code>не-актуально</code>,
</li>
<li><code>приглашен-на-интервью</code>,
</li>
<li><code>выслали-тестовое-задание</code>,
</li>
<li><code>отправил-тестовое-задание</code>,
</li>
<li><code>получен-оффер</code>,
</li>
<li><code>вакансия-закрыта</code> итп.
</li>
</ul>
</li>
</ul>

<p>
Работодатель хочет подтверждения навыков соискателя - для этого и тестовые
задания. Надо автоматизировать этот момент - если соискатель заявляет, к примеру,
знания С++ - он может сделать некоторое тестовое задание один раз и это будет
достаточным подтверждением квалификации для многих работодателей
</p>

<p>
Я бы хотел ранжировать вакансии вручную (по выставленным приоритетам) и
автоматически (т.е. скриптом), например, в зависимости от зарплаты или удаленности.
</p>

<p>
Я бы хотел иметь возможность планировать маршрут, когда еду на собеседование и иметь
календарь, чтобы не пропустить встречу.
</p>

<p>
Я бы хотел иметь версии вакансий, чтобы отслеживать их изменения, например,
изменения зарплаты до и после моего интервью - это позволит анализировать рынок и
получать больше информации.
</p>

<p>
Мне также интересно составлять профили компаний и отслеживать как меняется набор
сотрудников которых они ищут - это поможет планировать долгосрочную
стратегию. Особенно в этом плане интересны лидеры рынка - Яндекс, Гугл и.т.п.
</p>

<p>
Я бы хотел иметь возможность пообщаться с теми кто работал или работает в
интересующей меня компании, иметь подмножество функционала социальных сетей или
интеграцию с ними.
</p>

<p>
Иногда мне приятно работать с уже знакомыми людьми, так что в целом я бы не
отказался создавать на таком сайте что-то типа т.н. <code>рабочих коллективов</code>, чтобы
наниматься сразу командой. Возможно работодателям такой вариант найма тоже будет
интересен.
</p>

<p>
В ряде случаев компании меняют свои вакансии, некоторые делают это методом удаления
предыдущей и создания новой. Мне как соискателю хотелось бы не обнаруживать уже
просмотренную и возможно собеседованную вакансию в новых. Поэтому хотелось бы
предусмотреть механизм, который связывает очень похожие вакансии друг с другом.
</p>

<p>
Иногда вакансии меняются, или в них меняются существенные условия. Например, две
недели назад, когда я смотрел вакансию из предыдущей сборки меня не устроила
зарплата, а сегодня вакансия стала интереснее. Я хочу отслеживать что вакансия
поменялась.
</p>

<p>
Таким образом при создании вакансии мы должны проверять, может она уже есть в базе и
тогда указывать, что эта вакансия включена в несколько сборок.
</p>

<p>
Несколько вакансий могут быть от одной компании. В этом случае мне бы хотелось
отслеживать это в профиле компании, кроме того интересна аналитика по этой компании
за определенный период времени.
</p>

<p>
С социальной точки зрения интересно получать отзывы о компании от ее работников, в
том числе и уволенных.
</p>

<p>
Действия по вакансии: звонки, скайп-интервью, собеседования хорошо бы
отслеживать. Это информация вероятно будет интересна и работодателю особенно в плане
анализа эффективности работы HR-отдела. В эту таблицу заносим что сделано по каждой
вакансии, которая находится в разработке.
</p>

<p>
Теги вакансий помогают ориентироваться, когда вакансий много.
</p>

<p>
Важно: Для обеспечения социальных взаимодействий нужно предусмотреть, чтобы вакансию
можно было "передать", т.е. у нее минимум должен быть URI.
</p>

<p>
Если пользователь просмотрел вакансию, но пока не хочет отправлять отзыв - он может
добавить вакансию в закладки - в этом случае ее статус меняется на <code>favorited</code>
</p>

<p>
Из <code>favorited</code> мы снова можем отправить отзыв.
</p>

<p>
Из <code>favorited</code> пользователь может вернуть вакансию обратно в <code>interesting</code> или <code>hidden</code>.
</p>

<p>
Из <code>hidden</code> пользователь может вернуть вакансию в <code>interesting</code>.
</p>

<p>
Если по вакансии позвонили, пользователю обычно нужно ее быстро найти. Нужна форма
поиска по вакансиям в статусе <code>responded</code> - пользователь ищет обычно по названию
фирмы.
</p>

<p>
После звонка вакансия может быть выкинута или переведена из <code>responded</code> в статус
"был телефонный звонок" - <code>called</code>. Выкидывая вакансию пользователь может выбрать
reason - для них можно будет потом сделать отдельную таблицу но пока просто пишем в
поле вакансии. Если в результате телефонного звонка была достигнута договоренность о
собеседовании - пользователь переводит вакансию в состояние "пригласили на
интервью" - <code>wait-interview</code> и заносит в вакансию данные о том, куда и во сколько
ехать. Если по телефону рекрутер предложил тестовое задание - статус - "ожидание
тестового задания" - <code>wait-test</code>. Если договорились о интервью по скайпу - "ожидание
скайп-интервью" - <code>wait-skype-interview</code>.
</p>

<p>
Получив тестовое задание пользователь переводит вакансию из статуса <code>wait-test</code> в
"выполнение тестового задания" <code>run-test</code>, а оттуда либо в <code>test-cancel</code> либо в
<code>test-sended</code>. Либо выкидывает.
</p>

<p>
Пользователи иногда забивают на интервью (случаются накладки) - в этом случае рекрутер
часто передоговаривается на другое время. Делать петли в графе значит излишне усложнять
его, наверно пусть можно будет просто изменить данные о времени интервью.
</p>

<p>
После интервью или скайп-интервью от вакансии можно либо отказаться (<code>refuse-employer</code>,
<code>refuse-applicant</code>) либо перевести в статус "ожидание результата" - <code>wait-result</code>. Нужно
включать таймер, по истечении которого напоминать пользователю позвонить рекрутеру и
узнать, как дела.
</p>

<p>
Иногда после скайп-интервью назначают очное интервью. Также бывает прямо на интервью
предлагают оффер - <code>offer</code> и соискатель берет время на подумать.
</p>

<p>
Из "ожидания результата" можно перескочить в "предложен оффер", "отказ работодателя" -
<code>refuse-employer</code> или "отказ соискателя" - <code>refuse-аpplicant</code>.
</p>

<p>
История статусов нужна, в нее нужно заносить время когда изменяется статус и возможно
примечания по изменению. Будет красиво, если в интерфейсе будет отображаться полный граф
статусов и текущее положение вакансии в нем.
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> <span class="todo TODO">TODO</span> TODO</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>Было бы неплохо делать diff-ы между сборами вакансий и отзывов
</li>
<li>Нужен анализ ошибок hh при send-respond (например: вакансия в архиве)
</li>
<li>Нужна привязка к роботу, который по таймеру вынимает данные из hh
</li>
<li>Нужна привязка работы к юзеру
</li>
<li>Поправить неправильное определение emp-name при анализе тизеров
</li>
<li>Подключать несколько hh-аккаунтов к одному профилю пользователя
</li>
<li>Создание и удаление правил
</li>
<li>Предлагать правки статей через гитхаб
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> <span class="todo TODO">TODO</span> Сущности</h2>
<div class="outline-text-2" id="text-4">
<p>
Попробуем визуализировать схему БД через graphviz, опираясь на
<a href="http://graphviz.org/content/datastruct">http://graphviz.org/content/datastruct</a>
</p>

<p>
Простейший пример - реляционные отношения ученика и учителя (здесь мы считаем, что на
каждого учителя приходится некоторое кол-во учеников и у каждого ученика есть только
один учитель)
</p>

<table id="student_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Данные ученика</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">(primary)</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">teacher-id</td>
<td class="left">integer</td>
<td class="left">&#xa0;</td>
<td class="left">((one-to-many (teacher id)))</td>
<td class="left">связь с преподом</td>
</tr>
</tbody>
</table>

<table id="teacher_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Данные учителя</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">(primary)</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Таким образом мы пытаемся построить узел для учителя так, чтобы иметь возможность
ссылаться на поля записи (требует загрузки generators.el)
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp" id="make_node">(princ
 (concat <span style="color: #87005f;">"    \""</span> (underscore tbl) <span style="color: #87005f;">"\" [\n      label = \" ["</span> (underscore tbl) <span style="color: #87005f;">"] |"</span>
         (mapconcat #'(<span style="color: #af00ff;">lambda</span> (x)
                        (format <span style="color: #87005f;">" &lt;%s_%s&gt; %s "</span> (underscore tbl) (underscore x) x))
                    (remove-if-not #'(<span style="color: #af00ff;">lambda</span> (x)
                                       (string-match <span style="color: #87005f;">"id"</span> x))
                                   (mapcar #'car flds))
                    <span style="color: #87005f;">"|"</span>)
         <span style="color: #87005f;">"\"\n      shape = \"record\"\n    ];\n"</span>))
</pre>
</div>

<p>
Добавляем к этом связь (пока вручную):
</p>

<pre class="example" id="node_connections">
"student":student_teacher_id -&gt; "teacher": teacher_id [
  id = 1000
];
</pre>

<p>
И собираем, чтобы отрисовать граф:
</p>
<p>
<img src="img/test_graph2.png" alt="test_graph2.png" />
<img src="img/test_graph2.png" alt="test_graph2.png" />]]
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Сущность вакансии</h3>
<div class="outline-text-3" id="text-4-1">
<table id="vacancy_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Данные вакансии</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">(primary)</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">src-id</td>
<td class="left">integer</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор вакансии в источнике</td>
</tr>

<tr>
<td class="left">archive</td>
<td class="left">boolean</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">признак, что вакансия в архиве</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">название вакансии</td>
</tr>

<tr>
<td class="left">currency</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">валюта зарплаты</td>
</tr>

<tr>
<td class="left">base-salary</td>
<td class="left">(or db-null integer)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">размер компенсации в тизере</td>
</tr>

<tr>
<td class="left">salary</td>
<td class="left">(or db-null integer)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">размер компенсации</td>
</tr>

<tr>
<td class="left">salary-text</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">размер компенсации</td>
</tr>

<tr>
<td class="left">salary-max</td>
<td class="left">(or db-null integer)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">максимальный уровень зарплаты</td>
</tr>

<tr>
<td class="left">salary-min</td>
<td class="left">(or db-null integer)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">минимальный уровень зарплаты</td>
</tr>

<tr>
<td class="left">emp-id</td>
<td class="left">(or db-null integer)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор работодателя на удаленном ресурсе</td>
</tr>

<tr>
<td class="left">emp-name</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">имя работодателя на удаленном ресурсе</td>
</tr>

<tr>
<td class="left">city</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">город</td>
</tr>

<tr>
<td class="left">metro</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">метро</td>
</tr>

<tr>
<td class="left">experience</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">требуемый опыт работы</td>
</tr>

<tr>
<td class="left">date</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">дата опубликования в источнике</td>
</tr>

<tr>
<td class="left">respond</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">ссылка на отклик</td>
</tr>

<tr>
<td class="left">descr</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">описание вакансии</td>
</tr>

<tr>
<td class="left">notes</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">заметки по вакансии</td>
</tr>

<tr>
<td class="left">tags</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">Тэги вакансии</td>
</tr>

<tr>
<td class="left">response</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">текст отклика на вакансию</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Состояния вакансий</h3>
<div class="outline-text-3" id="text-4-2">
<p>
После загрузки, вакансия получает статус <code>unsort</code>
</p>

<p>
После сортировки пользователем ваканисия может принять один из статусов: <code>unsort</code>,
<code>interesting</code> или <code>uninteresting</code>
</p>

<p>
Пользователь, работая с этими интересными вакансиями, отслеживает их состояния, выполняя
действия, переводящие вакансию из одного состояния в другое: когда пользователь
отправляет отзыв - вакансия становится <code>responded</code>.
</p>

<table id="vacancy_state" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> Состояния конечного автомата вакансии</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">action</th>
<th scope="col" class="left">from</th>
<th scope="col" class="left">to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">uns-uni</td>
<td class="left">unsort</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">uns-int</td>
<td class="left">unsort</td>
<td class="left">interesting</td>
</tr>

<tr>
<td class="left">uns-res</td>
<td class="left">unsort</td>
<td class="left">responded</td>
</tr>

<tr>
<td class="left">uns-bee</td>
<td class="left">unsort</td>
<td class="left">beenviewed</td>
</tr>

<tr>
<td class="left">uns-rej</td>
<td class="left">unsort</td>
<td class="left">reject</td>
</tr>

<tr>
<td class="left">uns-inv</td>
<td class="left">unsort</td>
<td class="left">invite</td>
</tr>

<tr>
<td class="left">uni-int</td>
<td class="left">uninteresting</td>
<td class="left">interesting</td>
</tr>

<tr>
<td class="left">uni-res</td>
<td class="left">uninteresting</td>
<td class="left">responded</td>
</tr>

<tr>
<td class="left">uni-uni</td>
<td class="left">uninteresting</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">int-uni</td>
<td class="left">interesting</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">int-res</td>
<td class="left">interesting</td>
<td class="left">responded</td>
</tr>

<tr>
<td class="left">int-int</td>
<td class="left">interesting</td>
<td class="left">interesting</td>
</tr>

<tr>
<td class="left">res-bee</td>
<td class="left">responded</td>
<td class="left">beenviewed</td>
</tr>

<tr>
<td class="left">res-uni</td>
<td class="left">responded</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">res-rej</td>
<td class="left">responded</td>
<td class="left">reject</td>
</tr>

<tr>
<td class="left">res-inv</td>
<td class="left">responded</td>
<td class="left">invite</td>
</tr>

<tr>
<td class="left">res-res</td>
<td class="left">responded</td>
<td class="left">responded</td>
</tr>

<tr>
<td class="left">bee-uni</td>
<td class="left">beenviewed</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">bee-rej</td>
<td class="left">beenviewed</td>
<td class="left">reject</td>
</tr>

<tr>
<td class="left">bee-inv</td>
<td class="left">beenviewed</td>
<td class="left">invite</td>
</tr>

<tr>
<td class="left">bee-tes</td>
<td class="left">beenviewed</td>
<td class="left">testjob</td>
</tr>

<tr>
<td class="left">bee-bee</td>
<td class="left">beenviewed</td>
<td class="left">beenviewed</td>
</tr>

<tr>
<td class="left">tes-inv</td>
<td class="left">testjob</td>
<td class="left">invite</td>
</tr>

<tr>
<td class="left">tes-int</td>
<td class="left">testjob</td>
<td class="left">interview</td>
</tr>

<tr>
<td class="left">tes-uni</td>
<td class="left">testjob</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">tes-off</td>
<td class="left">testjob</td>
<td class="left">offer</td>
</tr>

<tr>
<td class="left">tes-tes</td>
<td class="left">testjob</td>
<td class="left">testjob</td>
</tr>

<tr>
<td class="left">rej-res</td>
<td class="left">reject</td>
<td class="left">responded</td>
</tr>

<tr>
<td class="left">rej-uni</td>
<td class="left">reject</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">rej-rej</td>
<td class="left">reject</td>
<td class="left">reject</td>
</tr>

<tr>
<td class="left">inv-inv</td>
<td class="left">invite</td>
<td class="left">invite</td>
</tr>

<tr>
<td class="left">inv-uni</td>
<td class="left">invite</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">inv-tes</td>
<td class="left">invite</td>
<td class="left">testjob</td>
</tr>

<tr>
<td class="left">inv-int</td>
<td class="left">invite</td>
<td class="left">interview</td>
</tr>

<tr>
<td class="left">int-uni</td>
<td class="left">interview</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">int-dis</td>
<td class="left">interview</td>
<td class="left">discard</td>
</tr>

<tr>
<td class="left">int-tes</td>
<td class="left">interview</td>
<td class="left">testjob</td>
</tr>

<tr>
<td class="left">int-int</td>
<td class="left">interview</td>
<td class="left">interview</td>
</tr>

<tr>
<td class="left">dis-uni</td>
<td class="left">discard</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">dis-dis</td>
<td class="left">discard</td>
<td class="left">discard</td>
</tr>

<tr>
<td class="left">int-off</td>
<td class="left">interview</td>
<td class="left">offer</td>
</tr>

<tr>
<td class="left">off-uni</td>
<td class="left">offer</td>
<td class="left">uninteresting</td>
</tr>

<tr>
<td class="left">off-off</td>
<td class="left">offer</td>
<td class="left">offer</td>
</tr>

<tr>
<td class="left">off-onj</td>
<td class="left">offer</td>
<td class="left">accept</td>
</tr>

<tr>
<td class="left">acc-acc</td>
<td class="left">accept</td>
<td class="left">accept</td>
</tr>
</tbody>
</table>

<p>
Теперь мы можем полностью описать поведение вакансии как конечный автомат:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp" id="vacancy_state_graph">(mapcar #'(<span style="color: #af00ff;">lambda</span> (x)
            (princ (format <span style="color: #87005f;">"%s -&gt; %s [label =\"%s\"];\n"</span>
                           (second x) (third x) (first x))))
        table)
</pre>
</div>

<p>
<img src="img/vacancy-state.png" alt="vacancy-state.png" />
<img src="img/vacancy-state.png" alt="vacancy-state.png" />]]
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="hh_fn_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uns-uni</span> ()
  <span style="color: #87005f;">"unsort        | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uns-int</span> ()
  <span style="color: #87005f;">"unsort        | interesting   |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uns-res</span> ()
  <span style="color: #87005f;">"unsort        | responded     |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uns-bee</span> ()
  <span style="color: #87005f;">"unsort        | beenviewed    |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uns-rej</span> ()
  <span style="color: #87005f;">"unsort        | reject        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uns-inv</span> ()
  <span style="color: #87005f;">"unsort        | invite        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uni-int</span> ()
  <span style="color: #87005f;">"uninteresting | interesting   |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uni-res</span> ()
  <span style="color: #87005f;">"uninteresting | responded     |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">uni-uni</span> ()
  <span style="color: #87005f;">"uninteresting | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">int-uni</span> ()
  <span style="color: #87005f;">"interesting   | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">int-res</span> ()
  <span style="color: #87005f;">"interesting   | responded     |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">int-int</span> ()
  <span style="color: #87005f;">"interesting   | interesting   |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">res-bee</span> ()
  <span style="color: #87005f;">"responded     | beenviewed    |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">res-uni</span> ()
  <span style="color: #87005f;">"responded     | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">res-rej</span> ()
  <span style="color: #87005f;">"responded     | reject        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">res-inv</span> ()
  <span style="color: #87005f;">"responded     | invite        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">res-res</span> ()
  <span style="color: #87005f;">"responded     | responded     |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">bee-uni</span> ()
  <span style="color: #87005f;">"beenviewed    | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">bee-rej</span> ()
  <span style="color: #87005f;">"beenviewed    | reject        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">bee-inv</span> ()
  <span style="color: #87005f;">"beenviewed    | invite        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">bee-tes</span> ()
  <span style="color: #87005f;">"beenviewed    | testjob       |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">bee-bee</span> ()
  <span style="color: #87005f;">"beenviewed    | beenviewed    |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">tes-inv</span> ()
  <span style="color: #87005f;">"testjob       | invite        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">tes-int</span> ()
  <span style="color: #87005f;">"testjob       | interview     |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">tes-uni</span> ()
  <span style="color: #87005f;">"testjob       | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">tes-off</span> ()
  <span style="color: #87005f;">"testjob       | offer         |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">tes-tes</span> ()
  <span style="color: #87005f;">"testjob       | testjob       |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">rej-res</span> ()
  <span style="color: #87005f;">"reject        | responded     |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">rej-uni</span> ()
  <span style="color: #87005f;">"reject        | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">rej-rej</span> ()
  <span style="color: #87005f;">"reject        | reject        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">inv-inv</span> ()
  <span style="color: #87005f;">"invite        | invite        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">inv-uni</span> ()
  <span style="color: #87005f;">"invite        | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">inv-tes</span> ()
  <span style="color: #87005f;">"invite        | testjob       |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">inv-int</span> ()
  <span style="color: #87005f;">"invite        | interview     |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">int-uni</span> ()
  <span style="color: #87005f;">"interview     | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">int-dis</span> ()
  <span style="color: #87005f;">"interview     | discard       |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">int-tes</span> ()
  <span style="color: #87005f;">"interview     | testjob       |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">int-int</span> ()
  <span style="color: #87005f;">"interview     | interview     |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dis-uni</span> ()
  <span style="color: #87005f;">"discard       | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dis-dis</span> ()
  <span style="color: #87005f;">"discard       | discard       |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">int-off</span> ()
  <span style="color: #87005f;">"interview     | offer         |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">off-uni</span> ()
  <span style="color: #87005f;">"offer         | uninteresting |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">off-off</span> ()
  <span style="color: #87005f;">"offer         | offer         |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">off-onj</span> ()
  <span style="color: #87005f;">"offer         | accept        |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">acc-acc</span> ()
  <span style="color: #87005f;">"accept        | accept        |"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> <span class="todo TODO">TODO</span> Сущность резюме соискателя (<code>entity:resume</code>)</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Иногда у одного соискателя может быть несколько резюме. Опишем структуру данных резюме:
</p>

<table id="resume_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 5:</span> Данные резюме</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">hh-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор резюме на hh.ru</td>
</tr>

<tr>
<td class="left">title</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">заголовок резюме</td>
</tr>

<tr>
<td class="left">last-name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">фамилия</td>
</tr>

<tr>
<td class="left">first-name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">имя</td>
</tr>

<tr>
<td class="left">middle-name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">отчество</td>
</tr>

<tr>
<td class="left">birthday</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">Дата рождения (по умолчанию: "")</td>
</tr>

<tr>
<td class="left">gender</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">пол (по умолчанию: "male")</td>
</tr>

<tr>
<td class="left">area</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">город проживания (спб: "2", москва: "1")</td>
</tr>

<tr>
<td class="left">metro</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">метро</td>
</tr>

<tr>
<td class="left">relocation</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">отношение к переезду ("no<sub>relocation</sub>"/"relocation<sub>possible</sub>"/"relocation<sub>desirable</sub>")</td>
</tr>

<tr>
<td class="left">relocation-area</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">куда переезжать (отправляется несколько полей с одним именем но разными значениями)</td>
</tr>

<tr>
<td class="left">business-trip-readiness</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">командировки ("never"/"ready"/"sometimes")</td>
</tr>

<tr>
<td class="left">citizen-ship</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">гражданство (Россия: 113)</td>
</tr>

<tr>
<td class="left">work-ticket</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">разрешение на работу (Россия: 113)</td>
</tr>

<tr>
<td class="left">travel-time</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">время в пути ("any"/"from<sub>hour</sub><sub>to</sub><sub>one</sub><sub>and</sub><sub>half</sub>"/"less<sub>than</sub><sub>hour</sub>")</td>
</tr>

<tr>
<td class="left">cell-phone-country</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">7</td>
</tr>

<tr>
<td class="left">cell-phone-city</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">911</td>
</tr>

<tr>
<td class="left">cell-phone-number</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">2869290</td>
</tr>

<tr>
<td class="left">cell-phone-comment</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">home-phone-country</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">7</td>
</tr>

<tr>
<td class="left">home-phone-city</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">home-phone-number</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">home-phone-comment</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">work-phone-country</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">7</td>
</tr>

<tr>
<td class="left">work-phone-city</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">work-phone-number</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">work-phone-comment</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">email-string</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">avenger-f%40yandex-ru</td>
</tr>

<tr>
<td class="left">preferred-contact</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">email/cell-phone/home-phone/work-phone</td>
</tr>

<tr>
<td class="left">icq</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">icq</td>
</tr>

<tr>
<td class="left">skype</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">skype</td>
</tr>

<tr>
<td class="left">freelance</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">freelance</td>
</tr>

<tr>
<td class="left">moi<sub>krug</sub></td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">moi<sub>krug</sub></td>
</tr>

<tr>
<td class="left">linkedin</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">linkedin</td>
</tr>

<tr>
<td class="left">facebook</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">facebook</td>
</tr>

<tr>
<td class="left">livejournal</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">livejournal</td>
</tr>

<tr>
<td class="left">personal-site</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">personal</td>
</tr>

<tr>
<td class="left">prof-area</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">1</td>
</tr>

<tr>
<td class="left">specializations</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">82 221</td>
</tr>

<tr>
<td class="left">salary-amount</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">100000</td>
</tr>

<tr>
<td class="left">salary-currency</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">RUR</td>
</tr>

<tr>
<td class="left">employment</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">full</td>
</tr>

<tr>
<td class="left">work-schedule</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">full<sub>day</sub></td>
</tr>

<tr>
<td class="left">education-level-string</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">higher</td>
</tr>

<tr>
<td class="left">educations</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">primary-education-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">primary-education-name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">primary-education-university-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">39864</td>
</tr>

<tr>
<td class="left">primary-education-faculty-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">primary-education-organization</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">primary-education-result</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">primary-education-specialty-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">224</td>
</tr>

<tr>
<td class="left">primary-education-year</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">2005</td>
</tr>

<tr>
<td class="left">additional-education-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">additional-education-name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">additional-education-organization</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">additional-education-result</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">additional-education-year</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-type</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-selected</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-ownerName</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-transcription-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-password</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-title</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-achievementDate</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">certificate-url</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">attestation-education-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">attestation-education-name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">attestation-education-organization</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">attestation-education-result</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">attestation-education-year</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">languages</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">Владение языками</td>
</tr>

<tr>
<td class="left">expiriences</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">Опыт работы</td>
</tr>

<tr>
<td class="left">skills</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">Ключевые навыки</td>
</tr>

<tr>
<td class="left">recommendations</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">Рекомендации</td>
</tr>

<tr>
<td class="left">portfolio</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">Портфолио</td>
</tr>
</tbody>
</table>

<p>
Резюме может быть активным или неактивным:
</p>

<table id="resume_state" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 6:</span> Состояния конечного автомата вакансии</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">action</th>
<th scope="col" class="left">from</th>
<th scope="col" class="left">to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">rai</td>
<td class="left">active</td>
<td class="left">inactive</td>
</tr>

<tr>
<td class="left">ria</td>
<td class="left">inactive</td>
<td class="left">active</td>
</tr>
</tbody>
</table>

<p>
Теперь мы можем полностью описать поведение резюме как конечный автомат:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp" id="resume_state_graph">(mapcar #'(<span style="color: #af00ff;">lambda</span> (x)
            (princ (format <span style="color: #87005f;">"%s -&gt; %s [label =\"%s\"];\n"</span>
                           (second x) (third x) (first x))))
        table)
</pre>
</div>

<p>
<img src="img/resume-state.png" alt="resume-state.png" />
<img src="img/resume-state.png" alt="resume-state.png" />]]
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="hh_fn_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">rai</span> ()
  <span style="color: #87005f;">"active-inactive"</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">ria</span> ()
  <span style="color: #87005f;">"inactive-active"</span>)
</pre>
</div>

<p>
Создадим резюме, связав их с резюме на hh:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="_hh_fn_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1058;&#1077;&#1089;&#1090;, &#1080;&#1083;&#1083;&#1102;&#1089;&#1090;&#1088;&#1080;&#1088;&#1091;&#1102;&#1097;&#1080;&#1081; magic-&#1084;&#1077;&#1090;&#1086;&#1076;&#1099;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1055;&#1088;&#1080; &#1087;&#1086;&#1087;&#1099;&#1090;&#1082;&#1077; &#1076;&#1086;&#1089;&#1090;&#1091;&#1087;&#1072; &#1082; &#1087;&#1086;&#1083;&#1102;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1075;&#1086; &#1085;&#1077; &#1089;&#1091;&#1097;&#1077;&#1089;&#1090;&#1074;&#1091;&#1077;&#1090; &#1074; &#1082;&#1083;&#1072;&#1089;&#1089;&#1077; &#1074; &#1101;&#1090;&#1086;&#1090; &#1082;&#1083;&#1072;&#1089;&#1089; &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090;&#1089;&#1103; &#1087;&#1086;&#1083;&#1077;. &#1045;&#1089;&#1083;&#1080; &#1076;&#1086;&#1089;&#1090;&#1091;&#1087; &#1073;&#1099;&#1083; &#1085;&#1072; &#1079;&#1072;&#1087;&#1080;&#1089;&#1100; - &#1079;&#1072;&#1087;&#1080;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090;&#1089;&#1103; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;, &#1080;&#1085;&#1072;&#1095;&#1077; &#1074; &#1087;&#1086;&#1083;&#1077; &#1073;&#1091;&#1076;&#1077;&#1090; nil.</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1069;&#1090;&#1086; &#1087;&#1086;&#1083;&#1077; - &#1095;&#1083;&#1077;&#1085; &#1082;&#1083;&#1072;&#1089;&#1089;&#1072;, &#1072; &#1085;&#1077; &#1086;&#1073;&#1098;&#1077;&#1082;&#1090;&#1072;. &#1058;&#1077;&#1093;&#1085;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080; &#1085;&#1080;&#1095;&#1090;&#1086; &#1085;&#1077; &#1084;&#1077;&#1096;&#1072;&#1077;&#1090; &#1085;&#1072;&#1084; &#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1075;&#1076;&#1077;-&#1090;&#1086; &#1086;&#1090;&#1076;&#1077;&#1083;&#1100;&#1085;&#1086; &#1086;&#1090; &#1089;&#1072;&#1084;&#1086;&#1075;&#1086; &#1082;&#1083;&#1072;&#1089;&#1089;&#1072;.</span>

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">direct-slot-defn-&gt;initarg</span> (slot-defn)
  (list <span style="color: #5f5f87;">:name</span> (slot-definition-name slot-defn)
        <span style="color: #5f5f87;">:readers</span> (slot-definition-readers slot-defn)
        <span style="color: #5f5f87;">:writers</span> (slot-definition-writers slot-defn)
        <span style="color: #5f5f87;">:initform</span> (slot-definition-initform slot-defn)
        <span style="color: #5f5f87;">:initargs</span> (slot-definition-initargs slot-defn)
        <span style="color: #5f5f87;">:initfunction</span> (slot-definition-initfunction slot-defn)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">add-slot-to-class</span> (class name <span style="color: #008700;">&amp;key</span> (initform nil) accessors readers writers initargs (initfunction (constantly nil)))
  (<span style="color: #ff0000; font-weight: bold;">check-type</span> class symbol)
  (<span style="color: #af00ff;">let</span> ((new-slots (list (list <span style="color: #5f5f87;">:name</span> name
                               <span style="color: #5f5f87;">:readers</span> (union accessors readers)
                               <span style="color: #5f5f87;">:writers</span> (union writers
                                               (mapcar #'(<span style="color: #af00ff;">lambda</span> (x)
                                                           (list 'setf x))
                                                       accessors)
                                               <span style="color: #5f5f87;">:test</span> #'equal)
                               <span style="color: #5f5f87;">:initform</span> initform
                               <span style="color: #5f5f87;">:initargs</span> initargs
                               <span style="color: #5f5f87;">:initfunction</span> initfunction))))
    (<span style="color: #af00ff;">dolist</span> (slot-defn (class-direct-slots (find-class class)))
      (push (direct-slot-defn-&gt;initarg slot-defn) new-slots))
    (ensure-class class <span style="color: #5f5f87;">:direct-slots</span> new-slots)))

(<span style="color: #af00ff;">defclass</span> <span style="color: #008700;">foo</span> ()
  ((bar <span style="color: #5f5f87;">:accessor</span> bar <span style="color: #5f5f87;">:initform</span> <span style="color: #87005f;">"zzzzzz"</span>)
   (baz <span style="color: #5f5f87;">:accessor</span> baz <span style="color: #5f5f87;">:initform</span> <span style="color: #87005f;">"zzzzzz"</span>)))

(<span style="color: #af00ff;">defmethod</span> <span style="color: #0000ff;">slot-missing</span> (class (instance foo) slot-name operation <span style="color: #008700;">&amp;optional</span> (new-value <span style="color: #87005f;">"defailt value"</span>))
  (<span style="color: #af00ff;">declare</span> (ignorable class))
  (print (list class instance slot-name operation new-value))
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">(err 'zz)</span>
  (add-slot-to-class (class-name class) slot-name)
  (setf (slot-value instance slot-name) new-value))

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*foo*</span> (make-instance 'foo))

(setf (slot-value *foo* 'bar) <span style="color: #87005f;">"the-bar"</span>)

(setf (slot-value *foo* 't2) <span style="color: #87005f;">"zzz"</span>)

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*foo2*</span> (make-instance 'foo))

(slot-value *foo2* 't5)

(slot-value *foo2* 'bar)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1058;&#1077;&#1089;&#1090;&#1086;&#1074;&#1086;&#1077; &#1088;&#1077;&#1079;&#1102;&#1084;&#1077;</span>
(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*test-resume*</span>
  (make-resume
   <span style="color: #5f5f87;">:last-name</span> <span style="color: #87005f;">"&#1043;&#1083;&#1091;&#1093;&#1086;&#1074;"</span>
   <span style="color: #5f5f87;">:first-name</span> <span style="color: #87005f;">"&#1052;&#1080;&#1093;&#1072;&#1080;&#1083;"</span>
   <span style="color: #5f5f87;">:middle-name</span> <span style="color: #87005f;">"&#1052;&#1080;&#1093;&#1072;&#1081;&#1083;&#1086;&#1074;&#1080;&#1095;"</span>
   <span style="color: #5f5f87;">:birthday</span> <span style="color: #87005f;">"1982-12-15"</span>
   <span style="color: #5f5f87;">:gender</span> <span style="color: #87005f;">"male"</span>
   <span style="color: #5f5f87;">:area</span> <span style="color: #87005f;">"2"</span>
   <span style="color: #5f5f87;">:metro</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:relocation</span> <span style="color: #87005f;">"relocation_possible"</span>
   <span style="color: #5f5f87;">:relocation-area</span> <span style="color: #87005f;">"1"</span>
   <span style="color: #5f5f87;">:business-trip-readiness</span> <span style="color: #87005f;">"ready"</span>
   <span style="color: #5f5f87;">:citizen-ship</span> <span style="color: #87005f;">"113"</span>
   <span style="color: #5f5f87;">:work-ticket</span> <span style="color: #87005f;">"113"</span>
   <span style="color: #5f5f87;">:travel-time</span> <span style="color: #87005f;">"any"</span>

   <span style="color: #5f5f87;">:cell-phone-country</span>      <span style="color: #87005f;">"7"</span>
   <span style="color: #5f5f87;">:cell-phone-city</span>         <span style="color: #87005f;">"911"</span>
   <span style="color: #5f5f87;">:cell-phone-number</span>       <span style="color: #87005f;">"2869290"</span>
   <span style="color: #5f5f87;">:cell-phone-comment</span>      <span style="color: #87005f;">"&#1042; &#1083;&#1102;&#1073;&#1086;&#1077; &#1074;&#1088;&#1077;&#1084;&#1103;"</span>

   <span style="color: #5f5f87;">:home-phone-country</span>      <span style="color: #87005f;">"7"</span>
   <span style="color: #5f5f87;">:home-phone-city</span>         <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:home-phone-number</span>       <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:home-phone-comment</span>      <span style="color: #87005f;">""</span>

   <span style="color: #5f5f87;">:work-phone-country</span>      <span style="color: #87005f;">"7"</span>
   <span style="color: #5f5f87;">:work-phone-city</span>         <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:work-phone-number</span>       <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:work-phone-comment</span>      <span style="color: #87005f;">""</span>

   <span style="color: #5f5f87;">:email-string</span>            <span style="color: #87005f;">"avenger-f@yandex.ru"</span>
   <span style="color: #5f5f87;">:preferred-contact</span>       <span style="color: #87005f;">"email"</span>
   <span style="color: #5f5f87;">:icq</span>                     <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:skype</span>                   <span style="color: #87005f;">"i.am.rigidus"</span>
   <span style="color: #5f5f87;">:freelance</span>               <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:moi_krug</span>                <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:linkedin</span>                <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:facebook</span>                <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:livejournal</span>             <span style="color: #87005f;">"rigidus"</span>
   <span style="color: #5f5f87;">:personal-site</span>           <span style="color: #87005f;">"https://rigidus.ru"</span>

   <span style="color: #5f5f87;">:title</span> <span style="color: #87005f;">"Programmer"</span>
   <span style="color: #5f5f87;">:specializations</span> <span style="color: #87005f;">"221"</span>
   <span style="color: #5f5f87;">:prof-area</span> <span style="color: #87005f;">"1"</span>
   <span style="color: #5f5f87;">:salary-amount</span> <span style="color: #87005f;">"160000"</span>
   <span style="color: #5f5f87;">:salary-currency</span> <span style="color: #87005f;">"RUR"</span>
   <span style="color: #5f5f87;">:employment</span> <span style="color: #87005f;">"full"</span>
   <span style="color: #5f5f87;">:work-schedule</span> <span style="color: #87005f;">"full_day"</span>

   <span style="color: #5f5f87;">:education-level-string</span> <span style="color: #87005f;">"higher"</span>
   <span style="color: #5f5f87;">:educations</span> (reduce #'(<span style="color: #af00ff;">lambda</span> (a b)
                          (format nil <span style="color: #87005f;">"~A ~A"</span> a b))
                      (mapcar #'id
                              (list
                               (make-education <span style="color: #5f5f87;">:education-id</span> <span style="color: #87005f;">"0"</span>
                                               <span style="color: #5f5f87;">:name</span> <span style="color: #87005f;">"&#1057;&#1072;&#1085;&#1082;&#1090;-&#1055;&#1077;&#1090;&#1077;&#1088;&#1073;&#1091;&#1088;&#1075;&#1089;&#1082;&#1080;&#1081; &#1075;&#1086;&#1089;&#1091;&#1076;&#1072;&#1088;&#1089;&#1090;&#1074;&#1077;&#1085;&#1085;&#1099;&#1081; &#1091;&#1085;&#1080;&#1074;&#1077;&#1088;&#1089;&#1080;&#1090;&#1077;&#1090; &#1082;&#1091;&#1083;&#1100;&#1090;&#1091;&#1088;&#1099; &#1080; &#1080;&#1089;&#1082;&#1091;&#1089;&#1089;&#1090;&#1074;, &#1057;&#1072;&#1085;&#1082;&#1090;-&#1055;&#1077;&#1090;&#1077;&#1088;&#1073;&#1091;&#1088;&#1075;"</span>
                                               <span style="color: #5f5f87;">:university-id</span> <span style="color: #87005f;">"39864"</span>
                                               <span style="color: #5f5f87;">:faculty-id</span> <span style="color: #87005f;">"0"</span>
                                               <span style="color: #5f5f87;">:organization</span> <span style="color: #87005f;">"&#1056;&#1077;&#1078;&#1080;&#1089;&#1089;&#1091;&#1088;&#1099;"</span>
                                               <span style="color: #5f5f87;">:result</span> <span style="color: #87005f;">"&#1056;&#1077;&#1078;&#1080;&#1089;&#1089;&#1091;&#1088;&#1072; &#1084;&#1091;&#1083;&#1100;&#1090;&#1080;&#1084;&#1077;&#1076;&#1080;&#1072; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;"</span>
                                               <span style="color: #5f5f87;">:specialty-id</span> <span style="color: #87005f;">"224"</span>
                                               <span style="color: #5f5f87;">:year</span> <span style="color: #87005f;">"2005"</span>)
                               (make-education <span style="color: #5f5f87;">:education-id</span> <span style="color: #87005f;">"0"</span>
                                               <span style="color: #5f5f87;">:name</span> <span style="color: #87005f;">""</span>
                                               <span style="color: #5f5f87;">:university-id</span> <span style="color: #87005f;">"0"</span>
                                               <span style="color: #5f5f87;">:faculty-id</span> <span style="color: #87005f;">"0"</span>
                                               <span style="color: #5f5f87;">:organization</span> <span style="color: #87005f;">""</span>
                                               <span style="color: #5f5f87;">:result</span> <span style="color: #87005f;">""</span>
                                               <span style="color: #5f5f87;">:specialty-id</span> <span style="color: #87005f;">"0"</span>
                                               <span style="color: #5f5f87;">:year</span> <span style="color: #87005f;">"0"</span>))))
   <span style="color: #5f5f87;">:additional-education-id</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:additional-education-name</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:additional-education-organization</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:additional-education-result</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:additional-education-year</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-id</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-type</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-selected</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-ownerName</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-transcription-id</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-password</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-title</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-achievementDate</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:certificate-url</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:attestation-education-id</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:attestation-education-name</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:attestation-education-organization</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:attestation-education-result</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:attestation-education-year</span> <span style="color: #87005f;">""</span>
   <span style="color: #5f5f87;">:languages</span> (reduce #'(<span style="color: #af00ff;">lambda</span> (a b)
                          (format nil <span style="color: #87005f;">"~A ~A"</span> a b))
                      (mapcar #'id
                              (list
                               (make-lang <span style="color: #5f5f87;">:lang-id</span> <span style="color: #87005f;">"34"</span> <span style="color: #5f5f87;">:lang-degree</span> <span style="color: #87005f;">"native"</span>)
                               (make-lang <span style="color: #5f5f87;">:lang-id</span> <span style="color: #87005f;">"57"</span> <span style="color: #5f5f87;">:lang-degree</span> <span style="color: #87005f;">"can_read"</span>)
                               (make-lang <span style="color: #5f5f87;">:lang-id</span> <span style="color: #87005f;">"58"</span> <span style="color: #5f5f87;">:lang-degree</span> <span style="color: #87005f;">"basic"</span>)
                               (make-lang <span style="color: #5f5f87;">:lang-id</span> <span style="color: #87005f;">"59"</span> <span style="color: #5f5f87;">:lang-degree</span> <span style="color: #87005f;">"none"</span>))))
   <span style="color: #5f5f87;">:expiriences</span> (reduce #'(<span style="color: #af00ff;">lambda</span> (a b)
                            (format nil <span style="color: #87005f;">"~A ~A"</span> a b))
                        (mapcar #'id
                                (list
                                 (make-expirience
                                  <span style="color: #5f5f87;">:name</span>         <span style="color: #87005f;">"&#1051;&#1072;&#1073;&#1086;&#1088;&#1072;&#1090;&#1086;&#1088;&#1080;&#1103; &#1050;&#1072;&#1089;&#1087;&#1077;&#1088;&#1089;&#1082;&#1086;&#1075;&#1086;"</span>
                                  <span style="color: #5f5f87;">:company-id</span>   <span style="color: #87005f;">"1057"</span>
                                  <span style="color: #5f5f87;">:company-area-id</span> <span style="color: #87005f;">"1"</span>
                                  <span style="color: #5f5f87;">:area-id</span>      <span style="color: #87005f;">"1"</span>
                                  <span style="color: #5f5f87;">:url</span>          <span style="color: #87005f;">""</span>
                                  <span style="color: #5f5f87;">:industry-id</span>  <span style="color: #87005f;">"0"</span>
                                  <span style="color: #5f5f87;">:industries</span>   <span style="color: #87005f;">"540"</span>
                                  <span style="color: #5f5f87;">:industries</span>   <span style="color: #87005f;">""</span>
                                  <span style="color: #5f5f87;">:exp-id</span>       <span style="color: #87005f;">""</span>
                                  <span style="color: #5f5f87;">:job-position</span> <span style="color: #87005f;">"&#1055;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1089;&#1090;"</span>
                                  <span style="color: #5f5f87;">:start-date</span>   <span style="color: #87005f;">"2000-01-01"</span>
                                  <span style="color: #5f5f87;">:end-date</span>     <span style="color: #87005f;">"2001-01-01"</span>
                                  <span style="color: #5f5f87;">:description</span>  <span style="color: #87005f;">"&#1056;&#1072;&#1073;&#1086;&#1090;&#1072; &#1079;&#1072; &#1076;&#1077;&#1085;&#1100;&#1075;&#1080;"</span>)
                                 (make-expirience
                                  <span style="color: #5f5f87;">:name</span>         <span style="color: #87005f;">"&#1042;&#1099;&#1084;&#1087;&#1077;&#1083;&#1082;&#1086;&#1084;"</span>
                                  <span style="color: #5f5f87;">:company-id</span>   <span style="color: #87005f;">"4934"</span>
                                  <span style="color: #5f5f87;">:company-area-id</span> <span style="color: #87005f;">"1"</span>
                                  <span style="color: #5f5f87;">:area-id</span>      <span style="color: #87005f;">"1"</span>
                                  <span style="color: #5f5f87;">:url</span>          <span style="color: #87005f;">""</span>
                                  <span style="color: #5f5f87;">:industry-id</span>  <span style="color: #87005f;">"0"</span>
                                  <span style="color: #5f5f87;">:industries</span>   <span style="color: #87005f;">"399"</span>
                                  <span style="color: #5f5f87;">:exp-id</span>       <span style="color: #87005f;">""</span>
                                  <span style="color: #5f5f87;">:job-position</span> <span style="color: #87005f;">"&#1055;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1089;&#1090;"</span>
                                  <span style="color: #5f5f87;">:start-date</span>   <span style="color: #87005f;">"2001-01-01"</span>
                                  <span style="color: #5f5f87;">:end-date</span>     <span style="color: #87005f;">"2005-01-01"</span>
                                  <span style="color: #5f5f87;">:description</span>  <span style="color: #87005f;">"&#1056;&#1072;&#1073;&#1086;&#1090;&#1072; &#1079;&#1072; &#1077;&#1076;&#1091; )"</span>))))
   <span style="color: #5f5f87;">:skills</span> (reduce #'(<span style="color: #af00ff;">lambda</span> (a b)
                       (format nil <span style="color: #87005f;">"~A ~A"</span> a b))
                   (mapcar #'id
                           (list
                            (make-skill <span style="color: #5f5f87;">:name</span> <span style="color: #87005f;">"&#1056;&#1072;&#1079;&#1088;&#1072;&#1073;&#1086;&#1090;&#1082;&#1072; &#1072;&#1088;&#1093;&#1080;&#1090;&#1077;&#1082;&#1090;&#1091;&#1088;&#1099;"</span>)
                            (make-skill <span style="color: #5f5f87;">:name</span> <span style="color: #87005f;">"&#1042;&#1072;&#1082;&#1091;&#1091;&#1084;&#1085;&#1072;&#1103; &#1095;&#1080;&#1089;&#1090;&#1082;&#1072; &#1083;&#1080;&#1094;&#1072;"</span>))))
   <span style="color: #5f5f87;">:skills-string</span> <span style="color: #87005f;">"&#1042; &#1087;&#1086;&#1089;&#1083;&#1077;&#1076;&#1085;&#1080;&#1077; &#1075;&#1086;&#1076;&#1099; &#1085;&#1072;&#1093;&#1086;&#1078;&#1091;&#1089;&#1100; &#1085;&#1072; &#1087;&#1077;&#1085;&#1089;&#1080;&#1080; )"</span>
   <span style="color: #5f5f87;">:recommendations</span> (reduce #'(<span style="color: #af00ff;">lambda</span> (a b)
                                (format nil <span style="color: #87005f;">"~A ~A"</span> a b))
                            (mapcar #'id
                                    (list
                                     (make-recommendation
                                      <span style="color: #5f5f87;">:recommendation-id</span> <span style="color: #87005f;">"0"</span>
                                      <span style="color: #5f5f87;">:name</span>              <span style="color: #87005f;">"&#1057;&#1084;&#1080;&#1088;&#1085;&#1086;&#1074;"</span>
                                      <span style="color: #5f5f87;">:job-position</span>      <span style="color: #87005f;">"&#1053;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1080;&#1082;"</span>
                                      <span style="color: #5f5f87;">:organization</span>      <span style="color: #87005f;">"&#1040;&#1088;&#1084;&#1080;&#1103;"</span>
                                      <span style="color: #5f5f87;">:contact-info</span>      <span style="color: #87005f;">"9112869290"</span>)
                                     (make-recommendation
                                      <span style="color: #5f5f87;">:recommendation-id</span> <span style="color: #87005f;">"0"</span>
                                      <span style="color: #5f5f87;">:name</span>              <span style="color: #87005f;">"&#1048;&#1074;&#1072;&#1085;&#1086;&#1074;"</span>
                                      <span style="color: #5f5f87;">:job-position</span>      <span style="color: #87005f;">"&#1047;&#1072;&#1084;&#1087;&#1086;&#1090;&#1077;&#1093;"</span>
                                      <span style="color: #5f5f87;">:organization</span>      <span style="color: #87005f;">"&#1040;&#1088;&#1084;&#1080;&#1103;"</span>
                                      <span style="color: #5f5f87;">:contact-info</span>      <span style="color: #87005f;">"9112878789"</span>))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> <span class="todo TODO">TODO</span> Вспомогательные сущности резюме</h3>
<div class="outline-text-3" id="text-4-4">
</div><div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1"><span class="section-number-4">4.4.1</span> Основное образование</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
[TODO] - Написать процедуру сопоставления вузов, факультетов и их идентификаторов на hh
</p>

<table id="education_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 7:</span> Данные основного образования</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">education-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор обучалки на hh (как правило пустой)</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">название учебного заведения</td>
</tr>

<tr>
<td class="left">university-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор учебного заведения (если оно есть в базе hh)</td>
</tr>

<tr>
<td class="left">faculty-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор факультета</td>
</tr>

<tr>
<td class="left">organization</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">факультет</td>
</tr>

<tr>
<td class="left">result</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">специальность</td>
</tr>

<tr>
<td class="left">specialty-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор специальности</td>
</tr>

<tr>
<td class="left">year</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">год окончания</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-4-2" class="outline-4">
<h4 id="sec-4-4-2"><span class="section-number-4">4.4.2</span> Иностранные языки</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
[TODO] - Написать процедуру сопоставления языков и их идентификаторов на hh
</p>

<table id="lang_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 8:</span> Данные иностранного языка</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">язык</td>
</tr>

<tr>
<td class="left">lang-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор на hh</td>
</tr>

<tr>
<td class="left">lang-degree</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">уровень владения</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-4-3" class="outline-4">
<h4 id="sec-4-4-3"><span class="section-number-4">4.4.3</span> Опыт работы</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
[TODO] - Посмотреть что значат некоторые поля
</p>

<table id="expirience_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 9:</span> Данные опыта работы</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">название компании</td>
</tr>

<tr>
<td class="left">company-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор компании на hh</td>
</tr>

<tr>
<td class="left">company-area-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентикатор города компании?</td>
</tr>

<tr>
<td class="left">url</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">сайт компании</td>
</tr>

<tr>
<td class="left">industry-id</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">предположительно отрасль компании (как правило пуста)</td>
</tr>

<tr>
<td class="left">industries</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">предположительно направления деятельности</td>
</tr>

<tr>
<td class="left">exp-id</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">не знаю что это такое</td>
</tr>

<tr>
<td class="left">job-position</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">должность</td>
</tr>

<tr>
<td class="left">start-date</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">начало работы</td>
</tr>

<tr>
<td class="left">end-date</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">окончание работы</td>
</tr>

<tr>
<td class="left">description</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">описание достижений</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-4-4" class="outline-4">
<h4 id="sec-4-4-4"><span class="section-number-4">4.4.4</span> Ключевые навыки</h4>
<div class="outline-text-4" id="text-4-4-4">
<table id="skill_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 10:</span> Данные ключевых навыков</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">название навыка</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-4-5" class="outline-4">
<h4 id="sec-4-4-5"><span class="section-number-4">4.4.5</span> Рекоммендации</h4>
<div class="outline-text-4" id="text-4-4-5">
<table id="recommendation_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 11:</span> Данные ключевых навыков</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">recommendation-id</td>
<td class="left">integer</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор рекомендации на hh</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">имя рекомендателя</td>
</tr>

<tr>
<td class="left">job-position</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">позиция рекомендателя</td>
</tr>

<tr>
<td class="left">organization</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">организация рекоммендателя</td>
</tr>

<tr>
<td class="left">contact-info</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">контактная информация</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-4-6" class="outline-4">
<h4 id="sec-4-4-6"><span class="section-number-4">4.4.6</span> Портфолио</h4>
<div class="outline-text-4" id="text-4-4-6">
<table id="portfolio_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 12:</span> Данные портфолио</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">descr</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">описание файла</td>
</tr>

<tr>
<td class="left">file</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">файл</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Сущность правила (<code>entity:rule</code>)</h3>
<div class="outline-text-3" id="text-4-5">
<p>
У нас есть два вида правил - для работы с тизерами и для обработки вакансий. Каждое
правило закреплено за пользователем, который им владеет и имеет ранг, в соответствии с
котором сортируется при применении набора правил.
</p>

<table id="rule_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 13:</span> Данные правила</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">name</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">имя</td>
</tr>

<tr>
<td class="left">user-id</td>
<td class="left">integer</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">владелец правила</td>
</tr>

<tr>
<td class="left">rank</td>
<td class="left">integer</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">приоритет правила</td>
</tr>

<tr>
<td class="left">ruletype</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">:teaser - правило для тизеров, :vacancy - для вакансий</td>
</tr>

<tr>
<td class="left">antecedent</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">условие срабатывания правила</td>
</tr>

<tr>
<td class="left">consequent</td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">код правила</td>
</tr>

<tr>
<td class="left">notes</td>
<td class="left">(or db-null varchar)</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">заметки к правилу</td>
</tr>
</tbody>
</table>

<p>
Правило может быть активным и неактивным
</p>

<table id="rule_state" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 14:</span> Состояния конечного автомата правила</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">action</th>
<th scope="col" class="left">from</th>
<th scope="col" class="left">to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">rule-activation</td>
<td class="left">active</td>
<td class="left">inactive</td>
</tr>

<tr>
<td class="left">rule-deactivation</td>
<td class="left">inactive</td>
<td class="left">active</td>
</tr>
</tbody>
</table>

<div class="org-src-container">

<pre class="src src-lisp" id="hh_fn_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">rule-activation</span> ()
  <span style="color: #87005f;">"| active   | inactive |"</span>)
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">rule-deactivation</span> ()
  <span style="color: #87005f;">"| inactive | active   |"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Аккаунт на источнике вакансий</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Для того чтобы иметь возможность работать в нескольких одновременных сессиях
внутри одного потока выполнения мы осуществляем поддержку сессий следующим
образом: Все вызовы получения страниц (<code>hh-get-page</code>) работают таким образом, как
будто считают себя по умолчанию залогиненными в сессию, для этого им передается
параметр cookie-jar. В случае, если по каким-то причинам это оказалось не так -
сессия восстанавливается вызовом <code>recovery-login</code>, который получает
авторизационную информацияю из объекта <code>src-account</code>, который также протягивается
через всю цепочку: <code>factory</code> -&gt; <code>get-vacancy::closure</code> -&gt; <code>hh-get-page</code> -&gt;
<code>recovery-login</code>. Возвращаемые из <code>recovery-login</code> куки попадают в замыкание и в
дальнейшем используются для работы в сессии.
</p>

<p>
Таким образом можно внутри одного потока выполения иметь несколько замыканий,
каждое из которых работает в своей сессии. Они могут выполнять разнообразные
задачи - сбор вакансий, отзывыв, опубликование резюме и.т.п. Для источника
вакансий это будет выглядеть как несколько пользователей, работающих с одного
адреса.
</p>

<table id="srcaccount_flds" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 15:</span> Данные таблицы аккаунтов</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">field name</th>
<th scope="col" class="left">field type</th>
<th scope="col" class="left">default</th>
<th scope="col" class="left">meta</th>
<th scope="col" class="left">note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">id</td>
<td class="left">serial</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор</td>
</tr>

<tr>
<td class="left">user<sub>id</sub></td>
<td class="left">integer</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор пользователя, владеющего логином</td>
</tr>

<tr>
<td class="left">src<sub>source</sub></td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">идентификатор источника ("hh" - для headhunter.ru)</td>
</tr>

<tr>
<td class="left">src<sub>login</sub></td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">логин пользователя на источнике</td>
</tr>

<tr>
<td class="left">src<sub>password</sub></td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">пароль пользователя на источнике</td>
</tr>

<tr>
<td class="left">src<sub>fio</sub></td>
<td class="left">varchar</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">ФИО пользователя, чтобы определить что вход в профиль успешен</td>
</tr>
</tbody>
</table>

<p>
Аккаунты могут быть активные и неактивные. С неактивными аккаунтами никаких
действий (сбор вакансий, проверка отзывов) не производится.
</p>

<p>
Если трижды не удалось залогиниться на аккаунте, он переводится в состояние
<code>wrong</code> после чего требуется ручное устранение ошибки.
</p>

<table id="srcaccount_state" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 16:</span> Состояния конечного автомата аккаунта</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">action</th>
<th scope="col" class="left">from</th>
<th scope="col" class="left">to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">account-activation</td>
<td class="left">active</td>
<td class="left">inactive</td>
</tr>

<tr>
<td class="left">account-deactivation</td>
<td class="left">inactive</td>
<td class="left">active</td>
</tr>

<tr>
<td class="left">account-login</td>
<td class="left">active</td>
<td class="left">logged</td>
</tr>

<tr>
<td class="left">account-logout</td>
<td class="left">logged</td>
<td class="left">active</td>
</tr>

<tr>
<td class="left">account-wrong</td>
<td class="left">active</td>
<td class="left">wrong</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Компоненты</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Получение, разбор и сохранение вакансий</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Мы можем получать вакансии с разных сайтов, поэтому самое первое, что следует
определить - это источник вакансий, например, сайт <a href="https://hh.ru/">https://hh.ru/</a>
</p>

<p>
Большинство сайтов источников устроено сходным образом - пользователь может
определить <code>критерии поиска</code> и получить по ним набор вакансий. В зависимости от
интерфейса, это может быть разбитая на страницы выборка или страници с бесконечным
скроллом.
</p>

<p>
В любом случае, я бы хотел не столько получить весь контейнер с вакансиями,
соответствующими <code>критериям поиска</code>, сколько иметь возможность извлечь следующую
вакансию, как только она нам понадобится. Поэтому необходимо иметь некторорую
функцию-генератор, которая при вызове возвратит следующую вакансию, или указание на
то, что вакансий больше нет.
</p>

<p>
Но так как у нас могут быть разные источники, то мы можем конструировать такие
функции-генераторы с помощью <code>фабрики</code>, передавая этой фабрике параметры, в которых
указано, какой сайт-источник должен использоваться и <code>критерии поиска</code>
</p>

<p>
<a href="./vacancy.html">./vacancy.html</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Посылка откликов и работа с ними</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<a href="./response.html">./response.html</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Создание и управление резюме</h3>
<div class="outline-text-3" id="text-5-3">
<p>
<a href="./resume.html">./resume.html</a>
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Интерфейс модуля</h3>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Тесты</h2>
<div class="outline-text-2" id="text-6">
<div class="org-src-container">

<pre class="src src-lisp" id="hh_test"><span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1058;&#1077;&#1089;&#1090;&#1080;&#1088;&#1091;&#1077;&#1084; hh</span>
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">hh-test</span> ()
  &lt;&lt;hh_test_contents&gt;&gt;
  (dbg <span style="color: #87005f;">"passed: hh-test~%"</span>))
(hh-test)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-lisp" id="hh_test_contents"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Точки входа</h2>
<div class="outline-text-2" id="text-7">
<p>
Соберем шаблоны:
</p>

<div class="org-src-container">

<pre class="src src-closure-template-html" id="hh_tpl"><span style="color: #af0000;">// -*- mode: closure-template-html; fill-column: 140 -*-</span>
{<span style="color: #008700; font-weight: bold;">namespace</span> <span style="color: #0000ff;">hhtpl</span>}

&lt;&lt;<span style="color: #0000ff;">hhtpl_contents</span>&gt;&gt;
</pre>
</div>

<p>
Скомпилируем шаблоны при подготовке модуля
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="hh_prepare">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1057;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; &#1096;&#1072;&#1073;&#1083;&#1086;&#1085;</span>
(closure-template:compile-template
 <span style="color: #5f5f87;">:common-lisp-backend</span>
 (pathname
  (concatenate 'string *base-path* <span style="color: #87005f;">"mod/hh/hh-tpl.htm"</span>)))
</pre>
</div>

<p>
Соберем контроллеры и все функции, которые контроллеры вызывают
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="hh_fn">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1069;&#1090;&#1086; &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1074; vacancy.lisp</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">special syntax for pattern-matching - ON</span>
(named-readtables:in-readtable <span style="color: #5f5f87;">:fare-quasiquote</span>)
&lt;&lt;tree_match&gt;&gt;
&lt;&lt;run&gt;&gt;

<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1069;&#1090;&#1086; &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1074; response.lisp</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">&lt;&lt;run_response&gt;&gt;</span>

&lt;&lt;hh_fn_contents&gt;&gt;

&lt;&lt;hh_test&gt;&gt;

<span style="color: #af0000;">;; </span><span style="color: #af0000;">Pattern matching test</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">(dbg "match_1: ~A" (match 1 (1 2)))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">(dbg "match_2: ~A" (match '(1 2 3 4) (`(1 ,x ,@y) (list x y))))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">special syntax for pattern-matching - OFF</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">(named-readtables:in-readtable :standard)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Сборка</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> Макроутилиты</h3>
<div class="outline-text-3" id="text-8-1">
<p>
[TODO] - Применение макросов отсюда:
<a href="https://github.com/magnars/dash.el/blob/master/dash.el#L1186">https://github.com/magnars/dash.el/blob/master/dash.el#L1186</a>
наверное существенно упростит код.
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="todomacro"><span style="color: #af0000;">;;; </span><span style="color: #af0000;">dash.el --- A modern list library for Emacs  -*- lexical-binding: t -*-</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">Copyright (C) 2012-2015 Free Software Foundation, Inc.</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">Author: Magnar Sveen &lt;<a href="mailto:magnars&#64;gmail.com">magnars&#64;gmail.com</a>&gt;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">Version: 2.12.1</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">Keywords: lists</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">This program is free software; you can redistribute it and/or modify</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">it under the terms of the GNU General Public License as published by</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">the Free Software Foundation, either version 3 of the License, or</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">(at your option) any later version.</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">This program is distributed in the hope that it will be useful,</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">GNU General Public License for more details.</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">You should have received a copy of the GNU General Public License</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">along with this program.  If not, see &lt;<a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>&gt;.</span>

<span style="color: #af0000;">;;; </span><span style="color: #af0000;">Commentary:</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">A modern list api for Emacs.</span>
<span style="color: #af0000;">;;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">See documentation on https://github.com/magnars/dash.el#functions</span>
<span style="color: #af0000;">;;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">**Please note** The lexical binding in this file is not utilised at the</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">moment. We will take full advantage of lexical binding in an upcoming 3.0</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">release of Dash. In the meantime, we've added the pragma to avoid a bug that</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">you can read more about in https://github.com/magnars/dash.el/issues/130.</span>
<span style="color: #af0000;">;;</span>

<span style="color: #af0000;">;;; </span><span style="color: #af0000;">Code:</span>

(defgroup dash ()
  <span style="color: #87005f;">"Customize group for dash.el"</span>
  <span style="color: #5f5f87;">:group</span> 'lisp
  <span style="color: #5f5f87;">:prefix</span> <span style="color: #87005f;">"dash-"</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--enable-fontlock</span> (symbol value)
  (<span style="color: #af00ff;">when</span> value
    (dash-enable-font-lock))
  (set-default symbol value))

(defcustom dash-enable-fontlock nil
  <span style="color: #87005f;">"If non-nil, enable fontification of dash functions, macros and</span>
<span style="color: #87005f;">special values."</span>
  <span style="color: #5f5f87;">:type</span> 'boolean
  <span style="color: #5f5f87;">:set</span> 'dash--enable-fontlock
  <span style="color: #5f5f87;">:group</span> 'dash)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">!cons</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">!cdr</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">--each</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">-each</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">--map-when</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">-map-when</span>

(put '-each 'lisp-indent-function 1)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--each-while</span> (list pred <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-each-while</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form body))
           (indent 2))
  (<span style="color: #af00ff;">let</span> ((l (make-symbol <span style="color: #87005f;">"list"</span>))
        (c (make-symbol <span style="color: #87005f;">"continue"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,l ,list)
           (,c t)
           (it-index 0))
       (<span style="color: #af00ff;">while</span> (and ,l ,c)
         (<span style="color: #af00ff;">let</span> ((it (car ,l)))
           (<span style="color: #af00ff;">if</span> (not ,pred) (setq ,c nil) ,@body))
         (setq it-index (1+ it-index))
         (!cdr ,l)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-each-while</span> (list pred fn)
  <span style="color: #87005f;">"Call FN with every item in LIST while (PRED item) is non-nil.</span>
<span style="color: #87005f;">Return nil, used for side-effects only."</span>
  (--each-while list (funcall pred it) (funcall fn it)))

(put '-each-while 'lisp-indent-function 2)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--dotimes</span> (num <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"Repeatedly executes BODY (presumably for side-effects) with `it` bound to integers from 0 through NUM-1."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form body))
           (indent 1))
  (<span style="color: #af00ff;">let</span> ((n (make-symbol <span style="color: #87005f;">"num"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,n ,num)
           (it 0))
       (<span style="color: #af00ff;">while</span> (&lt; it ,n)
         ,@body
         (setq it (1+ it))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-dotimes</span> (num fn)
  <span style="color: #87005f;">"Repeatedly calls FN (presumably for side-effects) passing in integers from 0 through NUM-1."</span>
  (--dotimes num (funcall fn it)))

(put '-dotimes 'lisp-indent-function 1)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-map</span> (fn list)
  <span style="color: #87005f;">"Return a new list consisting of the result of applying FN to the items in LIST."</span>
  (mapcar fn list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--map</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-map</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(mapcar (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--reduce-from</span> (form initial-value list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-reduce-from</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form)))
  `(<span style="color: #af00ff;">let</span> ((acc ,initial-value))
     (--each ,list (setq acc ,form))
     acc))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-reduce-from</span> (fn initial-value list)
  <span style="color: #87005f;">"Return the result of applying FN to INITIAL-VALUE and the</span>
<span style="color: #87005f;">first item in LIST, then applying FN to that result and the 2nd</span>
<span style="color: #87005f;">item, etc. If LIST contains no items, return INITIAL-VALUE and</span>
<span style="color: #87005f;">FN is not called.</span>

<span style="color: #87005f;">In the anaphoric form `</span><span style="color: #008787;">--reduce-from</span><span style="color: #87005f;">', the accumulated value is</span>
<span style="color: #87005f;">exposed as `acc`.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-reduce</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-reduce-r</span><span style="color: #87005f;">'"</span>
  (--reduce-from (funcall fn acc it) initial-value list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--reduce</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-reduce</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((lv (make-symbol <span style="color: #87005f;">"list-value"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,lv ,list))
       (<span style="color: #af00ff;">if</span> ,lv
           (--reduce-from ,form (car ,lv) (cdr ,lv))
           (<span style="color: #af00ff;">let</span> (acc it) ,form)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-reduce</span> (fn list)
  <span style="color: #87005f;">"Return the result of applying FN to the first 2 items in LIST,</span>
<span style="color: #87005f;">then applying FN to that result and the 3rd item, etc. If LIST</span>
<span style="color: #87005f;">contains no items, FN must accept no arguments as well, and</span>
<span style="color: #87005f;">reduce return the result of calling FN with no arguments. If</span>
<span style="color: #87005f;">LIST has only 1 item, it is returned and FN is not called.</span>

<span style="color: #87005f;">In the anaphoric form `</span><span style="color: #008787;">--reduce</span><span style="color: #87005f;">', the accumulated value is</span>
<span style="color: #87005f;">exposed as `acc`.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-reduce-from</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-reduce-r</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">if</span> list
      (-reduce-from fn (car list) (cdr list))
      (funcall fn)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-reduce-r-from</span> (fn initial-value list)
  <span style="color: #87005f;">"Replace conses with FN, nil with INITIAL-VALUE and evaluate</span>
<span style="color: #87005f;">the resulting expression. If LIST is empty, INITIAL-VALUE is</span>
<span style="color: #87005f;">returned and FN is not called.</span>

<span style="color: #87005f;">Note: this function works the same as `</span><span style="color: #008787;">-reduce-from</span><span style="color: #87005f;">' but the</span>
<span style="color: #87005f;">operation associates from right instead of from left.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-reduce-r</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-reduce</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">if</span> (not list) initial-value
      (funcall fn (car list) (-reduce-r-from fn initial-value (cdr list)))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--reduce-r-from</span> (form initial-value list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-reduce-r-from</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form)))
  `(-reduce-r-from (<span style="color: #af00ff;">lambda</span> (<span style="color: #008700;">&amp;optional</span> it acc) ,form) ,initial-value ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-reduce-r</span> (fn list)
  <span style="color: #87005f;">"Replace conses with FN and evaluate the resulting expression.</span>
<span style="color: #87005f;">The final nil is ignored. If LIST contains no items, FN must</span>
<span style="color: #87005f;">accept no arguments as well, and reduce return the result of</span>
<span style="color: #87005f;">calling FN with no arguments. If LIST has only 1 item, it is</span>
<span style="color: #87005f;">returned and FN is not called.</span>

<span style="color: #87005f;">The first argument of FN is the new item, the second is the</span>
<span style="color: #87005f;">accumulated value.</span>

<span style="color: #87005f;">Note: this function works the same as `</span><span style="color: #008787;">-reduce</span><span style="color: #87005f;">' but the operation</span>
<span style="color: #87005f;">associates from right instead of from left.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-reduce-r-from</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-reduce</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">cond</span>
    ((not list) (funcall fn))
    ((not (cdr list)) (car list))
    (t (funcall fn (car list) (-reduce-r fn (cdr list))))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--reduce-r</span> (form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-reduce-r</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-reduce-r (<span style="color: #af00ff;">lambda</span> (<span style="color: #008700;">&amp;optional</span> it acc) ,form) ,list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--filter</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-filter</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>)))
    `(<span style="color: #af00ff;">let</span> (,r)
       (--each ,list (<span style="color: #af00ff;">when</span> ,form (!cons it ,r)))
       (nreverse ,r))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-filter</span> (pred list)
  <span style="color: #87005f;">"Return a new list of the items in LIST for which PRED returns a non-nil value.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-select</span><span style="color: #87005f;">'"</span>
  (--filter (funcall pred it) list))

(defalias '-select '-filter)
(defalias '--select '--filter)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--remove</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-remove</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(--filter (not ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-remove</span> (pred list)
  <span style="color: #87005f;">"Return a new list of the items in LIST for which PRED returns nil.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-reject</span><span style="color: #87005f;">'"</span>
  (--remove (funcall pred it) list))

(defalias '-reject '-remove)
(defalias '--reject '--remove)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-remove-first</span> (pred list)
  <span style="color: #87005f;">"Return a new list with the first item matching PRED removed.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-reject-first</span><span style="color: #87005f;">'</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-remove</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-map-first</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> (front)
    (<span style="color: #af00ff;">while</span> (and list (not (funcall pred (car list))))
      (push (car list) front)
      (!cdr list))
    (<span style="color: #af00ff;">if</span> list
        (-concat (nreverse front) (cdr list))
        (nreverse front))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--remove-first</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-remove-first</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-remove-first (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(defalias '-reject-first '-remove-first)
(defalias '--reject-first '--remove-first)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-remove-last</span> (pred list)
  <span style="color: #87005f;">"Return a new list with the last item matching PRED removed.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-reject-last</span><span style="color: #87005f;">'</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-remove</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-map-last</span><span style="color: #87005f;">'"</span>
  (nreverse (-remove-first pred (nreverse list))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--remove-last</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-remove-last</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-remove-last (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(defalias '-reject-last '-remove-last)
(defalias '--reject-last '--remove-last)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-remove-item</span> (item list)
  <span style="color: #87005f;">"Remove all occurences of ITEM from LIST.</span>

<span style="color: #87005f;">Comparison is done with `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">'."</span>
  (--remove (equal it item) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--keep</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-keep</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>))
        (m (make-symbol <span style="color: #87005f;">"mapped"</span>)))
    `(<span style="color: #af00ff;">let</span> (,r)
       (--each ,list (<span style="color: #af00ff;">let</span> ((,m ,form)) (<span style="color: #af00ff;">when</span> ,m (!cons ,m ,r))))
       (nreverse ,r))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-keep</span> (fn list)
  <span style="color: #87005f;">"Return a new list of the non-nil results of applying FN to the items in LIST.</span>

<span style="color: #87005f;">If you want to select the original items satisfying a predicate use `</span><span style="color: #008787;">-filter</span><span style="color: #87005f;">'."</span>
  (--keep (funcall fn it) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-non-nil</span> (list)
  <span style="color: #87005f;">"Return all non-nil elements of LIST."</span>
  (-remove 'null list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--map-indexed</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-map-indexed</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>)))
    `(<span style="color: #af00ff;">let</span> (,r)
       (--each ,list
               (!cons ,form ,r))
       (nreverse ,r))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-map-indexed</span> (fn list)
  <span style="color: #87005f;">"Return a new list consisting of the result of (FN index item) for each item in LIST.</span>

<span style="color: #87005f;">In the anaphoric form `</span><span style="color: #008787;">--map-indexed</span><span style="color: #87005f;">', the index is exposed as `it-index`."</span>
  (--map-indexed (funcall fn it-index it) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--map-when</span> (pred rep list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-map-when</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>)))
    `(<span style="color: #af00ff;">let</span> (,r)
       (--each ,list (!cons (<span style="color: #af00ff;">if</span> ,pred ,rep it) ,r))
       (nreverse ,r))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-map-when</span> (pred rep list)
  <span style="color: #87005f;">"Return a new list where the elements in LIST that does not match the PRED function</span>
<span style="color: #87005f;">are unchanged, and where the elements in LIST that do match the PRED function are mapped</span>
<span style="color: #87005f;">through the REP function.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-replace-where</span><span style="color: #87005f;">'</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-update-at</span><span style="color: #87005f;">'"</span>
  (--map-when (funcall pred it) (funcall rep it) list))

(defalias '-replace-where '-map-when)
(defalias '--replace-where '--map-when)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-map-first</span> (pred rep list)
  <span style="color: #87005f;">"Replace first item in LIST satisfying PRED with result of REP called on this item.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-map-when</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-replace-first</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> (front)
    (<span style="color: #af00ff;">while</span> (and list (not (funcall pred (car list))))
      (push (car list) front)
      (!cdr list))
    (<span style="color: #af00ff;">if</span> list
        (-concat (nreverse front) (cons (funcall rep (car list)) (cdr list)))
        (nreverse front))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--map-first</span> (pred rep list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-map-first</span><span style="color: #87005f;">'."</span>
  `(-map-first (<span style="color: #af00ff;">lambda</span> (it) ,pred) (<span style="color: #af00ff;">lambda</span> (it) (ignore it) ,rep) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-map-last</span> (pred rep list)
  <span style="color: #87005f;">"Replace first item in LIST satisfying PRED with result of REP called on this item.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-map-when</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-replace-last</span><span style="color: #87005f;">'"</span>
  (nreverse (-map-first pred rep (nreverse list))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--map-last</span> (pred rep list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-map-last</span><span style="color: #87005f;">'."</span>
  `(-map-last (<span style="color: #af00ff;">lambda</span> (it) ,pred) (<span style="color: #af00ff;">lambda</span> (it) (ignore it) ,rep) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-replace</span> (old new list)
  <span style="color: #87005f;">"Replace all OLD items in LIST with NEW.</span>

<span style="color: #87005f;">Elements are compared using `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-replace-at</span><span style="color: #87005f;">'"</span>
  (--map-when (equal it old) new list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-replace-first</span> (old new list)
  <span style="color: #87005f;">"Replace the first occurence of OLD with NEW in LIST.</span>

<span style="color: #87005f;">Elements are compared using `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-map-first</span><span style="color: #87005f;">'"</span>
  (--map-first (equal old it) new list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-replace-last</span> (old new list)
  <span style="color: #87005f;">"Replace the last occurence of OLD with NEW in LIST.</span>

<span style="color: #87005f;">Elements are compared using `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-map-last</span><span style="color: #87005f;">'"</span>
  (--map-last (equal old it) new list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--mapcat</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-mapcat</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(apply 'append (--map ,form ,list)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-mapcat</span> (fn list)
  <span style="color: #87005f;">"Return the concatenation of the result of mapping FN over LIST.</span>
<span style="color: #87005f;">Thus function FN should return a list."</span>
  (--mapcat (funcall fn it) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-flatten</span> (l)
  <span style="color: #87005f;">"Take a nested list L and return its contents as a single, flat list.</span>

<span style="color: #87005f;">Note that because `</span><span style="color: #008787;">nil</span><span style="color: #87005f;">' represents a list of zero elements (an</span>
<span style="color: #87005f;">empty list), any mention of nil in L will disappear after</span>
<span style="color: #87005f;">flattening.  If you need to preserve nils, consider `</span><span style="color: #008787;">-flatten-n</span><span style="color: #87005f;">'</span>
<span style="color: #87005f;">or map them to some unique symbol and then map them back.</span>

<span style="color: #87005f;">Conses of two atoms are considered \"terminals\", that is, they</span>
<span style="color: #87005f;">aren't flattened further.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-flatten-n</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">if</span> (and (listp l) (listp (cdr l)))
      (-mapcat '-flatten l)
      (list l)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--iterate</span> (form init n)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-iterate</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form)))
  `(-iterate (<span style="color: #af00ff;">lambda</span> (it) ,form) ,init ,n))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-flatten-n</span> (num list)
  <span style="color: #87005f;">"Flatten NUM levels of a nested LIST.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-flatten</span><span style="color: #87005f;">'"</span>
  (-last-item (--iterate (--mapcat (-list it) it) list (1+ num))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-concat</span> (<span style="color: #008700;">&amp;rest</span> lists)
  <span style="color: #87005f;">"Return a new list with the concatenation of the elements in the supplied LISTS."</span>
  (apply 'append lists))

(defalias '-copy 'copy-sequence
  <span style="color: #87005f;">"Create a shallow copy of LIST."</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-splice</span> (pred fun list)
  <span style="color: #87005f;">"Splice lists generated by FUN in place of elements matching PRED in LIST.</span>

<span style="color: #87005f;">FUN takes the element matching PRED as input.</span>

<span style="color: #87005f;">This function can be used as replacement for `,@' in case you</span>
<span style="color: #87005f;">need to splice several lists at marked positions (for example</span>
<span style="color: #87005f;">with keywords).</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-splice-list</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-insert-at</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> (r)
    (--each list
            (<span style="color: #af00ff;">if</span> (funcall pred it)
                (<span style="color: #af00ff;">let</span> ((new (funcall fun it)))
                  (--each new (!cons it r)))
                (!cons it r)))
    (nreverse r)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--splice</span> (pred form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-splice</span><span style="color: #87005f;">'."</span>
  `(-splice (<span style="color: #af00ff;">lambda</span> (it) ,pred) (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-splice-list</span> (pred new-list list)
  <span style="color: #87005f;">"Splice NEW-LIST in place of elements matching PRED in LIST.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-splice</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-insert-at</span><span style="color: #87005f;">'"</span>
  (-splice pred (<span style="color: #af00ff;">lambda</span> (_) new-list) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--splice-list</span> (pred new-list list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-splice-list</span><span style="color: #87005f;">'."</span>
  `(-splice-list (<span style="color: #af00ff;">lambda</span> (it) ,pred) ,new-list ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-cons*</span> (<span style="color: #008700;">&amp;rest</span> args)
  <span style="color: #87005f;">"Make a new list from the elements of ARGS.</span>

<span style="color: #87005f;">The last 2 members of ARGS are used as the final cons of the</span>
<span style="color: #87005f;">result so if the final member of ARGS is not a list the result is</span>
<span style="color: #87005f;">a dotted list."</span>
  (-reduce-r 'cons args))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-snoc</span> (list elem <span style="color: #008700;">&amp;rest</span> elements)
  <span style="color: #87005f;">"Append ELEM to the end of the list.</span>

<span style="color: #87005f;">This is like `</span><span style="color: #008787;">cons</span><span style="color: #87005f;">', but operates on the end of list.</span>

<span style="color: #87005f;">If ELEMENTS is non nil, append these to the list as well."</span>
  (-concat list (list elem) elements))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--first</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-first</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((n (make-symbol <span style="color: #87005f;">"needle"</span>)))
    `(<span style="color: #af00ff;">let</span> (,n)
       (--each-while ,list (not ,n)
                     (<span style="color: #af00ff;">when</span> ,form (setq ,n it)))
       ,n)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-first</span> (pred list)
  <span style="color: #87005f;">"Return the first x in LIST where (PRED x) is non-nil, else nil.</span>

<span style="color: #87005f;">To get the first item in the list no questions asked, use `</span><span style="color: #008787;">car</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-find</span><span style="color: #87005f;">'"</span>
  (--first (funcall pred it) list))

(defalias '-find '-first)
(defalias '--find '--first)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--some</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-some</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((n (make-symbol <span style="color: #87005f;">"needle"</span>)))
    `(<span style="color: #af00ff;">let</span> (,n)
       (--each-while ,list (not ,n)
                     (setq ,n ,form))
       ,n)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-some</span> (pred list)
  <span style="color: #87005f;">"Return (PRED x) for the first LIST item where (PRED x) is non-nil, else nil.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-any</span><span style="color: #87005f;">'"</span>
  (--some (funcall pred it) list))

(defalias '-any '-some)
(defalias '--any '--some)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--last</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-last</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((n (make-symbol <span style="color: #87005f;">"needle"</span>)))
    `(<span style="color: #af00ff;">let</span> (,n)
       (--each ,list
               (<span style="color: #af00ff;">when</span> ,form (setq ,n it)))
       ,n)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-last</span> (pred list)
  <span style="color: #87005f;">"Return the last x in LIST where (PRED x) is non-nil, else nil."</span>
  (--last (funcall pred it) list))

(defalias '-first-item 'car
  <span style="color: #87005f;">"Return the first item of LIST, or nil on an empty list."</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-last-item</span> (list)
  <span style="color: #87005f;">"Return the last item of LIST, or nil on an empty list."</span>
  (car (last list)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-butlast</span> (list)
  <span style="color: #87005f;">"Return a list of all items in list except for the last."</span>
  (<span style="color: #af00ff;">let</span> (result)
    (<span style="color: #af00ff;">while</span> (cdr list)
      (!cons (car list) result)
      (!cdr list))
    (nreverse result)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--count</span> (pred list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-count</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,r 0))
       (--each ,list (<span style="color: #af00ff;">when</span> ,pred (setq ,r (1+ ,r))))
       ,r)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-count</span> (pred list)
  <span style="color: #87005f;">"Counts the number of items in LIST where (PRED item) is non-nil."</span>
  (--count (funcall pred it) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">---truthy?</span> (val)
  (not (null val)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--any?</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-any?</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(---truthy? (--first ,form ,list)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-any?</span> (pred list)
  <span style="color: #87005f;">"Return t if (PRED x) is non-nil for any x in LIST, else nil.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-any-p</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-some?</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-some-p</span><span style="color: #87005f;">'"</span>
  (--any? (funcall pred it) list))

(defalias '-some? '-any?)
(defalias '--some? '--any?)
(defalias '-any-p '-any?)
(defalias '--any-p '--any?)
(defalias '-some-p '-any?)
(defalias '--some-p '--any?)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--all?</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-all?</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((a (make-symbol <span style="color: #87005f;">"all"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,a t))
       (--each-while ,list ,a (setq ,a ,form))
       (---truthy? ,a))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-all?</span> (pred list)
  <span style="color: #87005f;">"Return t if (PRED x) is non-nil for all x in LIST, else nil.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-all-p</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-every?</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-every-p</span><span style="color: #87005f;">'"</span>
  (--all? (funcall pred it) list))

(defalias '-every? '-all?)
(defalias '--every? '--all?)
(defalias '-all-p '-all?)
(defalias '--all-p '--all?)
(defalias '-every-p '-all?)
(defalias '--every-p '--all?)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--none?</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-none?</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(--all? (not ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-none?</span> (pred list)
  <span style="color: #87005f;">"Return t if (PRED x) is nil for all x in LIST, else nil.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-none-p</span><span style="color: #87005f;">'"</span>
  (--none? (funcall pred it) list))

(defalias '-none-p '-none?)
(defalias '--none-p '--none?)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--only-some?</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-only-some?</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((y (make-symbol <span style="color: #87005f;">"yes"</span>))
        (n (make-symbol <span style="color: #87005f;">"no"</span>)))
    `(<span style="color: #af00ff;">let</span> (,y ,n)
       (--each-while ,list (not (and ,y ,n))
                     (<span style="color: #af00ff;">if</span> ,form (setq ,y t) (setq ,n t)))
       (---truthy? (and ,y ,n)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-only-some?</span> (pred list)
  <span style="color: #87005f;">"Return `t` if at least one item of LIST matches PRED and at least one item of LIST does not match PRED.</span>
<span style="color: #87005f;">Return `nil` both if all items match the predicate or if none of the items match the predicate.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-only-some-p</span><span style="color: #87005f;">'"</span>
  (--only-some? (funcall pred it) list))

(defalias '-only-some-p '-only-some?)
(defalias '--only-some-p '--only-some?)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-slice</span> (list from <span style="color: #008700;">&amp;optional</span> to step)
  <span style="color: #87005f;">"Return copy of LIST, starting from index FROM to index TO.</span>

<span style="color: #87005f;">FROM or TO may be negative.  These values are then interpreted</span>
<span style="color: #87005f;">modulo the length of the list.</span>

<span style="color: #87005f;">If STEP is a number, only each STEPth item in the resulting</span>
<span style="color: #87005f;">section is returned.  Defaults to 1."</span>
  (<span style="color: #af00ff;">let</span> ((length (length list))
        (new-list nil))
    <span style="color: #af0000;">;; </span><span style="color: #af0000;">to defaults to the end of the list</span>
    (setq to (or to length))
    (setq step (or step 1))
    <span style="color: #af0000;">;; </span><span style="color: #af0000;">handle negative indices</span>
    (<span style="color: #af00ff;">when</span> (&lt; from 0)
      (setq from (mod from length)))
    (<span style="color: #af00ff;">when</span> (&lt; to 0)
      (setq to (mod to length)))

    <span style="color: #af0000;">;; </span><span style="color: #af0000;">iterate through the list, keeping the elements we want</span>
    (--each-while list (&lt; it-index to)
                  (<span style="color: #af00ff;">when</span> (and (&gt;<span style="color: #af00ff;">=</span> it-index from)
                             (<span style="color: #af00ff;">=</span> (mod (- from it-index) step) 0))
                    (push it new-list)))
    (nreverse new-list)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-take</span> (n list)
  <span style="color: #87005f;">"Return a new list of the first N items in LIST, or all items if there are fewer than N."</span>
  (<span style="color: #af00ff;">let</span> (result)
    (--dotimes n
               (<span style="color: #af00ff;">when</span> list
                 (!cons (car list) result)
                 (!cdr list)))
    (nreverse result)))

(defalias '-drop 'nthcdr <span style="color: #87005f;">"Return the tail of LIST without the first N items."</span>)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--take-while</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-take-while</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>)))
    `(<span style="color: #af00ff;">let</span> (,r)
       (--each-while ,list ,form (!cons it ,r))
       (nreverse ,r))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-take-while</span> (pred list)
  <span style="color: #87005f;">"Return a new list of successive items from LIST while (PRED item) returns a non-nil value."</span>
  (--take-while (funcall pred it) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--drop-while</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-drop-while</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((l (make-symbol <span style="color: #87005f;">"list"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,l ,list))
       (<span style="color: #af00ff;">while</span> (and ,l (<span style="color: #af00ff;">let</span> ((it (car ,l))) ,form))
         (!cdr ,l))
       ,l)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-drop-while</span> (pred list)
  <span style="color: #87005f;">"Return the tail of LIST starting from the first item for which (PRED item) returns nil."</span>
  (--drop-while (funcall pred it) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-split-at</span> (n list)
  <span style="color: #87005f;">"Return a list of ((-take N LIST) (-drop N LIST)), in no more than one pass through the list."</span>
  (<span style="color: #af00ff;">let</span> (result)
    (--dotimes n
               (<span style="color: #af00ff;">when</span> list
                 (!cons (car list) result)
                 (!cdr list)))
    (list (nreverse result) list)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-rotate</span> (n list)
  <span style="color: #87005f;">"Rotate LIST N places to the right.  With N negative, rotate to the left.</span>
<span style="color: #87005f;">The time complexity is O(n)."</span>
  (<span style="color: #af00ff;">if</span> (&gt; n 0)
      (append (last list n) (butlast list n))
      (append (-drop (- n) list) (-take (- n) list))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-insert-at</span> (n x list)
  <span style="color: #87005f;">"Return a list with X inserted into LIST at position N.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-splice</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-splice-list</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> ((split-list (-split-at n list)))
    (nconc (car split-list) (cons x (cadr split-list)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-replace-at</span> (n x list)
  <span style="color: #87005f;">"Return a list with element at Nth position in LIST replaced with X.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-replace</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> ((split-list (-split-at n list)))
    (nconc (car split-list) (cons x (cdr (cadr split-list))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-update-at</span> (n func list)
  <span style="color: #87005f;">"Return a list with element at Nth position in LIST replaced with `(func (nth n list))`.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-map-when</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> ((split-list (-split-at n list)))
    (nconc (car split-list) (cons (funcall func (car (cadr split-list))) (cdr (cadr split-list))))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--update-at</span> (n form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-update-at</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form)))
  `(-update-at ,n (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-remove-at</span> (n list)
  <span style="color: #87005f;">"Return a list with element at Nth position in LIST removed.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-remove-at-indices</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-remove</span><span style="color: #87005f;">'"</span>
  (-remove-at-indices (list n) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-remove-at-indices</span> (indices list)
  <span style="color: #87005f;">"Return a list whose elements are elements from LIST without</span>
<span style="color: #87005f;">elements selected as `(nth i list)` for all i</span>
<span style="color: #87005f;">from INDICES.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-remove-at</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-remove</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let*</span> ((indices (-sort '&lt; indices))
         (diffs (cons (car indices) (-map '1- (-zip-with '- (cdr indices) indices))))
         r)
    (--each diffs
            (<span style="color: #af00ff;">let</span> ((split (-split-at it list)))
              (!cons (car split) r)
              (setq list (cdr (cadr split)))))
    (!cons list r)
    (apply '-concat (nreverse r))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--split-with</span> (pred list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-split-with</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((l (make-symbol <span style="color: #87005f;">"list"</span>))
        (r (make-symbol <span style="color: #87005f;">"result"</span>))
        (c (make-symbol <span style="color: #87005f;">"continue"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,l ,list)
           (,r nil)
           (,c t))
       (<span style="color: #af00ff;">while</span> (and ,l ,c)
         (<span style="color: #af00ff;">let</span> ((it (car ,l)))
           (<span style="color: #af00ff;">if</span> (not ,pred)
               (setq ,c nil)
               (!cons it ,r)
               (!cdr ,l))))
       (list (nreverse ,r) ,l))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-split-with</span> (pred list)
  <span style="color: #87005f;">"Return a list of ((-take-while PRED LIST) (-drop-while PRED LIST)), in no more than one pass through the list."</span>
  (--split-with (funcall pred it) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-split-on</span> (item list)
  <span style="color: #87005f;">"Split the LIST each time ITEM is found.</span>

<span style="color: #87005f;">Unlike `</span><span style="color: #008787;">-partition-by</span><span style="color: #87005f;">', the ITEM is discarded from the results.</span>
<span style="color: #87005f;">Empty lists are also removed from the result.</span>

<span style="color: #87005f;">Comparison is done by `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">See also `</span><span style="color: #008787;">-split-when</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-split-when (<span style="color: #af00ff;">lambda</span> (it) (equal it ,item)) ,list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--split-when</span> (form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-split-when</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-split-when (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-split-when</span> (fn list)
  <span style="color: #87005f;">"Split the LIST on each element where FN returns non-nil.</span>

<span style="color: #87005f;">Unlike `</span><span style="color: #008787;">-partition-by</span><span style="color: #87005f;">', the \"matched\" element is discarded from</span>
<span style="color: #87005f;">the results.  Empty lists are also removed from the result.</span>

<span style="color: #87005f;">This function can be thought of as a generalization of</span>
<span style="color: #87005f;">`</span><span style="color: #008787;">split-string</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">let</span> (r s)
    (<span style="color: #af00ff;">while</span> list
      (<span style="color: #af00ff;">if</span> (not (funcall fn (car list)))
          (push (car list) s)
          (<span style="color: #af00ff;">when</span> s (push (nreverse s) r))
          (setq s nil))
      (!cdr list))
    (<span style="color: #af00ff;">when</span> s (push (nreverse s) r))
    (nreverse r)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--separate</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-separate</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((y (make-symbol <span style="color: #87005f;">"yes"</span>))
        (n (make-symbol <span style="color: #87005f;">"no"</span>)))
    `(<span style="color: #af00ff;">let</span> (,y ,n)
       (--each ,list (<span style="color: #af00ff;">if</span> ,form (!cons it ,y) (!cons it ,n)))
       (list (nreverse ,y) (nreverse ,n)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-separate</span> (pred list)
  <span style="color: #87005f;">"Return a list of ((-filter PRED LIST) (-remove PRED LIST)), in one pass through the list."</span>
  (--separate (funcall pred it) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">---partition-all-in-steps-reversed</span> (n step list)
  <span style="color: #87005f;">"Private: Used by -partition-all-in-steps and -partition-in-steps."</span>
  (<span style="color: #af00ff;">when</span> (&lt; step 1)
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #87005f;">"Step must be a positive number, or you're looking at some juicy infinite loops."</span>))
  (<span style="color: #af00ff;">let</span> ((result nil))
    (<span style="color: #af00ff;">while</span> list
      (!cons (-take n list) result)
      (setq list (-drop step list)))
    result))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-partition-all-in-steps</span> (n step list)
  <span style="color: #87005f;">"Return a new list with the items in LIST grouped into N-sized sublists at offsets STEP apart.</span>
<span style="color: #87005f;">The last groups may contain less than N items."</span>
  (nreverse (---partition-all-in-steps-reversed n step list)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-partition-in-steps</span> (n step list)
  <span style="color: #87005f;">"Return a new list with the items in LIST grouped into N-sized sublists at offsets STEP apart.</span>
<span style="color: #87005f;">If there are not enough items to make the last group N-sized,</span>
<span style="color: #87005f;">those items are discarded."</span>
  (<span style="color: #af00ff;">let</span> ((result (---partition-all-in-steps-reversed n step list)))
    (<span style="color: #af00ff;">while</span> (and result (&lt; (length (car result)) n))
      (!cdr result))
    (nreverse result)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-partition-all</span> (n list)
  <span style="color: #87005f;">"Return a new list with the items in LIST grouped into N-sized sublists.</span>
<span style="color: #87005f;">The last group may contain less than N items."</span>
  (-partition-all-in-steps n n list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-partition</span> (n list)
  <span style="color: #87005f;">"Return a new list with the items in LIST grouped into N-sized sublists.</span>
<span style="color: #87005f;">If there are not enough items to make the last group N-sized,</span>
<span style="color: #87005f;">those items are discarded."</span>
  (-partition-in-steps n n list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--partition-by</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-partition-by</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>))
        (s (make-symbol <span style="color: #87005f;">"sublist"</span>))
        (v (make-symbol <span style="color: #87005f;">"value"</span>))
        (n (make-symbol <span style="color: #87005f;">"new-value"</span>))
        (l (make-symbol <span style="color: #87005f;">"list"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,l ,list))
       (<span style="color: #af00ff;">when</span> ,l
         (<span style="color: #af00ff;">let*</span> ((,r nil)
                (it (car ,l))
                (,s (list it))
                (,v ,form)
                (,l (cdr ,l)))
           (<span style="color: #af00ff;">while</span> ,l
             (<span style="color: #af00ff;">let*</span> ((it (car ,l))
                    (,n ,form))
               (<span style="color: #af00ff;">unless</span> (equal ,v ,n)
                 (!cons (nreverse ,s) ,r)
                 (setq ,s nil)
                 (setq ,v ,n))
               (!cons it ,s)
               (!cdr ,l)))
           (!cons (nreverse ,s) ,r)
           (nreverse ,r))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-partition-by</span> (fn list)
  <span style="color: #87005f;">"Apply FN to each item in LIST, splitting it each time FN returns a new value."</span>
  (--partition-by (funcall fn it) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--partition-by-header</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-partition-by-header</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>))
        (s (make-symbol <span style="color: #87005f;">"sublist"</span>))
        (h (make-symbol <span style="color: #87005f;">"header-value"</span>))
        (b (make-symbol <span style="color: #87005f;">"seen-body?"</span>))
        (n (make-symbol <span style="color: #87005f;">"new-value"</span>))
        (l (make-symbol <span style="color: #87005f;">"list"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,l ,list))
       (<span style="color: #af00ff;">when</span> ,l
         (<span style="color: #af00ff;">let*</span> ((,r nil)
                (it (car ,l))
                (,s (list it))
                (,h ,form)
                (,b nil)
                (,l (cdr ,l)))
           (<span style="color: #af00ff;">while</span> ,l
             (<span style="color: #af00ff;">let*</span> ((it (car ,l))
                    (,n ,form))
               (<span style="color: #af00ff;">if</span> (equal ,h ,n)
                   (<span style="color: #af00ff;">when</span> ,b
                     (!cons (nreverse ,s) ,r)
                     (setq ,s nil)
                     (setq ,b nil))
                   (setq ,b t))
               (!cons it ,s)
               (!cdr ,l)))
           (!cons (nreverse ,s) ,r)
           (nreverse ,r))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-partition-by-header</span> (fn list)
  <span style="color: #87005f;">"Apply FN to the first item in LIST. That is the header</span>
<span style="color: #87005f;">value. Apply FN to each item in LIST, splitting it each time FN</span>
<span style="color: #87005f;">returns the header value, but only after seeing at least one</span>
<span style="color: #87005f;">other value (the body)."</span>
  (--partition-by-header (funcall fn it) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--group-by</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-group-by</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug t))
  (<span style="color: #af00ff;">let</span> ((n (make-symbol <span style="color: #87005f;">"n"</span>))
        (k (make-symbol <span style="color: #87005f;">"k"</span>))
        (grp (make-symbol <span style="color: #87005f;">"grp"</span>)))
    `(nreverse
      (-map
       (<span style="color: #af00ff;">lambda</span> (,n)
         (cons (car ,n)
               (nreverse (cdr ,n))))
       (--reduce-from
        (<span style="color: #af00ff;">let*</span> ((,k (,@form))
               (,grp (assoc ,k acc)))
          (<span style="color: #af00ff;">if</span> ,grp
              (setcdr ,grp (cons it (cdr ,grp)))
              (push
               (list ,k it)
               acc))
          acc)
        nil ,list)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-group-by</span> (fn list)
  <span style="color: #87005f;">"Separate LIST into an alist whose keys are FN applied to the</span>
<span style="color: #87005f;">elements of LIST.  Keys are compared by `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">'."</span>
  (--group-by (funcall fn it) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-interpose</span> (sep list)
  <span style="color: #87005f;">"Return a new list of all elements in LIST separated by SEP."</span>
  (<span style="color: #af00ff;">let</span> (result)
    (<span style="color: #af00ff;">when</span> list
      (!cons (car list) result)
      (!cdr list))
    (<span style="color: #af00ff;">while</span> list
      (setq result (cons (car list) (cons sep result)))
      (!cdr list))
    (nreverse result)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-interleave</span> (<span style="color: #008700;">&amp;rest</span> lists)
  <span style="color: #87005f;">"Return a new list of the first item in each list, then the second etc."</span>
  (<span style="color: #af00ff;">let</span> (result)
    (<span style="color: #af00ff;">while</span> (-none? 'null lists)
      (--each lists (!cons (car it) result))
      (setq lists (-map 'cdr lists)))
    (nreverse result)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--zip-with</span> (form list1 list2)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-zip-with</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">The elements in list1 is bound as `it`, the elements in list2 as `other`."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form)))
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>))
        (l1 (make-symbol <span style="color: #87005f;">"list1"</span>))
        (l2 (make-symbol <span style="color: #87005f;">"list2"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,r nil)
           (,l1 ,list1)
           (,l2 ,list2))
       (<span style="color: #af00ff;">while</span> (and ,l1 ,l2)
         (<span style="color: #af00ff;">let</span> ((it (car ,l1))
               (other (car ,l2)))
           (!cons ,form ,r)
           (!cdr ,l1)
           (!cdr ,l2)))
       (nreverse ,r))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-zip-with</span> (fn list1 list2)
  <span style="color: #87005f;">"Zip the two lists LIST1 and LIST2 using a function FN.  This</span>
<span style="color: #87005f;">function is applied pairwise taking as first argument element of</span>
<span style="color: #87005f;">LIST1 and as second argument element of LIST2 at corresponding</span>
<span style="color: #87005f;">position.</span>

<span style="color: #87005f;">The anaphoric form `</span><span style="color: #008787;">--zip-with</span><span style="color: #87005f;">' binds the elements from LIST1 as `it`,</span>
<span style="color: #87005f;">and the elements from LIST2 as `other`."</span>
  (--zip-with (funcall fn it other) list1 list2))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-zip</span> (<span style="color: #008700;">&amp;rest</span> lists)
  <span style="color: #87005f;">"Zip LISTS together.  Group the head of each list, followed by the</span>
<span style="color: #87005f;">second elements of each list, and so on. The lengths of the returned</span>
<span style="color: #87005f;">groupings are equal to the length of the shortest input list.</span>

<span style="color: #87005f;">If two lists are provided as arguments, return the groupings as a list</span>
<span style="color: #87005f;">of cons cells. Otherwise, return the groupings as a list of lists.</span>

<span style="color: #87005f;">Please note! This distinction is being removed in an upcoming 2.0</span>
<span style="color: #87005f;">release of Dash. If you rely on this behavior, use -zip-pair instead."</span>
  (<span style="color: #af00ff;">let</span> (results)
    (<span style="color: #af00ff;">while</span> (-none? 'null lists)
      (setq results (cons (mapcar 'car lists) results))
      (setq lists (mapcar 'cdr lists)))
    (setq results (nreverse results))
    (<span style="color: #af00ff;">if</span> (<span style="color: #af00ff;">=</span> (length lists) 2)
        <span style="color: #af0000;">;; </span><span style="color: #af0000;">to support backward compatability, return</span>
        <span style="color: #af0000;">;; </span><span style="color: #af0000;">a cons cell if two lists were provided</span>
        (--map (cons (car it) (cadr it)) results)
        results)))

(defalias '-zip-pair '-zip)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-zip-fill</span> (fill-value <span style="color: #008700;">&amp;rest</span> lists)
  <span style="color: #87005f;">"Zip LISTS, with FILL-VALUE padded onto the shorter lists. The</span>
<span style="color: #87005f;">lengths of the returned groupings are equal to the length of the</span>
<span style="color: #87005f;">longest input list."</span>
  (apply '-zip (apply '-pad (cons fill-value lists))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-cycle</span> (list)
  <span style="color: #87005f;">"Return an infinite copy of LIST that will cycle through the</span>
<span style="color: #87005f;">elements and repeat from the beginning."</span>
  (<span style="color: #af00ff;">let</span> ((newlist (-map 'identity list)))
    (nconc newlist newlist)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-pad</span> (fill-value <span style="color: #008700;">&amp;rest</span> lists)
  <span style="color: #87005f;">"Appends FILL-VALUE to the end of each list in LISTS such that they</span>
<span style="color: #87005f;">will all have the same length."</span>
  (<span style="color: #af00ff;">let*</span> ((annotations (-annotate 'length lists))
         (n (-max (-map 'car annotations))))
    (--map (append (cdr it) (-repeat (- n (car it)) fill-value)) annotations)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-annotate</span> (fn list)
  <span style="color: #87005f;">"Return a list of cons cells where each cell is FN applied to each</span>
<span style="color: #87005f;">element of LIST paired with the unmodified element of LIST."</span>
  (-zip (-map fn list) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--annotate</span> (form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-annotate</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-annotate (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--table-carry</span> (lists restore-lists <span style="color: #008700;">&amp;optional</span> re)
  <span style="color: #87005f;">"Helper for `</span><span style="color: #008787;">-table</span><span style="color: #87005f;">' and `</span><span style="color: #008787;">-table-flat</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">If a list overflows, carry to the right and reset the list."</span>
  (<span style="color: #af00ff;">while</span> (not (or (car lists)
                  (equal lists '(nil))))
    (setcar lists (car restore-lists))
    (pop (cadr lists))
    (!cdr lists)
    (!cdr restore-lists)
    (<span style="color: #af00ff;">when</span> re
      (push (nreverse (car re)) (cadr re))
      (setcar re nil)
      (!cdr re))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-table</span> (fn <span style="color: #008700;">&amp;rest</span> lists)
  <span style="color: #87005f;">"Compute outer product of LISTS using function FN.</span>

<span style="color: #87005f;">The function FN should have the same arity as the number of</span>
<span style="color: #87005f;">supplied lists.</span>

<span style="color: #87005f;">The outer product is computed by applying fn to all possible</span>
<span style="color: #87005f;">combinations created by taking one element from each list in</span>
<span style="color: #87005f;">order.  The dimension of the result is (length lists).</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-table-flat</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> ((restore-lists (copy-sequence lists))
        (last-list (last lists))
        (re (make-list (length lists) nil)))
    (<span style="color: #af00ff;">while</span> (car last-list)
      (<span style="color: #af00ff;">let</span> ((item (apply fn (-map 'car lists))))
        (push item (car re))
        (setcar lists (cdar lists)) <span style="color: #af0000;">;; </span><span style="color: #af0000;">silence byte compiler</span>
        (dash--table-carry lists restore-lists re)))
    (nreverse (car (last re)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-table-flat</span> (fn <span style="color: #008700;">&amp;rest</span> lists)
  <span style="color: #87005f;">"Compute flat outer product of LISTS using function FN.</span>

<span style="color: #87005f;">The function FN should have the same arity as the number of</span>
<span style="color: #87005f;">supplied lists.</span>

<span style="color: #87005f;">The outer product is computed by applying fn to all possible</span>
<span style="color: #87005f;">combinations created by taking one element from each list in</span>
<span style="color: #87005f;">order.  The results are flattened, ignoring the tensor structure</span>
<span style="color: #87005f;">of the result.  This is equivalent to calling:</span>

<span style="color: #87005f;">  (-flatten-n (1- (length lists)) (-table fn lists))</span>

<span style="color: #87005f;">but the implementation here is much more efficient.</span>

<span style="color: #87005f;">See also: `</span><span style="color: #008787;">-flatten-n</span><span style="color: #87005f;">', `</span><span style="color: #008787;">-table</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">when</span> lists                           <span style="color: #af0000;">;Just in case.</span>
    (<span style="color: #af00ff;">let*</span> ((list1 (pop lists))
           (restore-lists (copy-sequence lists))
           (last-list (last lists))
           re)
      (<span style="color: #af00ff;">while</span> (car last-list)
        (<span style="color: #af00ff;">let</span> ((tail (-map #'car lists)))
          (<span style="color: #af00ff;">dolist</span> (head list1)
            (push (apply fn head tail) re)))
        (pop (car lists))
        (dash--table-carry lists restore-lists))
      (nreverse re))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-partial</span> (fn <span style="color: #008700;">&amp;rest</span> args)
  <span style="color: #87005f;">"Take a function FN and fewer than the normal arguments to FN,</span>
<span style="color: #87005f;">and return a fn that takes a variable number of additional ARGS.</span>
<span style="color: #87005f;">When called, the returned function calls FN with ARGS first and</span>
<span style="color: #87005f;">then additional args."</span>
  (apply 'apply-partially fn args))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-elem-index</span> (elem list)
  <span style="color: #87005f;">"Return the index of the first element in the given LIST which</span>
<span style="color: #87005f;">is equal to the query element ELEM, or nil if there is no</span>
<span style="color: #87005f;">such element."</span>
  (car (-elem-indices elem list)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-elem-indices</span> (elem list)
  <span style="color: #87005f;">"Return the indices of all elements in LIST equal to the query</span>
<span style="color: #87005f;">element ELEM, in ascending order."</span>
  (-find-indices (-partial 'equal elem) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-find-indices</span> (pred list)
  <span style="color: #87005f;">"Return the indices of all elements in LIST satisfying the</span>
<span style="color: #87005f;">predicate PRED, in ascending order."</span>
  (apply 'append (--map-indexed (<span style="color: #af00ff;">when</span> (funcall pred it) (list it-index)) list)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--find-indices</span> (form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-find-indices</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-find-indices (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-find-index</span> (pred list)
  <span style="color: #87005f;">"Take a predicate PRED and a LIST and return the index of the</span>
<span style="color: #87005f;">first element in the list satisfying the predicate, or nil if</span>
<span style="color: #87005f;">there is no such element."</span>
  (car (-find-indices pred list)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--find-index</span> (form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-find-index</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-find-index (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-find-last-index</span> (pred list)
  <span style="color: #87005f;">"Take a predicate PRED and a LIST and return the index of the</span>
<span style="color: #87005f;">last element in the list satisfying the predicate, or nil if</span>
<span style="color: #87005f;">there is no such element."</span>
  (-last-item (-find-indices pred list)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--find-last-index</span> (form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-find-last-index</span><span style="color: #87005f;">'."</span>
  `(-find-last-index (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-select-by-indices</span> (indices list)
  <span style="color: #87005f;">"Return a list whose elements are elements from LIST selected</span>
<span style="color: #87005f;">as `(nth i list)` for all i from INDICES."</span>
  (<span style="color: #af00ff;">let</span> (r)
    (--each indices
            (!cons (nth it list) r))
    (nreverse r)))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">-&gt;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">-&gt;&gt;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">--&gt;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">-some-&gt;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">-some-&gt;&gt;</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">-some--&gt;</span>

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-grade-up</span> (comparator list)
  <span style="color: #87005f;">"Grade elements of LIST using COMPARATOR relation, yielding a</span>
<span style="color: #87005f;">permutation vector such that applying this permutation to LIST</span>
<span style="color: #87005f;">sorts it in ascending order."</span>
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">ugly hack to "fix" lack of lexical scope</span>
  (<span style="color: #af00ff;">let</span> ((comp `(<span style="color: #af00ff;">lambda</span> (it other) (funcall ',comparator (car it) (car other)))))
    (-&gt;&gt; (--map-indexed (cons it it-index) list)
         (-sort comp)
         (-map 'cdr))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-grade-down</span> (comparator list)
  <span style="color: #87005f;">"Grade elements of LIST using COMPARATOR relation, yielding a</span>
<span style="color: #87005f;">permutation vector such that applying this permutation to LIST</span>
<span style="color: #87005f;">sorts it in descending order."</span>
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">ugly hack to "fix" lack of lexical scope</span>
  (<span style="color: #af00ff;">let</span> ((comp `(<span style="color: #af00ff;">lambda</span> (it other) (funcall ',comparator (car other) (car it)))))
    (-&gt;&gt; (--map-indexed (cons it it-index) list)
         (-sort comp)
         (-map 'cdr))))

(<span style="color: #af00ff;">defvar</span> <span style="color: #af5f00;">dash--source-counter</span> 0
  <span style="color: #87005f;">"Monotonic counter for generated symbols."</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-make-source-symbol</span> ()
  <span style="color: #87005f;">"Generate a new dash-source symbol.</span>

<span style="color: #87005f;">All returned symbols are guaranteed to be unique."</span>
  (<span style="color: #af00ff;">prog1</span> (make-symbol (format <span style="color: #87005f;">"--dash-source-%d--"</span> dash--source-counter))
    (setq dash--source-counter (1+ dash--source-counter))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-ignore-place-p</span> (symbol)
  <span style="color: #87005f;">"Return non-nil if SYMBOL is a symbol and starts with _."</span>
  (and (symbolp symbol)
       (eq (aref (symbol-name symbol) 0) ?_)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-cons-skip-cdr</span> (skip-cdr source)
  <span style="color: #87005f;">"Helper function generating idiomatic shifting code."</span>
  (<span style="color: #af00ff;">cond</span>
    ((<span style="color: #af00ff;">=</span> skip-cdr 0)
     `(pop ,source))
    (t
     `(<span style="color: #af00ff;">prog1</span> ,(dash--match-cons-get-car skip-cdr source)
        (setq ,source ,(dash--match-cons-get-cdr (1+ skip-cdr) source))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-cons-get-car</span> (skip-cdr source)
  <span style="color: #87005f;">"Helper function generating idiomatic code to get nth car."</span>
  (<span style="color: #af00ff;">cond</span>
    ((<span style="color: #af00ff;">=</span> skip-cdr 0)
     `(car ,source))
    ((<span style="color: #af00ff;">=</span> skip-cdr 1)
     `(cadr ,source))
    (t
     `(nth ,skip-cdr ,source))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-cons-get-cdr</span> (skip-cdr source)
  <span style="color: #87005f;">"Helper function generating idiomatic code to get nth cdr."</span>
  (<span style="color: #af00ff;">cond</span>
    ((<span style="color: #af00ff;">=</span> skip-cdr 0)
     source)
    ((<span style="color: #af00ff;">=</span> skip-cdr 1)
     `(cdr ,source))
    (t
     `(nthcdr ,skip-cdr ,source))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-cons</span> (match-form source)
  <span style="color: #87005f;">"Setup a cons matching environment and call the real matcher."</span>
  (<span style="color: #af00ff;">let</span> ((s (dash--match-make-source-symbol))
        (n 0)
        (m match-form))
    (<span style="color: #af00ff;">while</span> (and (consp m)
                (dash--match-ignore-place-p (car m)))
      (setq n (1+ n)) (!cdr m))
    (<span style="color: #af00ff;">cond</span>
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">when we only have one pattern in the list, we don't have to</span>
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">create a temporary binding (--dash-source--) for the source</span>
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">and just use the input directly</span>
      ((and (consp m)
            (not (cdr m)))
       (dash--match (car m) (dash--match-cons-get-car n source)))
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">handle other special types</span>
      ((&gt; n 0)
       (dash--match m (dash--match-cons-get-cdr n source)))
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">this is the only entry-point for dash--match-cons-1, that's</span>
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">why we can't simply use the above branch, it would produce</span>
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">infinite recursion</span>
      (t
       (cons (list s source) (dash--match-cons-1 match-form s))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-cons-1</span> (match-form source <span style="color: #008700;">&amp;optional</span> props)
  <span style="color: #87005f;">"Match MATCH-FORM against SOURCE.</span>

<span style="color: #87005f;">MATCH-FORM is a proper or improper list.  Each element of</span>
<span style="color: #87005f;">MATCH-FORM is either a symbol, which gets bound to the respective</span>
<span style="color: #87005f;">value in source or another match form which gets destructured</span>
<span style="color: #87005f;">recursively.</span>

<span style="color: #87005f;">If the cdr of last cons cell in the list is `</span><span style="color: #008787;">nil</span><span style="color: #87005f;">', matching stops</span>
<span style="color: #87005f;">there.</span>

<span style="color: #87005f;">SOURCE is a proper or improper list."</span>
  (<span style="color: #af00ff;">let</span> ((skip-cdr (or (plist-get props <span style="color: #5f5f87;">:skip-cdr</span>) 0)))
    (<span style="color: #af00ff;">cond</span>
      ((consp match-form)
       (<span style="color: #af00ff;">cond</span>
         ((cdr match-form)
          (<span style="color: #af00ff;">cond</span>
            ((and (symbolp (car match-form))
                  (memq (car match-form) '(<span style="color: #008700;">&amp;keys</span> <span style="color: #008700;">&amp;plist</span> <span style="color: #008700;">&amp;alist</span> <span style="color: #008700;">&amp;hash</span>)))
             (dash--match-kv match-form (dash--match-cons-get-cdr skip-cdr source)))
            ((dash--match-ignore-place-p (car match-form))
             (dash--match-cons-1 (cdr match-form) source
                                 (plist-put props <span style="color: #5f5f87;">:skip-cdr</span> (1+ skip-cdr))))
            (t
             (-concat (dash--match (car match-form) (dash--match-cons-skip-cdr skip-cdr source))
                      (dash--match-cons-1 (cdr match-form) source)))))
         (t <span style="color: #af0000;">;; </span><span style="color: #af0000;">Last matching place, no need for shift</span>
          (dash--match (car match-form) (dash--match-cons-get-car skip-cdr source)))))
      ((eq match-form nil)
       nil)
      (t <span style="color: #af0000;">;; </span><span style="color: #af0000;">Handle improper lists.  Last matching place, no need for shift</span>
       (dash--match match-form (dash--match-cons-get-cdr skip-cdr source))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--vector-tail</span> (seq start)
  <span style="color: #87005f;">"Return the tail of SEQ starting at START."</span>
  (<span style="color: #af00ff;">cond</span>
    ((vectorp seq)
     (<span style="color: #af00ff;">let*</span> ((re-length (- (length seq) start))
            (re (make-vector re-length 0)))
       (--dotimes re-length (aset re it (aref seq (+ it start))))
       re))
    ((stringp seq)
     (substring seq start))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-vector</span> (match-form source)
  <span style="color: #87005f;">"Setup a vector matching environment and call the real matcher."</span>
  (<span style="color: #af00ff;">let</span> ((s (dash--match-make-source-symbol)))
    (<span style="color: #af00ff;">cond</span>
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">don't bind `s' if we only have one sub-pattern</span>
      ((<span style="color: #af00ff;">=</span> (length match-form) 1)
       (dash--match (aref match-form 0) `(aref ,source 0)))
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">if the source is a symbol, we don't need to re-bind it</span>
      ((symbolp source)
       (dash--match-vector-1 match-form source))
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">don't bind `s' if we only have one sub-pattern which is not ignored</span>
      ((<span style="color: #af00ff;">let*</span> ((ignored-places (mapcar 'dash--match-ignore-place-p match-form))
              (ignored-places-n (length (-remove 'null ignored-places))))
         (<span style="color: #af00ff;">when</span> (<span style="color: #af00ff;">=</span> ignored-places-n (1- (length match-form)))
           (<span style="color: #af00ff;">let</span> ((n (-find-index 'null ignored-places)))
             (dash--match (aref match-form n) `(aref ,source ,n))))))
      (t
       (cons (list s source) (dash--match-vector-1 match-form s))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-vector-1</span> (match-form source)
  <span style="color: #87005f;">"Match MATCH-FORM against SOURCE.</span>

<span style="color: #87005f;">MATCH-FORM is a vector.  Each element of MATCH-FORM is either a</span>
<span style="color: #87005f;">symbol, which gets bound to the respective value in source or</span>
<span style="color: #87005f;">another match form which gets destructured recursively.</span>

<span style="color: #87005f;">If second-from-last place in MATCH-FORM is the symbol &amp;rest, the</span>
<span style="color: #87005f;">next element of the MATCH-FORM is matched against the tail of</span>
<span style="color: #87005f;">SOURCE, starting at index of the &amp;rest symbol.  This is</span>
<span style="color: #87005f;">conceptually the same as the (head . tail) match for improper</span>
<span style="color: #87005f;">lists, where dot plays the role of &amp;rest.</span>

<span style="color: #87005f;">SOURCE is a vector.</span>

<span style="color: #87005f;">If the MATCH-FORM vector is shorter than SOURCE vector, only</span>
<span style="color: #87005f;">the (length MATCH-FORM) places are bound, the rest of the SOURCE</span>
<span style="color: #87005f;">is discarded."</span>
  (<span style="color: #af00ff;">let</span> ((i 0)
        (l (length match-form))
        (re))
    (<span style="color: #af00ff;">while</span> (&lt; i l)
      (<span style="color: #af00ff;">let</span> ((m (aref match-form i)))
        (push (<span style="color: #af00ff;">cond</span>
                ((and (symbolp m)
                      (eq m '<span style="color: #008700;">&amp;rest</span>))
                 (<span style="color: #af00ff;">prog1</span> (dash--match
                         (aref match-form (1+ i))
                         `(dash--vector-tail ,source ,i))
                   (setq i l)))
                ((and (symbolp m)
                      <span style="color: #af0000;">;; </span><span style="color: #af0000;">do not match symbols starting with _</span>
                      (not (eq (aref (symbol-name m) 0) ?_)))
                 (list (list m `(aref ,source ,i))))
                ((not (symbolp m))
                 (dash--match m `(aref ,source ,i))))
              re)
        (setq i (1+ i))))
    (-flatten-n 1 (nreverse re))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-kv</span> (match-form source)
  <span style="color: #87005f;">"Setup a kv matching environment and call the real matcher.</span>

<span style="color: #87005f;">kv can be any key-value store, such as plist, alist or hash-table."</span>
  (<span style="color: #af00ff;">let</span> ((s (dash--match-make-source-symbol)))
    (<span style="color: #af00ff;">cond</span>
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">don't bind `s' if we only have one sub-pattern (&amp;type key val)</span>
      ((<span style="color: #af00ff;">=</span> (length match-form) 3)
       (dash--match-kv-1 (cdr match-form) source (car match-form)))
      <span style="color: #af0000;">;; </span><span style="color: #af0000;">if the source is a symbol, we don't need to re-bind it</span>
      ((symbolp source)
       (dash--match-kv-1 (cdr match-form) source (car match-form)))
      (t
       (cons (list s source) (dash--match-kv-1 (cdr match-form) s (car match-form)))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-kv-1</span> (match-form source type)
  <span style="color: #87005f;">"Match MATCH-FORM against SOURCE of type TYPE.</span>

<span style="color: #87005f;">MATCH-FORM is a proper list of the form (key1 place1 ... keyN</span>
<span style="color: #87005f;">placeN).  Each placeK is either a symbol, which gets bound to the</span>
<span style="color: #87005f;">value of keyK retrieved from the key-value store, or another</span>
<span style="color: #87005f;">match form which gets destructured recursively.</span>

<span style="color: #87005f;">SOURCE is a key-value store of type TYPE, which can be a plist,</span>
<span style="color: #87005f;">an alist or a hash table.</span>

<span style="color: #87005f;">TYPE is a token specifying the type of the key-value store.</span>
<span style="color: #87005f;">Valid values are &amp;plist, &amp;alist and &amp;hash."</span>
  (-flatten-n 1 (-map
                 (<span style="color: #af00ff;">lambda</span> (kv)
                   (<span style="color: #af00ff;">let*</span> ((k (car kv))
                          (v (cadr kv))
                          (getter (<span style="color: #af00ff;">cond</span>
                                    ((or (eq type '<span style="color: #008700;">&amp;plist</span>) (eq type '<span style="color: #008700;">&amp;keys</span>))
                                     `(plist-get ,source ,k))
                                    ((eq type '<span style="color: #008700;">&amp;alist</span>)
                                     `(cdr (assoc ,k ,source)))
                                    ((eq type '<span style="color: #008700;">&amp;hash</span>)
                                     `(gethash ,k ,source)))))
                     (<span style="color: #af00ff;">cond</span>
                       ((symbolp v)
                        (list (list v getter)))
                       (t (dash--match v getter)))))
                 (-partition 2 match-form))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match-symbol</span> (match-form source)
  <span style="color: #87005f;">"Bind a symbol.</span>

<span style="color: #87005f;">This works just like `</span><span style="color: #008787;">let</span><span style="color: #87005f;">', there is no destructuring."</span>
  (list (list match-form source)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash--match</span> (match-form source)
  <span style="color: #87005f;">"Match MATCH-FORM against SOURCE.</span>

<span style="color: #87005f;">This function tests the MATCH-FORM and dispatches to specific</span>
<span style="color: #87005f;">matchers based on the type of the expression.</span>

<span style="color: #87005f;">Key-value stores are disambiguated by placing a token &amp;plist,</span>
<span style="color: #87005f;">&amp;alist or &amp;hash as a first item in the MATCH-FORM."</span>
  (<span style="color: #af00ff;">cond</span>
    ((symbolp match-form)
     (dash--match-symbol match-form source))
    ((consp match-form)
     (<span style="color: #af00ff;">cond</span>
       <span style="color: #af0000;">;; </span><span style="color: #af0000;">Handle the "x &amp;as" bindings first.</span>
       ((and (consp (cdr match-form))
             (symbolp (car match-form))
             (eq '<span style="color: #008700;">&amp;as</span> (cadr match-form)))
        (<span style="color: #af00ff;">let</span> ((s (car match-form)))
          (cons (list s source)
                (dash--match (cddr match-form) s))))
       ((memq (car match-form) '(<span style="color: #008700;">&amp;keys</span> <span style="color: #008700;">&amp;plist</span> <span style="color: #008700;">&amp;alist</span> <span style="color: #008700;">&amp;hash</span>))
        (dash--match-kv match-form source))
       (t (dash--match-cons match-form source))))
    ((vectorp match-form)
     <span style="color: #af0000;">;; </span><span style="color: #af0000;">We support the &amp;as binding in vectors too</span>
     (<span style="color: #af00ff;">cond</span>
       ((and (&gt; (length match-form) 2)
             (symbolp (aref match-form 0))
             (eq '<span style="color: #008700;">&amp;as</span> (aref match-form 1)))
        (<span style="color: #af00ff;">let</span> ((s (aref match-form 0)))
          (cons (list s source)
                (dash--match (dash--vector-tail match-form 2) s))))
       (t (dash--match-vector match-form source))))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-let*</span> (varlist <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"Bind variables according to VARLIST then eval BODY.</span>

<span style="color: #87005f;">VARLIST is a list of lists of the form (PATTERN SOURCE).  Each</span>
<span style="color: #87005f;">PATTERN is matched against the SOURCE structurally.  SOURCE is</span>
<span style="color: #87005f;">only evaluated once for each PATTERN.</span>

<span style="color: #87005f;">Each SOURCE can refer to the symbols already bound by this</span>
<span style="color: #87005f;">VARLIST.  This is useful if you want to destructure SOURCE</span>
<span style="color: #87005f;">recursively but also want to name the intermediate structures.</span>

<span style="color: #87005f;">See `</span><span style="color: #008787;">-let</span><span style="color: #87005f;">' for the list of all possible patterns."</span>
  (<span style="color: #af00ff;">declare</span> (debug ((<span style="color: #008700;">&amp;rest</span> (sexp form)) body))
           (indent 1))
  (<span style="color: #af00ff;">let</span> ((bindings (--mapcat (dash--match (car it) (cadr it)) varlist)))
    `(<span style="color: #af00ff;">let*</span> ,bindings
       ,@body)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-let</span> (varlist <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"Bind variables according to VARLIST then eval BODY.</span>

<span style="color: #87005f;">VARLIST is a list of lists of the form (PATTERN SOURCE).  Each</span>
<span style="color: #87005f;">PATTERN is matched against the SOURCE \"structurally\".  SOURCE</span>
<span style="color: #87005f;">is only evaluated once for each PATTERN.  Each PATTERN is matched</span>
<span style="color: #87005f;">recursively, and can therefore contain sub-patterns which are</span>
<span style="color: #87005f;">matched against corresponding sub-expressions of SOURCE.</span>

<span style="color: #87005f;">All the SOURCEs are evalled before any symbols are</span>
<span style="color: #87005f;">bound (i.e. \"in parallel\").</span>

<span style="color: #87005f;">If VARLIST only contains one (PATTERN SOURCE) element, you can</span>
<span style="color: #87005f;">optionally specify it using a vector and discarding the</span>
<span style="color: #87005f;">outer-most parens.  Thus</span>

<span style="color: #87005f;">  (-let ((PATTERN SOURCE)) ..)</span>

<span style="color: #87005f;">becomes</span>

<span style="color: #87005f;">  (-let [PATTERN SOURCE] ..).</span>

<span style="color: #87005f;">`</span><span style="color: #008787;">-let</span><span style="color: #87005f;">' uses a convention of not binding places (symbols) starting</span>
<span style="color: #87005f;">with _ whenever it's possible.  You can use this to skip over</span>
<span style="color: #87005f;">entries you don't care about.  However, this is not *always*</span>
<span style="color: #87005f;">possible (as a result of implementation) and these symbols might</span>
<span style="color: #87005f;">get bound to undefined values.</span>

<span style="color: #87005f;">Following is the overview of supported patterns.  Remember that</span>
<span style="color: #87005f;">patterns can be matched recursively, so every a, b, aK in the</span>
<span style="color: #87005f;">following can be a matching construct and not necessarily a</span>
<span style="color: #87005f;">symbol/variable.</span>

<span style="color: #87005f;">Symbol:</span>

<span style="color: #87005f;">  a - bind the SOURCE to A.  This is just like regular `</span><span style="color: #008787;">let</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">Conses and lists:</span>

<span style="color: #87005f;">  (a) - bind `</span><span style="color: #008787;">car</span><span style="color: #87005f;">' of cons/list to A</span>

<span style="color: #87005f;">  (a . b) - bind car of cons to A and `</span><span style="color: #008787;">cdr</span><span style="color: #87005f;">' to B</span>

<span style="color: #87005f;">  (a b) - bind car of list to A and `</span><span style="color: #008787;">cadr</span><span style="color: #87005f;">' to B</span>

<span style="color: #87005f;">  (a1 a2 a3  ...) - bind 0th car of list to A1, 1st to A2, 2nd to A3 ...</span>

<span style="color: #87005f;">  (a1 a2 a3 ... aN . rest) - as above, but bind the Nth cdr to REST.</span>

<span style="color: #87005f;">Vectors:</span>

<span style="color: #87005f;">  [a] - bind 0th element of a non-list sequence to A (works with</span>
<span style="color: #87005f;">        vectors, strings, bit arrays...)</span>

<span style="color: #87005f;">  [a1 a2 a3 ...] - bind 0th element of non-list sequence to A0, 1st to</span>
<span style="color: #87005f;">                   A1, 2nd to A2, ...</span>
<span style="color: #87005f;">                   If the PATTERN is shorter than SOURCE, the values at</span>
<span style="color: #87005f;">                   places not in PATTERN are ignored.</span>
<span style="color: #87005f;">                   If the PATTERN is longer than SOURCE, an `</span><span style="color: #008787;">error</span><span style="color: #87005f;">' is</span>
<span style="color: #87005f;">                   thrown.</span>

<span style="color: #87005f;">  [a1 a2 a3 ... &amp;rest rest] - as above, but bind the rest of</span>
<span style="color: #87005f;">                              the sequence to REST.  This is</span>
<span style="color: #87005f;">                              conceptually the same as improper list</span>
<span style="color: #87005f;">                              matching (a1 a2 ... aN . rest)</span>

<span style="color: #87005f;">Key/value stores:</span>

<span style="color: #87005f;">  (&amp;plist key0 a0 ... keyN aN) - bind value mapped by keyK in the</span>
<span style="color: #87005f;">                                 SOURCE plist to aK.  If the</span>
<span style="color: #87005f;">                                 value is not found, aK is nil.</span>

<span style="color: #87005f;">  (&amp;alist key0 a0 ... keyN aN) - bind value mapped by keyK in the</span>
<span style="color: #87005f;">                                 SOURCE alist to aK.  If the</span>
<span style="color: #87005f;">                                 value is not found, aK is nil.</span>

<span style="color: #87005f;">  (&amp;hash key0 a0 ... keyN aN) - bind value mapped by keyK in the</span>
<span style="color: #87005f;">                                SOURCE hash table to aK.  If the</span>
<span style="color: #87005f;">                                value is not found, aK is nil.</span>

<span style="color: #87005f;">Further, special keyword &amp;keys supports \"inline\" matching of</span>
<span style="color: #87005f;">plist-like key-value pairs, similarly to &amp;keys keyword of</span>
<span style="color: #87005f;">`</span><span style="color: #008787;">cl-defun</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">  (a1 a2 ... aN &amp;keys key1 b1 ... keyN bK)</span>

<span style="color: #87005f;">This binds N values from the list to a1 ... aN, then interprets</span>
<span style="color: #87005f;">the cdr as a plist (see key/value matching above).</span>

<span style="color: #87005f;">You can name the source using the syntax SYMBOL &amp;as PATTERN.</span>
<span style="color: #87005f;">This syntax works with lists (proper or improper), vectors and</span>
<span style="color: #87005f;">all types of maps.</span>

<span style="color: #87005f;">  (list &amp;as a b c) (list 1 2 3)</span>

<span style="color: #87005f;">binds A to 1, B to 2, C to 3 and LIST to (1 2 3).</span>

<span style="color: #87005f;">Similarly:</span>

<span style="color: #87005f;">  (bounds &amp;as beg . end) (cons 1 2)</span>

<span style="color: #87005f;">binds BEG to 1, END to 2 and BOUNDS to (1 . 2).</span>

<span style="color: #87005f;">  (items &amp;as first . rest) (list 1 2 3)</span>

<span style="color: #87005f;">binds FIRST to 1, REST to (2 3) and ITEMS to (1 2 3)</span>

<span style="color: #87005f;">  [vect &amp;as _ b c] [1 2 3]</span>

<span style="color: #87005f;">binds B to 2, C to 3 and VECT to [1 2 3] (_ avoids binding as usual).</span>

<span style="color: #87005f;">  (plist &amp;as &amp;plist :b b) (list :a 1 :b 2 :c 3)</span>

<span style="color: #87005f;">binds B to 2 and PLIST to (:a 1 :b 2 :c 3).  Same for &amp;alist and &amp;hash.</span>

<span style="color: #87005f;">This is especially useful when we want to capture the result of a</span>
<span style="color: #87005f;">computation and destructure at the same time.  Consider the</span>
<span style="color: #87005f;">form (function-returning-complex-structure) returning a list of</span>
<span style="color: #87005f;">two vectors with two items each.  We want to capture this entire</span>
<span style="color: #87005f;">result and pass it to another computation, but at the same time</span>
<span style="color: #87005f;">we want to get the second item from each vector.  We can achieve</span>
<span style="color: #87005f;">it with pattern</span>

<span style="color: #87005f;">  (result &amp;as [_ a] [_ b]) (function-returning-complex-structure)</span>

<span style="color: #87005f;">Note: Clojure programmers may know this feature as the \":as</span>
<span style="color: #87005f;">binding\".  The difference is that we put the &amp;as at the front</span>
<span style="color: #87005f;">because we need to support improper list binding."</span>
  (<span style="color: #af00ff;">declare</span> (debug ([&amp;or (<span style="color: #008700;">&amp;rest</span> (sexp form))
                        (vector [&amp;rest [sexp form]])]
                        body))
           (indent 1))
  (<span style="color: #af00ff;">if</span> (vectorp varlist)
      `(<span style="color: #af00ff;">let*</span> ,(dash--match (aref varlist 0) (aref varlist 1))
         ,@body)
      (<span style="color: #af00ff;">let*</span> ((inputs (--map-indexed (list (make-symbol (format <span style="color: #87005f;">"input%d"</span> it-index)) (cadr it)) varlist))
             (new-varlist (--map (list (caar it) (cadr it)) (-zip varlist inputs))))
        `(<span style="color: #af00ff;">let</span> ,inputs
           (-let* ,new-varlist ,@body)))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-lambda</span> (match-form <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"Return a lambda which destructures its input as MATCH-FORM and executes BODY.</span>

<span style="color: #87005f;">Note that you have to enclose the MATCH-FORM in a pair of parens,</span>
<span style="color: #87005f;">such that:</span>

<span style="color: #87005f;">  (-lambda (x) body)</span>
<span style="color: #87005f;">  (-lambda (x y ...) body)</span>

<span style="color: #87005f;">has the usual semantics of `</span><span style="color: #008787;">lambda</span><span style="color: #87005f;">'.  Furthermore, these get</span>
<span style="color: #87005f;">translated into normal lambda, so there is no performance</span>
<span style="color: #87005f;">penalty.</span>

<span style="color: #87005f;">See `</span><span style="color: #008787;">-let</span><span style="color: #87005f;">' for the description of destructuring mechanism."</span>
  (<span style="color: #af00ff;">declare</span> (doc-string 2) (indent defun)
           (debug (<span style="color: #008700;">&amp;define</span> sexp
                           [&amp;optional stringp]
                           [&amp;optional (<span style="color: #87005f;">"interactive"</span> interactive)]
                           def-body)))
  (<span style="color: #af00ff;">cond</span>
    ((not (consp match-form))
     (<span style="color: #ff0000; font-weight: bold;">signal</span> 'wrong-type-argument <span style="color: #87005f;">"match-form must be a list"</span>))
    <span style="color: #af0000;">;; </span><span style="color: #af0000;">no destructuring, so just return regular lambda to make things faster</span>
    ((-all? 'symbolp match-form)
     `(<span style="color: #af00ff;">lambda</span> ,match-form ,@body))
    (t
     (<span style="color: #af00ff;">let*</span> ((inputs (--map-indexed (list it (make-symbol (format <span style="color: #87005f;">"input%d"</span> it-index))) match-form)))
       <span style="color: #af0000;">;; </span><span style="color: #af0000;">TODO: because inputs to the lambda are evaluated only once,</span>
       <span style="color: #af0000;">;; </span><span style="color: #af0000;">-let* need not to create the extra bindings to ensure that.</span>
       <span style="color: #af0000;">;; </span><span style="color: #af0000;">We should find a way to optimize that.  Not critical however.</span>
       `(<span style="color: #af00ff;">lambda</span> ,(--map (cadr it) inputs)
          (-let* ,inputs ,@body))))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-if-let*</span> (vars-vals then <span style="color: #008700;">&amp;rest</span> else)
  <span style="color: #87005f;">"If all VALS evaluate to true, bind them to their corresponding</span>
<span style="color: #87005f;">VARS and do THEN, otherwise do ELSE. VARS-VALS should be a list</span>
<span style="color: #87005f;">of (VAR VAL) pairs.</span>

<span style="color: #87005f;">Note: binding is done according to `</span><span style="color: #008787;">-let*</span><span style="color: #87005f;">'.  VALS are evaluated</span>
<span style="color: #87005f;">sequentially, and evaluation stops after the first nil VAL is</span>
<span style="color: #87005f;">encountered."</span>
  (<span style="color: #af00ff;">declare</span> (debug ((<span style="color: #008700;">&amp;rest</span> (sexp form)) form body))
           (indent 2))
  (-&gt;&gt; vars-vals
       (--mapcat (dash--match (car it) (cadr it)))
       (--reduce-r-from
        (<span style="color: #af00ff;">let</span> ((var (car it))
              (val (cadr it)))
          `(<span style="color: #af00ff;">let</span> ((,var ,val))
             (<span style="color: #af00ff;">if</span> ,var ,acc ,@else)))
        then)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-if-let</span> (var-val then <span style="color: #008700;">&amp;rest</span> else)
  <span style="color: #87005f;">"If VAL evaluates to non-nil, bind it to VAR and do THEN,</span>
<span style="color: #87005f;">otherwise do ELSE. VAR-VAL should be a (VAR VAL) pair.</span>

<span style="color: #87005f;">Note: binding is done according to `</span><span style="color: #008787;">-let</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug ((sexp form) form body))
           (indent 2))
  `(-if-let* (,var-val) ,then ,@else))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--if-let</span> (val then <span style="color: #008700;">&amp;rest</span> else)
  <span style="color: #87005f;">"If VAL evaluates to non-nil, bind it to `</span><span style="color: #008787;">it</span><span style="color: #87005f;">' and do THEN,</span>
<span style="color: #87005f;">otherwise do ELSE."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form body))
           (indent 2))
  `(-if-let (it ,val) ,then ,@else))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-when-let*</span> (vars-vals <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"If all VALS evaluate to true, bind them to their corresponding</span>
<span style="color: #87005f;">VARS and execute body. VARS-VALS should be a list of (VAR VAL)</span>
<span style="color: #87005f;">pairs.</span>

<span style="color: #87005f;">Note: binding is done according to `</span><span style="color: #008787;">-let*</span><span style="color: #87005f;">'.  VALS are evaluated</span>
<span style="color: #87005f;">sequentially, and evaluation stops after the first nil VAL is</span>
<span style="color: #87005f;">encountered."</span>
  (<span style="color: #af00ff;">declare</span> (debug ((<span style="color: #008700;">&amp;rest</span> (sexp form)) body))
           (indent 1))
  `(-if-let* ,vars-vals (<span style="color: #af00ff;">progn</span> ,@body)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-when-let</span> (var-val <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"If VAL evaluates to non-nil, bind it to VAR and execute body.</span>
<span style="color: #87005f;">VAR-VAL should be a (VAR VAL) pair.</span>

<span style="color: #87005f;">Note: binding is done according to `</span><span style="color: #008787;">-let</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug ((sexp form) body))
           (indent 1))
  `(-if-let ,var-val (<span style="color: #af00ff;">progn</span> ,@body)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--when-let</span> (val <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"If VAL evaluates to non-nil, bind it to `</span><span style="color: #008787;">it</span><span style="color: #87005f;">' and execute</span>
<span style="color: #87005f;">body."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form body))
           (indent 1))
  `(--if-let ,val (<span style="color: #af00ff;">progn</span> ,@body)))

(<span style="color: #af00ff;">defvar</span> <span style="color: #af5f00;">-compare-fn</span> nil
  <span style="color: #87005f;">"Tests for equality use this function or `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">' if this is nil.</span>
<span style="color: #87005f;">It should only be set using dynamic scope with a let, like:</span>

<span style="color: #87005f;">  (let ((-compare-fn #'=)) (-union numbers1 numbers2 numbers3)"</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-distinct</span> (list)
  <span style="color: #87005f;">"Return a new list with all duplicates removed.</span>
<span style="color: #87005f;">The test for equality is done with `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">',</span>
<span style="color: #87005f;">or with `</span><span style="color: #008787;">-compare-fn</span><span style="color: #87005f;">' if that's non-nil.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-uniq</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> (result)
    (--each list (<span style="color: #af00ff;">unless</span> (-contains? result it) (!cons it result)))
    (nreverse result)))

(defalias '-uniq '-distinct)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-union</span> (list list2)
  <span style="color: #87005f;">"Return a new list containing the elements of LIST1 and elements of LIST2 that are not in LIST1.</span>
<span style="color: #87005f;">The test for equality is done with `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">',</span>
<span style="color: #87005f;">or with `</span><span style="color: #008787;">-compare-fn</span><span style="color: #87005f;">' if that's non-nil."</span>
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">We fall back to iteration implementation if the comparison</span>
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">function isn't one of `</span><span style="color: #008787;">eq</span><span style="color: #af0000;">', `</span><span style="color: #008787;">eql</span><span style="color: #af0000;">' or `</span><span style="color: #008787;">equal</span><span style="color: #af0000;">'.</span>
  (<span style="color: #af00ff;">let*</span> ((result (reverse list))
         <span style="color: #af0000;">;; </span><span style="color: #af0000;">TODO: get rid of this dynamic variable, pass it as an</span>
         <span style="color: #af0000;">;; </span><span style="color: #af0000;">argument instead.</span>
         (-compare-fn (<span style="color: #af00ff;">if</span> (bound-and-true-p -compare-fn)
                          -compare-fn
                          'equal)))
    (<span style="color: #af00ff;">if</span> (memq -compare-fn '(eq eql equal))
        (<span style="color: #af00ff;">let</span> ((ht (make-hash-table <span style="color: #5f5f87;">:test</span> -compare-fn)))
          (--each list (puthash it t ht))
          (--each list2 (<span style="color: #af00ff;">unless</span> (gethash it ht) (!cons it result))))
        (--each list2 (<span style="color: #af00ff;">unless</span> (-contains? result it) (!cons it result))))
    (nreverse result)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-intersection</span> (list list2)
  <span style="color: #87005f;">"Return a new list containing only the elements that are members of both LIST and LIST2.</span>
<span style="color: #87005f;">The test for equality is done with `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">',</span>
<span style="color: #87005f;">or with `</span><span style="color: #008787;">-compare-fn</span><span style="color: #87005f;">' if that's non-nil."</span>
  (--filter (-contains? list2 it) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-difference</span> (list list2)
  <span style="color: #87005f;">"Return a new list with only the members of LIST that are not in LIST2.</span>
<span style="color: #87005f;">The test for equality is done with `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">',</span>
<span style="color: #87005f;">or with `</span><span style="color: #008787;">-compare-fn</span><span style="color: #87005f;">' if that's non-nil."</span>
  (--filter (not (-contains? list2 it)) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-contains?</span> (list element)
  <span style="color: #87005f;">"Return non-nil if LIST contains ELEMENT.</span>

<span style="color: #87005f;">The test for equality is done with `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">', or with `</span><span style="color: #008787;">-compare-fn</span><span style="color: #87005f;">'</span>
<span style="color: #87005f;">if that's non-nil.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-contains-p</span><span style="color: #87005f;">'"</span>
  (not
   (null
    (<span style="color: #af00ff;">cond</span>
      ((null -compare-fn)    (member element list))
      ((eq -compare-fn 'eq)  (memq element list))
      ((eq -compare-fn 'eql) (memql element list))
      (t
       (<span style="color: #af00ff;">let</span> ((lst list))
         (<span style="color: #af00ff;">while</span> (and lst
                     (not (funcall -compare-fn element (car lst))))
           (setq lst (cdr lst)))
         lst))))))

(defalias '-contains-p '-contains?)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-same-items?</span> (list list2)
  <span style="color: #87005f;">"Return true if LIST and LIST2 has the same items.</span>

<span style="color: #87005f;">The order of the elements in the lists does not matter.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-same-items-p</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> ((length-a (length list))
        (length-b (length list2)))
    (and
     (<span style="color: #af00ff;">=</span> length-a length-b)
     (<span style="color: #af00ff;">=</span> length-a (length (-intersection list list2))))))

(defalias '-same-items-p '-same-items?)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-is-prefix?</span> (prefix list)
  <span style="color: #87005f;">"Return non-nil if PREFIX is prefix of LIST.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-is-prefix-p</span><span style="color: #87005f;">'"</span>
  (--each-while list (equal (car prefix) it)
                (!cdr prefix))
  (not prefix))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-is-suffix?</span> (suffix list)
  <span style="color: #87005f;">"Return non-nil if SUFFIX is suffix of LIST.</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-is-suffix-p</span><span style="color: #87005f;">'"</span>
  (-is-prefix? (reverse suffix) (reverse list)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-is-infix?</span> (infix list)
  <span style="color: #87005f;">"Return non-nil if INFIX is infix of LIST.</span>

<span style="color: #87005f;">This operation runs in O(n^2) time</span>

<span style="color: #87005f;">Alias: `</span><span style="color: #008787;">-is-infix-p</span><span style="color: #87005f;">'"</span>
  (<span style="color: #af00ff;">let</span> (done)
    (<span style="color: #af00ff;">while</span> (and (not done) list)
      (setq done (-is-prefix? infix list))
      (!cdr list))
    done))

(defalias '-is-prefix-p '-is-prefix?)
(defalias '-is-suffix-p '-is-suffix?)
(defalias '-is-infix-p '-is-infix?)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-sort</span> (comparator list)
  <span style="color: #87005f;">"Sort LIST, stably, comparing elements using COMPARATOR.</span>
<span style="color: #87005f;">Return the sorted list.  LIST is NOT modified by side effects.</span>
<span style="color: #87005f;">COMPARATOR is called with two elements of LIST, and should return non-nil</span>
<span style="color: #87005f;">if the first element should sort before the second."</span>
  (sort (copy-sequence list) comparator))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--sort</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-sort</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-sort (<span style="color: #af00ff;">lambda</span> (it other) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-list</span> (<span style="color: #008700;">&amp;rest</span> args)
  <span style="color: #87005f;">"Return a list with ARGS.</span>

<span style="color: #87005f;">If first item of ARGS is already a list, simply return ARGS.  If</span>
<span style="color: #87005f;">not, return a list with ARGS as elements."</span>
  (<span style="color: #af00ff;">let</span> ((arg (car args)))
    (<span style="color: #af00ff;">if</span> (listp arg) arg args)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-repeat</span> (n x)
  <span style="color: #87005f;">"Return a list with X repeated N times.</span>
<span style="color: #87005f;">Return nil if N is less than 1."</span>
  (<span style="color: #af00ff;">let</span> (ret)
    (--dotimes n (!cons x ret))
    ret))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-sum</span> (list)
  <span style="color: #87005f;">"Return the sum of LIST."</span>
  (apply '+ list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-product</span> (list)
  <span style="color: #87005f;">"Return the product of LIST."</span>
  (apply '* list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-max</span> (list)
  <span style="color: #87005f;">"Return the largest value from LIST of numbers or markers."</span>
  (apply 'max list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-min</span> (list)
  <span style="color: #87005f;">"Return the smallest value from LIST of numbers or markers."</span>
  (apply 'min list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-max-by</span> (comparator list)
  <span style="color: #87005f;">"Take a comparison function COMPARATOR and a LIST and return</span>
<span style="color: #87005f;">the greatest element of the list by the comparison function.</span>

<span style="color: #87005f;">See also combinator `</span><span style="color: #008787;">-on</span><span style="color: #87005f;">' which can transform the values before</span>
<span style="color: #87005f;">comparing them."</span>
  (--reduce (<span style="color: #af00ff;">if</span> (funcall comparator it acc) it acc) list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-min-by</span> (comparator list)
  <span style="color: #87005f;">"Take a comparison function COMPARATOR and a LIST and return</span>
<span style="color: #87005f;">the least element of the list by the comparison function.</span>

<span style="color: #87005f;">See also combinator `</span><span style="color: #008787;">-on</span><span style="color: #87005f;">' which can transform the values before</span>
<span style="color: #87005f;">comparing them."</span>
  (--reduce (<span style="color: #af00ff;">if</span> (funcall comparator it acc) acc it) list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--max-by</span> (form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-max-by</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">The items for the comparator form are exposed as \"it\" and \"other\"."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-max-by (<span style="color: #af00ff;">lambda</span> (it other) ,form) ,list))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--min-by</span> (form list)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-min-by</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">The items for the comparator form are exposed as \"it\" and \"other\"."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-min-by (<span style="color: #af00ff;">lambda</span> (it other) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-iterate</span> (fun init n)
  <span style="color: #87005f;">"Return a list of iterated applications of FUN to INIT.</span>

<span style="color: #87005f;">This means a list of form:</span>

<span style="color: #87005f;">  (init (fun init) (fun (fun init)) ...)</span>

<span style="color: #87005f;">N is the length of the returned list."</span>
  (<span style="color: #af00ff;">if</span> (<span style="color: #af00ff;">=</span> n 0) nil
      (<span style="color: #af00ff;">let</span> ((r (list init)))
        (--dotimes (1- n)
                   (push (funcall fun (car r)) r))
        (nreverse r))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-fix</span> (fn list)
  <span style="color: #87005f;">"Compute the (least) fixpoint of FN with initial input LIST.</span>

<span style="color: #87005f;">FN is called at least once, results are compared with `</span><span style="color: #008787;">equal</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">let</span> ((re (funcall fn list)))
    (<span style="color: #af00ff;">while</span> (not (equal list re))
      (setq list re)
      (setq re (funcall fn re)))
    re))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--fix</span> (form list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-fix</span><span style="color: #87005f;">'."</span>
  `(-fix (<span style="color: #af00ff;">lambda</span> (it) ,form) ,list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-unfold</span> (fun seed)
  <span style="color: #87005f;">"Build a list from SEED using FUN.</span>

<span style="color: #87005f;">This is \"dual\" operation to `</span><span style="color: #008787;">-reduce-r</span><span style="color: #87005f;">': while -reduce-r</span>
<span style="color: #87005f;">consumes a list to produce a single value, `</span><span style="color: #008787;">-unfold</span><span style="color: #87005f;">' takes a</span>
<span style="color: #87005f;">seed value and builds a (potentially infinite!) list.</span>

<span style="color: #87005f;">FUN should return `</span><span style="color: #008787;">nil</span><span style="color: #87005f;">' to stop the generating process, or a</span>
<span style="color: #87005f;">cons (A . B), where A will be prepended to the result and B is</span>
<span style="color: #87005f;">the new seed."</span>
  (<span style="color: #af00ff;">let</span> ((last (funcall fun seed)) r)
    (<span style="color: #af00ff;">while</span> last
      (push (car last) r)
      (setq last (funcall fun (cdr last))))
    (nreverse r)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--unfold</span> (form seed)
  <span style="color: #87005f;">"Anaphoric version of `</span><span style="color: #008787;">-unfold</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-unfold (<span style="color: #af00ff;">lambda</span> (it) ,form) ,seed))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-cons-pair?</span> (con)
  <span style="color: #87005f;">"Return non-nil if CON is true cons pair.</span>
<span style="color: #87005f;">That is (A . B) where B is not a list."</span>
  (and (listp con)
       (not (listp (cdr con)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-cons-to-list</span> (con)
  <span style="color: #87005f;">"Convert a cons pair to a list with `</span><span style="color: #008787;">car</span><span style="color: #87005f;">' and `</span><span style="color: #008787;">cdr</span><span style="color: #87005f;">' of the pair respectively."</span>
  (list (car con) (cdr con)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-value-to-list</span> (val)
  <span style="color: #87005f;">"Convert a value to a list.</span>

<span style="color: #87005f;">If the value is a cons pair, make a list with two elements, `</span><span style="color: #008787;">car</span><span style="color: #87005f;">'</span>
<span style="color: #87005f;">and `</span><span style="color: #008787;">cdr</span><span style="color: #87005f;">' of the pair respectively.</span>

<span style="color: #87005f;">If the value is anything else, wrap it in a list."</span>
  (<span style="color: #af00ff;">cond</span>
    ((-cons-pair? val) (-cons-to-list val))
    (t (list val))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-tree-mapreduce-from</span> (fn folder init-value tree)
  <span style="color: #87005f;">"Apply FN to each element of TREE, and make a list of the results.</span>
<span style="color: #87005f;">If elements of TREE are lists themselves, apply FN recursively to</span>
<span style="color: #87005f;">elements of these nested lists.</span>

<span style="color: #87005f;">Then reduce the resulting lists using FOLDER and initial value</span>
<span style="color: #87005f;">INIT-VALUE. See `</span><span style="color: #008787;">-reduce-r-from</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">This is the same as calling `</span><span style="color: #008787;">-tree-reduce-from</span><span style="color: #87005f;">' after `</span><span style="color: #008787;">-tree-map</span><span style="color: #87005f;">'</span>
<span style="color: #87005f;">but is twice as fast as it only traverse the structure once."</span>
  (<span style="color: #af00ff;">cond</span>
    ((not tree) nil)
    ((-cons-pair? tree) (funcall fn tree))
    ((listp tree)
     (-reduce-r-from folder init-value (mapcar (<span style="color: #af00ff;">lambda</span> (x) (-tree-mapreduce-from fn folder init-value x)) tree)))
    (t (funcall fn tree))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--tree-mapreduce-from</span> (form folder init-value tree)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-tree-mapreduce-from</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form form)))
  `(-tree-mapreduce-from (<span style="color: #af00ff;">lambda</span> (it) ,form) (<span style="color: #af00ff;">lambda</span> (it acc) ,folder) ,init-value ,tree))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-tree-mapreduce</span> (fn folder tree)
  <span style="color: #87005f;">"Apply FN to each element of TREE, and make a list of the results.</span>
<span style="color: #87005f;">If elements of TREE are lists themselves, apply FN recursively to</span>
<span style="color: #87005f;">elements of these nested lists.</span>

<span style="color: #87005f;">Then reduce the resulting lists using FOLDER and initial value</span>
<span style="color: #87005f;">INIT-VALUE. See `</span><span style="color: #008787;">-reduce-r-from</span><span style="color: #87005f;">'.</span>

<span style="color: #87005f;">This is the same as calling `</span><span style="color: #008787;">-tree-reduce</span><span style="color: #87005f;">' after `</span><span style="color: #008787;">-tree-map</span><span style="color: #87005f;">'</span>
<span style="color: #87005f;">but is twice as fast as it only traverse the structure once."</span>
  (<span style="color: #af00ff;">cond</span>
    ((not tree) nil)
    ((-cons-pair? tree) (funcall fn tree))
    ((listp tree)
     (-reduce-r folder (mapcar (<span style="color: #af00ff;">lambda</span> (x) (-tree-mapreduce fn folder x)) tree)))
    (t (funcall fn tree))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--tree-mapreduce</span> (form folder tree)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-tree-mapreduce</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form)))
  `(-tree-mapreduce (<span style="color: #af00ff;">lambda</span> (it) ,form) (<span style="color: #af00ff;">lambda</span> (it acc) ,folder) ,tree))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-tree-map</span> (fn tree)
  <span style="color: #87005f;">"Apply FN to each element of TREE while preserving the tree structure."</span>
  (<span style="color: #af00ff;">cond</span>
    ((not tree) nil)
    ((-cons-pair? tree) (funcall fn tree))
    ((listp tree)
     (mapcar (<span style="color: #af00ff;">lambda</span> (x) (-tree-map fn x)) tree))
    (t (funcall fn tree))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--tree-map</span> (form tree)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-tree-map</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-tree-map (<span style="color: #af00ff;">lambda</span> (it) ,form) ,tree))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-tree-reduce-from</span> (fn init-value tree)
  <span style="color: #87005f;">"Use FN to reduce elements of list TREE.</span>
<span style="color: #87005f;">If elements of TREE are lists themselves, apply the reduction recursively.</span>

<span style="color: #87005f;">FN is first applied to INIT-VALUE and first element of the list,</span>
<span style="color: #87005f;">then on this result and second element from the list etc.</span>

<span style="color: #87005f;">The initial value is ignored on cons pairs as they always contain</span>
<span style="color: #87005f;">two elements."</span>
  (<span style="color: #af00ff;">cond</span>
    ((not tree) nil)
    ((-cons-pair? tree) tree)
    ((listp tree)
     (-reduce-r-from fn init-value (mapcar (<span style="color: #af00ff;">lambda</span> (x) (-tree-reduce-from fn init-value x)) tree)))
    (t tree)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--tree-reduce-from</span> (form init-value tree)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-tree-reduce-from</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form form)))
  `(-tree-reduce-from (<span style="color: #af00ff;">lambda</span> (it acc) ,form) ,init-value ,tree))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-tree-reduce</span> (fn tree)
  <span style="color: #87005f;">"Use FN to reduce elements of list TREE.</span>
<span style="color: #87005f;">If elements of TREE are lists themselves, apply the reduction recursively.</span>

<span style="color: #87005f;">FN is first applied to first element of the list and second</span>
<span style="color: #87005f;">element, then on this result and third element from the list etc.</span>

<span style="color: #87005f;">See `</span><span style="color: #008787;">-reduce-r</span><span style="color: #87005f;">' for how exactly are lists of zero or one element handled."</span>
  (<span style="color: #af00ff;">cond</span>
    ((not tree) nil)
    ((-cons-pair? tree) tree)
    ((listp tree)
     (-reduce-r fn (mapcar (<span style="color: #af00ff;">lambda</span> (x) (-tree-reduce fn x)) tree)))
    (t tree)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--tree-reduce</span> (form tree)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-tree-reduce</span><span style="color: #87005f;">'."</span>
  (<span style="color: #af00ff;">declare</span> (debug (form form)))
  `(-tree-reduce (<span style="color: #af00ff;">lambda</span> (it acc) ,form) ,tree))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-tree-map-nodes</span> (pred fun tree)
  <span style="color: #87005f;">"Call FUN on each node of TREE that satisfies PRED.</span>

<span style="color: #87005f;">If PRED returns nil, continue descending down this node.  If PRED</span>
<span style="color: #87005f;">returns non-nil, apply FUN to this node and do not descend</span>
<span style="color: #87005f;">further."</span>
  (<span style="color: #af00ff;">if</span> (funcall pred tree)
      (funcall fun tree)
      (<span style="color: #af00ff;">if</span> (and (listp tree)
               (not (-cons-pair? tree)))
          (-map (<span style="color: #af00ff;">lambda</span> (x) (-tree-map-nodes pred fun x)) tree)
          tree)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--tree-map-nodes</span> (pred form tree)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-tree-map-nodes</span><span style="color: #87005f;">'."</span>
  `(-tree-map-nodes (<span style="color: #af00ff;">lambda</span> (it) ,pred) (<span style="color: #af00ff;">lambda</span> (it) ,form) ,tree))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-tree-seq</span> (branch children tree)
  <span style="color: #87005f;">"Return a sequence of the nodes in TREE, in depth-first search order.</span>

<span style="color: #87005f;">BRANCH is a predicate of one argument that returns non-nil if the</span>
<span style="color: #87005f;">passed argument is a branch, that is, a node that can have children.</span>

<span style="color: #87005f;">CHILDREN is a function of one argument that returns the children</span>
<span style="color: #87005f;">of the passed branch node.</span>

<span style="color: #87005f;">Non-branch nodes are simply copied."</span>
  (cons tree
        (<span style="color: #af00ff;">when</span> (funcall branch tree)
          (-mapcat (<span style="color: #af00ff;">lambda</span> (x) (-tree-seq branch children x))
                   (funcall children tree)))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--tree-seq</span> (branch children tree)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-tree-seq</span><span style="color: #87005f;">'."</span>
  `(-tree-seq (<span style="color: #af00ff;">lambda</span> (it) ,branch) (<span style="color: #af00ff;">lambda</span> (it) ,children) ,tree))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-clone</span> (list)
  <span style="color: #87005f;">"Create a deep copy of LIST.</span>
<span style="color: #87005f;">The new list has the same elements and structure but all cons are</span>
<span style="color: #87005f;">replaced with new ones.  This is useful when you need to clone a</span>
<span style="color: #87005f;">structure such as plist or alist."</span>
  (-tree-map 'identity list))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">dash-enable-font-lock</span> ()
  <span style="color: #87005f;">"Add syntax highlighting to dash functions, macros and magic values."</span>
  (eval-after-load <span style="color: #87005f;">"lisp-mode"</span>
    '(<span style="color: #af00ff;">progn</span>
      (<span style="color: #af00ff;">let</span> ((new-keywords '(
                            <span style="color: #87005f;">"-each"</span>
                            <span style="color: #87005f;">"--each"</span>
                            <span style="color: #87005f;">"-each-while"</span>
                            <span style="color: #87005f;">"--each-while"</span>
                            <span style="color: #87005f;">"-dotimes"</span>
                            <span style="color: #87005f;">"--dotimes"</span>
                            <span style="color: #87005f;">"-map"</span>
                            <span style="color: #87005f;">"--map"</span>
                            <span style="color: #87005f;">"-reduce-from"</span>
                            <span style="color: #87005f;">"--reduce-from"</span>
                            <span style="color: #87005f;">"-reduce"</span>
                            <span style="color: #87005f;">"--reduce"</span>
                            <span style="color: #87005f;">"-reduce-r-from"</span>
                            <span style="color: #87005f;">"--reduce-r-from"</span>
                            <span style="color: #87005f;">"-reduce-r"</span>
                            <span style="color: #87005f;">"--reduce-r"</span>
                            <span style="color: #87005f;">"-filter"</span>
                            <span style="color: #87005f;">"--filter"</span>
                            <span style="color: #87005f;">"-select"</span>
                            <span style="color: #87005f;">"--select"</span>
                            <span style="color: #87005f;">"-remove"</span>
                            <span style="color: #87005f;">"--remove"</span>
                            <span style="color: #87005f;">"-reject"</span>
                            <span style="color: #87005f;">"--reject"</span>
                            <span style="color: #87005f;">"-remove-first"</span>
                            <span style="color: #87005f;">"--remove-first"</span>
                            <span style="color: #87005f;">"-reject-first"</span>
                            <span style="color: #87005f;">"--reject-first"</span>
                            <span style="color: #87005f;">"-remove-last"</span>
                            <span style="color: #87005f;">"--remove-last"</span>
                            <span style="color: #87005f;">"-reject-last"</span>
                            <span style="color: #87005f;">"--reject-last"</span>
                            <span style="color: #87005f;">"-remove-item"</span>
                            <span style="color: #87005f;">"-non-nil"</span>
                            <span style="color: #87005f;">"-keep"</span>
                            <span style="color: #87005f;">"--keep"</span>
                            <span style="color: #87005f;">"-map-indexed"</span>
                            <span style="color: #87005f;">"--map-indexed"</span>
                            <span style="color: #87005f;">"-splice"</span>
                            <span style="color: #87005f;">"--splice"</span>
                            <span style="color: #87005f;">"-splice-list"</span>
                            <span style="color: #87005f;">"--splice-list"</span>
                            <span style="color: #87005f;">"-map-when"</span>
                            <span style="color: #87005f;">"--map-when"</span>
                            <span style="color: #87005f;">"-replace-where"</span>
                            <span style="color: #87005f;">"--replace-where"</span>
                            <span style="color: #87005f;">"-map-first"</span>
                            <span style="color: #87005f;">"--map-first"</span>
                            <span style="color: #87005f;">"-map-last"</span>
                            <span style="color: #87005f;">"--map-last"</span>
                            <span style="color: #87005f;">"-replace"</span>
                            <span style="color: #87005f;">"-replace-first"</span>
                            <span style="color: #87005f;">"-replace-last"</span>
                            <span style="color: #87005f;">"-flatten"</span>
                            <span style="color: #87005f;">"-flatten-n"</span>
                            <span style="color: #87005f;">"-concat"</span>
                            <span style="color: #87005f;">"-mapcat"</span>
                            <span style="color: #87005f;">"--mapcat"</span>
                            <span style="color: #87005f;">"-copy"</span>
                            <span style="color: #87005f;">"-cons*"</span>
                            <span style="color: #87005f;">"-snoc"</span>
                            <span style="color: #87005f;">"-first"</span>
                            <span style="color: #87005f;">"--first"</span>
                            <span style="color: #87005f;">"-find"</span>
                            <span style="color: #87005f;">"--find"</span>
                            <span style="color: #87005f;">"-some"</span>
                            <span style="color: #87005f;">"--some"</span>
                            <span style="color: #87005f;">"-any"</span>
                            <span style="color: #87005f;">"--any"</span>
                            <span style="color: #87005f;">"-last"</span>
                            <span style="color: #87005f;">"--last"</span>
                            <span style="color: #87005f;">"-first-item"</span>
                            <span style="color: #87005f;">"-last-item"</span>
                            <span style="color: #87005f;">"-butlast"</span>
                            <span style="color: #87005f;">"-count"</span>
                            <span style="color: #87005f;">"--count"</span>
                            <span style="color: #87005f;">"-any?"</span>
                            <span style="color: #87005f;">"--any?"</span>
                            <span style="color: #87005f;">"-some?"</span>
                            <span style="color: #87005f;">"--some?"</span>
                            <span style="color: #87005f;">"-any-p"</span>
                            <span style="color: #87005f;">"--any-p"</span>
                            <span style="color: #87005f;">"-some-p"</span>
                            <span style="color: #87005f;">"--some-p"</span>
                            <span style="color: #87005f;">"-all?"</span>
                            <span style="color: #87005f;">"--all?"</span>
                            <span style="color: #87005f;">"-every?"</span>
                            <span style="color: #87005f;">"--every?"</span>
                            <span style="color: #87005f;">"-all-p"</span>
                            <span style="color: #87005f;">"--all-p"</span>
                            <span style="color: #87005f;">"-every-p"</span>
                            <span style="color: #87005f;">"--every-p"</span>
                            <span style="color: #87005f;">"-none?"</span>
                            <span style="color: #87005f;">"--none?"</span>
                            <span style="color: #87005f;">"-none-p"</span>
                            <span style="color: #87005f;">"--none-p"</span>
                            <span style="color: #87005f;">"-only-some?"</span>
                            <span style="color: #87005f;">"--only-some?"</span>
                            <span style="color: #87005f;">"-only-some-p"</span>
                            <span style="color: #87005f;">"--only-some-p"</span>
                            <span style="color: #87005f;">"-slice"</span>
                            <span style="color: #87005f;">"-take"</span>
                            <span style="color: #87005f;">"-drop"</span>
                            <span style="color: #87005f;">"-take-while"</span>
                            <span style="color: #87005f;">"--take-while"</span>
                            <span style="color: #87005f;">"-drop-while"</span>
                            <span style="color: #87005f;">"--drop-while"</span>
                            <span style="color: #87005f;">"-split-at"</span>
                            <span style="color: #87005f;">"-rotate"</span>
                            <span style="color: #87005f;">"-insert-at"</span>
                            <span style="color: #87005f;">"-replace-at"</span>
                            <span style="color: #87005f;">"-update-at"</span>
                            <span style="color: #87005f;">"--update-at"</span>
                            <span style="color: #87005f;">"-remove-at"</span>
                            <span style="color: #87005f;">"-remove-at-indices"</span>
                            <span style="color: #87005f;">"-split-with"</span>
                            <span style="color: #87005f;">"--split-with"</span>
                            <span style="color: #87005f;">"-split-on"</span>
                            <span style="color: #87005f;">"-split-when"</span>
                            <span style="color: #87005f;">"--split-when"</span>
                            <span style="color: #87005f;">"-separate"</span>
                            <span style="color: #87005f;">"--separate"</span>
                            <span style="color: #87005f;">"-partition-all-in-steps"</span>
                            <span style="color: #87005f;">"-partition-in-steps"</span>
                            <span style="color: #87005f;">"-partition-all"</span>
                            <span style="color: #87005f;">"-partition"</span>
                            <span style="color: #87005f;">"-partition-by"</span>
                            <span style="color: #87005f;">"--partition-by"</span>
                            <span style="color: #87005f;">"-partition-by-header"</span>
                            <span style="color: #87005f;">"--partition-by-header"</span>
                            <span style="color: #87005f;">"-group-by"</span>
                            <span style="color: #87005f;">"--group-by"</span>
                            <span style="color: #87005f;">"-interpose"</span>
                            <span style="color: #87005f;">"-interleave"</span>
                            <span style="color: #87005f;">"-zip-with"</span>
                            <span style="color: #87005f;">"--zip-with"</span>
                            <span style="color: #87005f;">"-zip"</span>
                            <span style="color: #87005f;">"-zip-fill"</span>
                            <span style="color: #87005f;">"-cycle"</span>
                            <span style="color: #87005f;">"-pad"</span>
                            <span style="color: #87005f;">"-annotate"</span>
                            <span style="color: #87005f;">"--annotate"</span>
                            <span style="color: #87005f;">"-table"</span>
                            <span style="color: #87005f;">"-table-flat"</span>
                            <span style="color: #87005f;">"-partial"</span>
                            <span style="color: #87005f;">"-elem-index"</span>
                            <span style="color: #87005f;">"-elem-indices"</span>
                            <span style="color: #87005f;">"-find-indices"</span>
                            <span style="color: #87005f;">"--find-indices"</span>
                            <span style="color: #87005f;">"-find-index"</span>
                            <span style="color: #87005f;">"--find-index"</span>
                            <span style="color: #87005f;">"-find-last-index"</span>
                            <span style="color: #87005f;">"--find-last-index"</span>
                            <span style="color: #87005f;">"-select-by-indices"</span>
                            <span style="color: #87005f;">"-grade-up"</span>
                            <span style="color: #87005f;">"-grade-down"</span>
                            <span style="color: #87005f;">"-&gt;"</span>
                            <span style="color: #87005f;">"-&gt;&gt;"</span>
                            <span style="color: #87005f;">"--&gt;"</span>
                            <span style="color: #87005f;">"-when-let"</span>
                            <span style="color: #87005f;">"-when-let*"</span>
                            <span style="color: #87005f;">"--when-let"</span>
                            <span style="color: #87005f;">"-if-let"</span>
                            <span style="color: #87005f;">"-if-let*"</span>
                            <span style="color: #87005f;">"--if-let"</span>
                            <span style="color: #87005f;">"-let*"</span>
                            <span style="color: #87005f;">"-let"</span>
                            <span style="color: #87005f;">"-lambda"</span>
                            <span style="color: #87005f;">"-distinct"</span>
                            <span style="color: #87005f;">"-uniq"</span>
                            <span style="color: #87005f;">"-union"</span>
                            <span style="color: #87005f;">"-intersection"</span>
                            <span style="color: #87005f;">"-difference"</span>
                            <span style="color: #87005f;">"-contains?"</span>
                            <span style="color: #87005f;">"-contains-p"</span>
                            <span style="color: #87005f;">"-same-items?"</span>
                            <span style="color: #87005f;">"-same-items-p"</span>
                            <span style="color: #87005f;">"-is-prefix-p"</span>
                            <span style="color: #87005f;">"-is-prefix?"</span>
                            <span style="color: #87005f;">"-is-suffix-p"</span>
                            <span style="color: #87005f;">"-is-suffix?"</span>
                            <span style="color: #87005f;">"-is-infix-p"</span>
                            <span style="color: #87005f;">"-is-infix?"</span>
                            <span style="color: #87005f;">"-sort"</span>
                            <span style="color: #87005f;">"--sort"</span>
                            <span style="color: #87005f;">"-list"</span>
                            <span style="color: #87005f;">"-repeat"</span>
                            <span style="color: #87005f;">"-sum"</span>
                            <span style="color: #87005f;">"-product"</span>
                            <span style="color: #87005f;">"-max"</span>
                            <span style="color: #87005f;">"-min"</span>
                            <span style="color: #87005f;">"-max-by"</span>
                            <span style="color: #87005f;">"--max-by"</span>
                            <span style="color: #87005f;">"-min-by"</span>
                            <span style="color: #87005f;">"--min-by"</span>
                            <span style="color: #87005f;">"-iterate"</span>
                            <span style="color: #87005f;">"--iterate"</span>
                            <span style="color: #87005f;">"-fix"</span>
                            <span style="color: #87005f;">"--fix"</span>
                            <span style="color: #87005f;">"-unfold"</span>
                            <span style="color: #87005f;">"--unfold"</span>
                            <span style="color: #87005f;">"-cons-pair?"</span>
                            <span style="color: #87005f;">"-cons-to-list"</span>
                            <span style="color: #87005f;">"-value-to-list"</span>
                            <span style="color: #87005f;">"-tree-mapreduce-from"</span>
                            <span style="color: #87005f;">"--tree-mapreduce-from"</span>
                            <span style="color: #87005f;">"-tree-mapreduce"</span>
                            <span style="color: #87005f;">"--tree-mapreduce"</span>
                            <span style="color: #87005f;">"-tree-map"</span>
                            <span style="color: #87005f;">"--tree-map"</span>
                            <span style="color: #87005f;">"-tree-reduce-from"</span>
                            <span style="color: #87005f;">"--tree-reduce-from"</span>
                            <span style="color: #87005f;">"-tree-reduce"</span>
                            <span style="color: #87005f;">"--tree-reduce"</span>
                            <span style="color: #87005f;">"-tree-seq"</span>
                            <span style="color: #87005f;">"--tree-seq"</span>
                            <span style="color: #87005f;">"-tree-map-nodes"</span>
                            <span style="color: #87005f;">"--tree-map-nodes"</span>
                            <span style="color: #87005f;">"-clone"</span>
                            <span style="color: #87005f;">"-rpartial"</span>
                            <span style="color: #87005f;">"-juxt"</span>
                            <span style="color: #87005f;">"-applify"</span>
                            <span style="color: #87005f;">"-on"</span>
                            <span style="color: #87005f;">"-flip"</span>
                            <span style="color: #87005f;">"-const"</span>
                            <span style="color: #87005f;">"-cut"</span>
                            <span style="color: #87005f;">"-orfn"</span>
                            <span style="color: #87005f;">"-andfn"</span>
                            <span style="color: #87005f;">"-iteratefn"</span>
                            <span style="color: #87005f;">"-fixfn"</span>
                            <span style="color: #87005f;">"-prodfn"</span>
                            ))
            (special-variables '(
                                 <span style="color: #87005f;">"it"</span>
                                 <span style="color: #87005f;">"it-index"</span>
                                 <span style="color: #87005f;">"acc"</span>
                                 <span style="color: #87005f;">"other"</span>
                                 )))
        (font-lock-add-keywords 'emacs-lisp-mode `((,(concat <span style="color: #87005f;">"\\_&lt;"</span> (regexp-opt special-variables 'paren) <span style="color: #87005f;">"\\_&gt;"</span>)
                                                     1 font-lock-variable-name-face)) 'append)
        (font-lock-add-keywords 'emacs-lisp-mode `((,(concat <span style="color: #87005f;">"(\\s-*"</span> (regexp-opt new-keywords 'paren) <span style="color: #87005f;">"\\_&gt;"</span>)
                                                     1 font-lock-keyword-face)) 'append))
      (--each (buffer-list)
       (<span style="color: #af00ff;">with-current-buffer</span> it
         (<span style="color: #af00ff;">when</span> (and (eq major-mode 'emacs-lisp-mode)
                    (boundp 'font-lock-mode)
                    font-lock-mode)
           (font-lock-refresh-defaults)))))))

(<span style="color: #af00ff;">provide</span> '<span style="color: #008787;">dash</span>)
<span style="color: #af0000;">;;; </span><span style="color: #af0000;">dash.el ends here</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-lisp" id="m_util">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

&lt;&lt;m_util_contents&gt;&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-lisp" id="m_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">!cons</span> (car cdr)
  <span style="color: #87005f;">"Destructive: Set CDR to the cons of CAR and CDR."</span>
  `(setq ,cdr (cons ,car ,cdr)))


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">!cdr</span> (list)
  <span style="color: #87005f;">"Destructive: Set LIST to the cdr of LIST."</span>
  `(setq ,list (cdr ,list)))


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--each</span> (list <span style="color: #008700;">&amp;rest</span> body)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-each</span><span style="color: #87005f;">'."</span>
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">(declare (debug (form body))</span>
  <span style="color: #af0000;">;;          </span><span style="color: #af0000;">(indent 1))</span>
  (<span style="color: #af00ff;">let</span> ((l (make-symbol <span style="color: #87005f;">"list"</span>)))
    `(<span style="color: #af00ff;">let</span> ((,l ,list)
           (it-index 0))
       (<span style="color: #af00ff;">while</span> ,l
         (<span style="color: #af00ff;">let</span> ((it (car ,l)))
           ,@body)
         (setq it-index (1+ it-index))
         (!cdr ,l)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-each</span> (list fn)
  <span style="color: #87005f;">"Call FN with every item in LIST. Return nil, used for side-effects only."</span>
  (--each list (funcall fn it)))


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--map-when</span> (pred rep list)
  <span style="color: #87005f;">"Anaphoric form of `</span><span style="color: #008787;">-map-when</span><span style="color: #87005f;">'."</span>
  <span style="color: #af0000;">;; </span><span style="color: #af0000;">(declare (debug (form form form)))</span>
  (<span style="color: #af00ff;">let</span> ((r (make-symbol <span style="color: #87005f;">"result"</span>)))
    `(<span style="color: #af00ff;">let</span> (,r)
       (--each ,list (!cons (<span style="color: #af00ff;">if</span> ,pred ,rep it) ,r))
       (nreverse ,r))))


(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">-map-when</span> (pred rep list)
  <span style="color: #87005f;">"Return a new list where the elements in LIST that does not match the PRED function</span>
<span style="color: #87005f;">     are unchanged, and where the elements in LIST that do match the PRED function are mapped</span>
<span style="color: #87005f;">     through the REP function.</span>

<span style="color: #87005f;">     Alias: `</span><span style="color: #008787;">-replace-where</span><span style="color: #87005f;">'</span>

<span style="color: #87005f;">     See also: `</span><span style="color: #008787;">-update-at</span><span style="color: #87005f;">'"</span>
  (--map-when (funcall pred it) (funcall rep it) list))


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-&gt;</span> (x <span style="color: #008700;">&amp;optional</span> form <span style="color: #008700;">&amp;rest</span> more)
  <span style="color: #87005f;">"Thread the expr through the forms. Insert X as the second item</span>
<span style="color: #87005f;">in the first form, making a list of it if it is not a list</span>
<span style="color: #87005f;">already. If there are more forms, insert the first form as the</span>
<span style="color: #87005f;">second item in second form, etc."</span>
  (<span style="color: #af00ff;">cond</span>
    ((null form) x)
    ((null more) (<span style="color: #af00ff;">if</span> (listp form)
                     `(,(car form) ,x ,@(cdr form))
                     (list form x)))
    (<span style="color: #5f5f87;">:else</span> `(-&gt; (-&gt; ,x ,form) ,@more))))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(-&gt; 5 1- ODDP)</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">=&gt; (-&gt; (-&gt; 5 1-) ODDP)</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">=&gt; (ODDP (-&gt; 5 1-))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">=&gt; (ODDP (1- 5))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(sb-cltl2:macroexpand-all '(-&gt; 'first (cons 'second) (cons 'third)))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">=&gt; (CONS (CONS 'FIRST 'SECOND) 'THIRD)</span>

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-&gt;&gt;</span> (x <span style="color: #008700;">&amp;optional</span> form <span style="color: #008700;">&amp;rest</span> more)
  <span style="color: #87005f;">"Thread the expr through the forms. Insert X as the last item</span>
<span style="color: #87005f;">in the first form, making a list of it if it is not a list</span>
<span style="color: #87005f;">already. If there are more forms, insert the first form as the</span>
<span style="color: #87005f;">last item in second form, etc."</span>
  (<span style="color: #af00ff;">cond</span>
    ((null form) x)
    ((null more) (<span style="color: #af00ff;">if</span> (listp form)
                     `(,@form ,x)
                     (list form x)))
    (<span style="color: #5f5f87;">:else</span> `(-&gt;&gt; (-&gt;&gt; ,x ,form) ,@more))))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(sb-cltl2:macroexpand-all '(-&gt;&gt; 'first (cons 'second) (cons 'third)))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">=&gt; (CONS 'THIRD (CONS 'SECOND 'FIRST))</span>


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">.&gt;</span> (fn x chain <span style="color: #008700;">&amp;rest</span> more)
  <span style="color: #87005f;">"Chainer for accessors like getf and gethash"</span>
  `(,chain ,x ,@(mapcar #'(<span style="color: #af00ff;">lambda</span> (x) (list fn x)) more)))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(macroexpand-1 '(.&gt; getf y -&gt; :second :third))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">;; =&gt; (-&gt; Y (GETF :SECOND) (GETF :THIRD))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">(sb-cltl2:macroexpand-all '(-&gt; Y (GETF :SECOND) (GETF :THIRD)))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">;; =&gt; (GETF (GETF Y :SECOND) :THIRD)</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(macroexpand-1 '(.&gt; gethash y -&gt;&gt; :second :third))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">;; =&gt; (-&gt;&gt; Y (GETHASH :SECOND) (GETHASH :THIRD))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">(sb-cltl2:macroexpand-all '(-&gt;&gt; Y (GETHASH :SECOND) (GETHASH :THIRD)))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">;; =&gt; (GETHASH :THIRD (GETHASH :SECOND Y))</span>



(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">--&gt;</span> (x form <span style="color: #008700;">&amp;rest</span> more)
  <span style="color: #87005f;">"Thread the expr through the forms. Insert X at the position</span>
<span style="color: #87005f;">signified by the token `</span><span style="color: #008787;">it</span><span style="color: #87005f;">' in the first form. If there are more</span>
<span style="color: #87005f;">forms, insert the first form at the position signified by `</span><span style="color: #008787;">it</span><span style="color: #87005f;">' in</span>
<span style="color: #87005f;">in second form, etc."</span>
  (<span style="color: #af00ff;">if</span> (null more)
      (<span style="color: #af00ff;">if</span> (listp form)
          (--map-when (eq it 'it) x form)
          (list form x))
      `(--&gt; (--&gt; ,x ,form) ,@more)))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(sb-cltl2:macroexpand-all</span>
<span style="color: #af0000;">;;  </span><span style="color: #af0000;">'(--&gt; "test" (list* it '(:a)) reverse (getf it :a)))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">=&gt; (GETF (REVERSE (LIST* "test" '(:A))) :A)</span>


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-some-&gt;</span> (x <span style="color: #008700;">&amp;optional</span> form <span style="color: #008700;">&amp;rest</span> more)
  <span style="color: #87005f;">"When expr is non-nil, thread it through the first form (via `</span><span style="color: #008787;">-&gt;</span><span style="color: #87005f;">'),</span>
<span style="color: #87005f;">     and when that result is non-nil, through the next form, etc."</span>
  (<span style="color: #af00ff;">if</span> (null form) x
      (<span style="color: #af00ff;">let</span> ((result (make-symbol <span style="color: #87005f;">"result"</span>)))
        `(-some-&gt; (-when-let (,result ,x)
                    (-&gt; ,result ,form))
                  ,@more))))


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-some-&gt;&gt;</span> (x <span style="color: #008700;">&amp;optional</span> form <span style="color: #008700;">&amp;rest</span> more)
  <span style="color: #87005f;">"When expr is non-nil, thread it through the first form (via `</span><span style="color: #008787;">-&gt;&gt;</span><span style="color: #87005f;">'),</span>
<span style="color: #87005f;">     and when that result is non-nil, through the next form, etc."</span>
  (<span style="color: #af00ff;">if</span> (null form) x
      (<span style="color: #af00ff;">let</span> ((result (make-symbol <span style="color: #87005f;">"result"</span>)))
        `(-some-&gt;&gt; (-when-let (,result ,x)
                     (-&gt;&gt; ,result ,form))
                   ,@more))))


(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">-some--&gt;</span> (x <span style="color: #008700;">&amp;optional</span> form <span style="color: #008700;">&amp;rest</span> more)
  <span style="color: #87005f;">"When expr in non-nil, thread it through the first form (via `</span><span style="color: #008787;">--&gt;</span><span style="color: #87005f;">'),</span>
<span style="color: #87005f;">     and when that result is non-nil, through the next form, etc."</span>
  (<span style="color: #af00ff;">if</span> (null form) x
      (<span style="color: #af00ff;">let</span> ((result (make-symbol <span style="color: #87005f;">"result"</span>)))
        `(-some--&gt; (-when-let (,result ,x)
                     (--&gt; ,result ,form))
                   ,@more))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Фунциональные утилиты</h3>
<div class="outline-text-3" id="text-8-2">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

&lt;&lt;f_util_contents&gt;&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">maptree-if</span> (predicate transformer tree)
  (<span style="color: #af00ff;">multiple-value-bind</span> (t-tree control)
      (<span style="color: #af00ff;">if</span> (funcall predicate tree)
          (funcall transformer tree)
          (values tree #'mapcar))
    (<span style="color: #af00ff;">if</span> (and (consp t-tree)
             control)
        (funcall control
                 #'(<span style="color: #af00ff;">lambda</span> (x)
                     (maptree-if predicate transformer x))
                 t-tree)
        t-tree)))
</pre>
</div>
</div>

<div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1"><span class="section-number-4">8.2.1</span> Point-free определения:</h4>
<div class="outline-text-4" id="text-8-2-1">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">define</span> (form* form)
  (<span style="color: #af00ff;">etypecase</span> form*
    (symbol (<span style="color: #af00ff;">etypecase</span> form
              <span style="color: #af0000;">;; </span><span style="color: #af0000;">alias for function or macro</span>
              (symbol `(<span style="color: #af00ff;">defmacro</span> ,form* (<span style="color: #008700;">&amp;rest</span> args)
                         `(,',form ,@args)))
              <span style="color: #af0000;">;; </span><span style="color: #af0000;">alias for lambda</span>
              (cons   `(<span style="color: #af00ff;">defun</span> ,form* (<span style="color: #008700;">&amp;rest</span> args)
                         (apply ,form args)))))
    (cons     <span style="color: #af0000;">;; </span><span style="color: #af0000;">scheme-like function definition</span>
     ` (<span style="color: #af00ff;">defun</span> ,(first form*) ,(rest form*)
         ,form))))
</pre>
</div>

<p>
Тут typecase используется до генерации кода - в зависимости от того символы или списки
связываются друг с другом генерируются различные определения. Можно определять
псевдонимы для функций и маросов, псевдоним будет макросом:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(define head car)
(define tail cdr)
(define \\   lambda)
(define $    funcall)
</pre>
</div>

<p>
Можно определить функцию f2, которая является псевдонимом для лямбды, возвращённой
формой (f1 a1):
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(define f2 (f1 a1))
(f2 a2) ~ (apply (f1 a1) a2)
</pre>
</div>

<p>
Простое определение функций в Scheme-стиле, более соответствующее представлению о
редукции форм:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(define (f1 a1) (f2 a2))
(f1 a1) ~ (<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">f1</span> (a1) (f2 a2))
</pre>
</div>

<p>
Также, чтобы определять функции миксующую аргументы с другой функцией, можно ввести
такой макрос:
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">define*</span> (form* form)
  `(<span style="color: #af00ff;">defun</span> ,(first form*) ,(rest form*)
     (,(first form) ,@(rest form) ,@(rest form*))))
</pre>
</div>

<p>
Пример:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(define* (f1 a1) (f2 a2))
(f1 a1) ~ (f2 a2 a1)
</pre>
</div>

<p>
Либо использовать карринг.
</p>
</div>
</div>

<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2"><span class="section-number-4">8.2.2</span> Flip, карринг, композиции:</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
далее f, g, &#x2026; обозначают функции,
a, b, &#x2026; - их аргументы.
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(define (self object) object)
(define (flip f)      (\\ (a b) ($ f b a)))
(define (curry f a)   (\\ (b)   ($ f a b)))
(define (curry* f g)  (\\ (a b) ($ f g a b)))
(define (compose f g) (\\ (a)   ($ f ($ g a))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3"><span class="section-number-4">8.2.3</span> Свёртки и "развёртки":</h4>
<div class="outline-text-4" id="text-8-2-3">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(define (foldl f a list)
    (<span style="color: #af00ff;">typecase</span> list
      (null a)
      (cons (foldl f ($ f a (head list)) (tail list)))))

(define (foldr f a list)
    (<span style="color: #af00ff;">typecase</span> list
      (null a)
      (cons ($ f (head list) (foldr f a (tail list))))))

(define (unfold f i p)
    (<span style="color: #af00ff;">if</span> ($ p i)
        (cons i '())
        (cons i (unfold f ($ f i) p))))

(define fold foldl)
(define my-reduce fold)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-4" class="outline-4">
<h4 id="sec-8-2-4"><span class="section-number-4">8.2.4</span> Отображения и фильтрации:</h4>
<div class="outline-text-4" id="text-8-2-4">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">map &amp; filter</span>
(define (my-map f list) (foldr (\\ (x y) (cons ($ f x) y)) '() list))
(define (filter p list) (foldr (\\ (x y) (<span style="color: #af00ff;">if</span> ($ p x) (cons x y) y)) '() list))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-5" class="outline-4">
<h4 id="sec-8-2-5"><span class="section-number-4">8.2.5</span> Функции для списков на основе карринга и свёрток:</h4>
<div class="outline-text-4" id="text-8-2-5">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">functions for lists</span>
(define (my-list <span style="color: #008700;">&amp;rest</span> objs)         objs)
(define (my-length list)             (fold (\\ (x y) (1+ x)) 0 list))
(define (my-reverse list)            (fold (flip 'cons) '() list))
(define (my-append list <span style="color: #008700;">&amp;rest</span> lists) (fold (flip (curry* 'foldr 'cons)) list lists))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-6" class="outline-4">
<h4 id="sec-8-2-6"><span class="section-number-4">8.2.6</span> Функции для чисел:</h4>
<div class="outline-text-4" id="text-8-2-6">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">functions for numbers</span>
(define zero?                    (curry '<span style="color: #af00ff;">=</span> 0))
(define positive?                (curry '&lt; 0))
(define negative?                (curry '&gt; 0))
(define (odd? number)            (<span style="color: #af00ff;">=</span> (mod number 2) 1))
(define (even? number)           (<span style="color: #af00ff;">=</span> (mod number 2) 0))
(define (my-max a <span style="color: #008700;">&amp;rest</span> numbers) (fold (\\ (y z) (<span style="color: #af00ff;">if</span> (&gt; y z) y z)) a numbers))
(define (my-min a <span style="color: #008700;">&amp;rest</span> numbers) (fold (\\ (y z) (<span style="color: #af00ff;">if</span> (&lt; y z) y z)) a numbers))
(define (summa <span style="color: #008700;">&amp;rest</span> numbers)    (fold '+ 0 numbers))
(define (product <span style="color: #008700;">&amp;rest</span> numbers)  (fold '* 1 numbers))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-7" class="outline-4">
<h4 id="sec-8-2-7"><span class="section-number-4">8.2.7</span> И для булевых чисел:</h4>
<div class="outline-text-4" id="text-8-2-7">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">functions for booleans</span>
(define (my-and <span style="color: #008700;">&amp;rest</span> list)   (fold 'and t list))
(define (my-or <span style="color: #008700;">&amp;rest</span> list)    (fold 'or nil list))
(define (any? p <span style="color: #008700;">&amp;rest</span> list)   (apply 'my-or (my-map p list)))
(define (every? p <span style="color: #008700;">&amp;rest</span> list) (apply 'my-and (my-map p list)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-8" class="outline-4">
<h4 id="sec-8-2-8"><span class="section-number-4">8.2.8</span> Многие другие функции представляются свёртками, например:</h4>
<div class="outline-text-4" id="text-8-2-8">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">member &amp; assoc</span>
(<span style="color: #af00ff;">flet</span> ((helper (p op)
         (\\ (a next) (<span style="color: #af00ff;">if</span> (and (not a) ($ p ($ op next))) next a))))

  (define (my-member object list <span style="color: #008700;">&amp;key</span> (test 'equal))
      (fold (helper (curry test object) 'self) nil list))

  (define (my-assoc object alist <span style="color: #008700;">&amp;key</span> (test 'equal))
      (fold (helper (curry test object) 'car) nil alist)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-9" class="outline-4">
<h4 id="sec-8-2-9"><span class="section-number-4">8.2.9</span> Свёртки для деревьев:</h4>
<div class="outline-text-4" id="text-8-2-9">
<p>
Теперь, собственно, код для деревьев. Нужно заметить, что учитывая весь код для
"абстракций", получается существенно меньше, чем при реализации "в лоб" (как у Грэхама,
например).
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">for (1 . (2 . 3)) trees</span>

(define (my-append a b)
    (append (<span style="color: #af00ff;">if</span> (atom a) (list a) a)
            (<span style="color: #af00ff;">if</span> (atom b) (list b) b)))

(define (fold-tree f g tree)
    (<span style="color: #af00ff;">typecase</span> tree
      (atom ($ f tree))
      (cons ($ g (fold-tree f g (head tree))
               (fold-tree f g (tail tree))))))

(define* (summa/tree tree) (fold-tree 'self '+))
(define* (depth/tree tree) (fold-tree 'one 'max+1))
(define* (flatten tree)    (fold-tree 'self 'my-append))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> Другие утилиты</h3>
<div class="outline-text-3" id="text-8-3">
<div class="org-src-container">

<pre class="src src-lisp" id="f_util_contents">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(defun my-range (n)</span>
<span style="color: #af0000;">;;   </span><span style="color: #af0000;">(let ((i 0))</span>
<span style="color: #af0000;">;;     </span><span style="color: #af0000;">#'(lambda ()</span>
<span style="color: #af0000;">;;         </span><span style="color: #af0000;">(if (&lt; i n) (incf i) nil))))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(let ((f (my-range 3)))</span>
<span style="color: #af0000;">;;   </span><span style="color: #af0000;">(list</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(funcall f)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(funcall f)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(funcall f)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(funcall f)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(funcall f)</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(range 3)</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(defmacro do-closure ((i clos) &amp;body body)</span>
<span style="color: #af0000;">;;   </span><span style="color: #af0000;">(let ((c (gensym)))</span>
<span style="color: #af0000;">;;     </span><span style="color: #af0000;">`(let ((,c ,clos))</span>
<span style="color: #af0000;">;;        </span><span style="color: #af0000;">(loop for ,i = (funcall ,c)</span>
<span style="color: #af0000;">;;           </span><span style="color: #af0000;">while ,i do ,@body))))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(do-closure (i (my-range 100)) (print i))</span>


(<span style="color: #af00ff;">declaim</span> (inline zip))
(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">zip</span> (<span style="color: #008700;">&amp;rest</span> args)
  <span style="color: #87005f;">"</span>
<span style="color: #87005f;">Zips the elements of @arg{args}.</span>
<span style="color: #87005f;">Example:</span>
<span style="color: #87005f;">@lisp</span>
<span style="color: #87005f;">&gt; (zip '(2 3 4) '(a b c) '(j h c s))</span>
<span style="color: #87005f;">=&gt; ((2 A J) (3 B H) (4 C C))</span>
<span style="color: #87005f;">@end lisp</span>
<span style="color: #87005f;">"</span>
  (apply #'map 'list #'list args))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">symstuff</span> (l)
  <span style="color: #87005f;">"From the Common Lisp Cookbook - https://cl-cookbook.sourceforge.net/macros.html</span>
<span style="color: #87005f;">Helper function to (build-symbol)"</span>
  `(concatenate 'string
                ,@(for (x <span style="color: #5f5f87;">:in</span> l)
                       (<span style="color: #af00ff;">cond</span> ((stringp x)
                              `',x)
                             ((atom x)
                              `',(format nil <span style="color: #87005f;">"~a"</span> x))
                             ((eq (car x) '<span style="color: #5f5f87;">:&lt;</span>)
                              `(format nil <span style="color: #87005f;">"~a"</span> ,(cadr x)))
                             ((eq (car x) '<span style="color: #5f5f87;">:++</span>)
                              `(format nil <span style="color: #87005f;">"~a"</span> (incf ,(cadr x))))
                             (t
                              `(format nil <span style="color: #87005f;">"~a"</span> ,x))))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">build-symbol</span> (<span style="color: #008700;">&amp;rest</span> l)
  <span style="color: #87005f;">"From the Common Lisp Cookbook - https://cl-cookbook.sourceforge.net/macros.html"</span>
  (<span style="color: #af00ff;">let</span> ((p (find-if (<span style="color: #af00ff;">lambda</span> (x) (and (consp x) (eq (car x) '<span style="color: #5f5f87;">:package</span>)))
                    l)))
    (<span style="color: #af00ff;">cond</span> (p
           (setq l (remove p l))))
    (<span style="color: #af00ff;">let</span> ((pkg (<span style="color: #af00ff;">cond</span> ((eq (cadr p) 'nil)
                      nil)
                     (t `(find-package ',(cadr p))))))
      (<span style="color: #af00ff;">cond</span> (p
             (<span style="color: #af00ff;">cond</span> (pkg
                    `(values (intern ,(symstuff l) ,pkg)))
                   (t
                    `(make-symbol ,(symstuff l)))))
            (t
             `(values (intern ,(symstuff l))))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">remove-nth</span> (n seq)
  <span style="color: #87005f;">"Remove nth element from sequence"</span>
  (remove-if (constantly t) seq <span style="color: #5f5f87;">:start</span> n <span style="color: #5f5f87;">:count</span> 1))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">make-hash</span> (<span style="color: #008700;">&amp;rest</span> keyvals)
  <span style="color: #87005f;">"Create a hash table given keys and values"</span>
  (plist-hash-table keyvals))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">make-hash*</span> (<span style="color: #008700;">&amp;rest</span> keyvals)
  <span style="color: #87005f;">"Make a hash table given key/value pairs, allowing use of prior key/val pairs in late r definitions"</span>
  (<span style="color: #af00ff;">loop</span> while keyvals
     for k <span style="color: #af00ff;">=</span> (intern (symbol-name (pop keyvals)))
     for v <span style="color: #af00ff;">=</span> (pop keyvals)
     collect `(,k ,v) into letargs
     collect (make-keyword k) into objargs
     collect k into objargs
     finally (<span style="color: #af00ff;">return</span>
               `(<span style="color: #af00ff;">let*</span> (,@letargs)
                  (make-hash ,@objargs)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">maphash2</span> (fn ht)
  <span style="color: #87005f;">"Returns a hash-table with the results of the function of key &amp; value as values"</span>
  (<span style="color: #af00ff;">let</span> ((ht-out (make-hash-table
                 <span style="color: #5f5f87;">:test</span> (hash-table-test ht)
                 <span style="color: #5f5f87;">:size</span> (hash-table-size ht)
                 <span style="color: #5f5f87;">:rehash-size</span> (hash-table-rehash-size ht)
                 <span style="color: #5f5f87;">:rehash-threshold</span> (hash-table-rehash-threshold ht))))
    (maphash #'(<span style="color: #af00ff;">lambda</span> (k v)
                 (setf (gethash k ht-out) (funcall fn k v)))
             ht)
    ht-out))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">maphash-values2</span> (fn ht)
  <span style="color: #87005f;">"Returns a hash-table with the results of the function of value as values"</span>
  (<span style="color: #af00ff;">let</span> ((ht-out (make-hash-table)))
    (maphash #'(<span style="color: #af00ff;">lambda</span> (k v) (setf (gethash k ht-out) (funcall fn v))) ht)
    ht-out))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">swap</span> (pl1 pl2)
  <span style="color: #87005f;">"Macro to swap two places"</span>
  (<span style="color: #af00ff;">let</span> ((temp1-name (gensym)) <span style="color: #af0000;">; don't clobber existing names</span>
        (temp2-name (gensym)))
    `(<span style="color: #af00ff;">let</span> ((,temp1-name ,pl1)
           (,temp2-name ,pl2))
       (setf ,pl1 ,temp2-name)
       (setf ,pl2 ,temp1-name))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">print-hash-key-or-val</span> (kv stream)
  (format stream (<span style="color: #af00ff;">typecase</span> kv
                   (keyword <span style="color: #87005f;">" :~a"</span>)
                   (string <span style="color: #87005f;">" \"~a\""</span>)
                   (symbol <span style="color: #87005f;">" '~a"</span>)
                   (list <span style="color: #87005f;">" '~a"</span>)
                   (t <span style="color: #87005f;">" ~a"</span>)) kv))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">printhash</span> (h <span style="color: #008700;">&amp;optional</span> (stream t))
  <span style="color: #87005f;">"Pretty print a hash table as :KEY VAL on separate lines"</span>
  (format stream <span style="color: #87005f;">"#&lt;HASH-TABLE~{~a~a~^~&amp;~}&gt;"</span>
          (<span style="color: #af00ff;">loop</span> for k being the hash-keys in h using (hash-value v)
             collect (print-hash-key-or-val k nil)
             collect (print-hash-key-or-val v nil))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">lethash</span> (keys h <span style="color: #008700;">&amp;body</span> body)
  <span style="color: #87005f;">"Let form binding hash table entries to let variables names"</span>
  (<span style="color: #af00ff;">let</span> ((ht (gensym)))
    `(<span style="color: #af00ff;">let</span> ((,ht ,h))
       (<span style="color: #af00ff;">let</span> ,(<span style="color: #af00ff;">loop</span> for key in keys
                collect `(,key (gethash ,(make-keyword key) ,ht)))
         ,@body))))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">with-keys</span> (keys h <span style="color: #008700;">&amp;body</span> body)
  <span style="color: #87005f;">"Make keys of hash table available to body for use &amp; changable via setf"</span>
  (<span style="color: #af00ff;">let</span> ((ht (gensym)))
    (<span style="color: #af00ff;">loop</span> for key in keys
       for newbody <span style="color: #af00ff;">=</span> (subst `(gethash ,(make-keyword key) ,ht) key body)
       then (subst `(gethash ,(make-keyword key) ,ht) key newbody)
       finally (<span style="color: #af00ff;">return</span> `(<span style="color: #af00ff;">let</span> ((,ht ,h))
                          ,@newbody)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">linear-interpolation</span> (ys xs x)
  <span style="color: #87005f;">"Linear interpolation: calculate y(x) at x given table of ys and xs. Also returns ind ex of lookup table interval. Works from first x to less than last x."</span>
  (<span style="color: #af00ff;">let*</span> ((i (position x xs <span style="color: #5f5f87;">:test</span> #'&gt;<span style="color: #af00ff;">=</span> <span style="color: #5f5f87;">:from-end</span> t))
         (x0 (elt xs i))
         (x1 (elt xs (1+ i)))
         (y0 (elt ys i))
         (y1 (elt ys (1+ i))))
    (+ y0 (* (- y1 y0) (- x x0) (/ (- x1 x0))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">maptree</span> (f tree)
  <span style="color: #87005f;">"Map a function on the leaves of a tree"</span>
  (<span style="color: #af00ff;">cond</span>
    ((null tree) nil)
    ((atom tree) (funcall f tree))
    (t (cons (maptree f (car tree))
             (maptree f (cdr tree))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">maptreenode</span> (f tree)
  (<span style="color: #af00ff;">cond</span>
    ((null tree) nil)
    ((atom tree) tree)
    (t (<span style="color: #af00ff;">progn</span>
         (funcall f tree)
         (cons (maptreenode f (car tree))
               (maptreenode f (cdr tree)))))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">flat-list-p</span> (param)
  (mapcar #'(<span style="color: #af00ff;">lambda</span> (x) (<span style="color: #af00ff;">unless</span> (atom x) (<span style="color: #af00ff;">return-from</span> flat-list-p nil)))
          param)
  t)

(<span style="color: #af00ff;">defmethod</span> <span style="color: #0000ff;">diff</span> ((l list))
  <span style="color: #87005f;">"Return list of the 1st differences of given list: l(1)-l(0),...,l(n)-l(n-1)"</span>
    (<span style="color: #af00ff;">loop</span> for i below (1- (length l))
       for li in l
       collect (- (elt l (1+ i)) li)))

(<span style="color: #af00ff;">defmethod</span> <span style="color: #0000ff;">diff</span> ((v vector))
  <span style="color: #87005f;">"Return vector of the 1st differences of given vector: v(1)-v(0),...,v(n)-v(n-1)"</span>
  (<span style="color: #af00ff;">let*</span> ((n (length v))
         (v2 (make-array (1- n))))
    (<span style="color: #af00ff;">dotimes</span> (i (1- n))
      (setf (aref v2 i) (- (aref v (1+ i)) (aref v i))))
    v2))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">slot-ref</span> (obj slots)
  <span style="color: #87005f;">"Reference nested objects by a list of successive slot names. For example, (slot-ref  o 'foo 'bar 'baz) should return (slot-value (slot-value (slot-value o 'foo) 'bar) 'baz) "</span>
  (<span style="color: #af00ff;">cond</span>
    ((atom slots) (slot-value obj slots))
    ((null (cdr slots)) (slot-value obj (car slots)))
    (t (slot-ref (slot-value obj (first slots)) (rest slots)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">slot-ref-set</span> (obj slots val)
  <span style="color: #87005f;">"Set nested object slot reference to new value"</span>
  (<span style="color: #af00ff;">cond</span>
    ((atom slots) (setf (slot-value obj slots) val))
    ((null (cdr slots)) (setf (slot-value obj (car slots)) val))
    (t (slot-ref-set (slot-value obj (first slots)) (rest slots) val))))

(<span style="color: #af00ff;">defsetf</span> <span style="color: #0000ff;">slot-ref</span> slot-ref-set)

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">bind-nested-slots</span> (forms obj <span style="color: #008700;">&amp;body</span> body)
  <span style="color: #87005f;">"For each form of (VAR SLOT1 SLOT2 ...) bind VAR to (NESTED-SLOT OBJ SLOT1 SLOT2 ...) "</span>
  `(<span style="color: #af00ff;">let</span> ,(<span style="color: #af00ff;">loop</span> for form in forms
            collect `(,(first form) (slot-ref ,obj ',(rest form))))
     ,@body))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">defpfun</span> (name args pargs <span style="color: #008700;">&amp;body</span> body)
  <span style="color: #87005f;">"Define pandoric function given name, arguments, pandoric arguments,</span>
<span style="color: #87005f;">&amp; body forms."</span>
  `(setf (symbol-function ',name)
         (plambda ,args ,pargs
                  ,@body)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> Утилиты</h3>
<div class="outline-text-3" id="text-8-4">
<div class="org-src-container">

<pre class="src src-lisp" id="utility_file">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*user-agent*</span> <span style="color: #87005f;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0"</span>)

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*cookies*</span>
  (list <span style="color: #87005f;">"portal_tid=1291969547067-10909"</span>
        <span style="color: #87005f;">"__utma=189530924.115785001.1291969547.1297497611.1297512149.377"</span>
        <span style="color: #87005f;">"__utmc=3521885"</span>))

(setf *drakma-default-external-format* <span style="color: #5f5f87;">:utf-8</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">get-headers</span> (referer)
  `(
    (<span style="color: #87005f;">"Accept"</span> . <span style="color: #87005f;">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>)
    (<span style="color: #87005f;">"Accept-Language"</span> . <span style="color: #87005f;">"ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3"</span>)
    (<span style="color: #87005f;">"Accept-Charset"</span> . <span style="color: #87005f;">"utf-8"</span>)
    (<span style="color: #87005f;">"Referer"</span> . ,referer)
    <span style="color: #af0000;">;; </span><span style="color: #af0000;">("Cookie" . ,(format nil "~{~a; ~}" *cookies*))</span>
    (<span style="color: #87005f;">"Cookie"</span> . <span style="color: #87005f;">"ad20c=2; ad17c=2; __utma=48706362.2093251633.1396569814.1413985658.1413990550.145; __utmz=48706362.1413926450.142.18.utmcsr=vk.com|utmccn=(referral)|utmcmd=referral|utmcct=/im; email=avenger-f%40yandex.ru; password=30e3465569cc7433b34d42baeadff18f; PHPSESSID=ms1rrsgjqvm3lhdl5af1aekvv0; __utmc=48706362; __utmb=48706362.5.10.1413990550"</span>)
    ))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">web</span> (to ot)
  (<span style="color: #af00ff;">let</span> ((x-to (append '(format nil) to))
        (x-ot (append '(format nil) ot)))
    `(<span style="color: #af00ff;">let</span> ((r (sb-ext:octets-to-string
               (drakma:http-request ,x-to
                                    <span style="color: #5f5f87;">:user-agent</span> *user-agent*
                                    <span style="color: #5f5f87;">:additional-headers</span> (get-headers ,x-ot)
                                    <span style="color: #5f5f87;">:redirect</span> 10
                                    <span style="color: #5f5f87;">:force-binary</span> t)
               <span style="color: #5f5f87;">:external-format</span> <span style="color: #5f5f87;">:utf-8</span>)))
       r)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">fnd</span> (var pattern)
  `(<span style="color: #af00ff;">multiple-value-bind</span> (all matches)
       (ppcre:scan-to-strings ,pattern ,var)
     (<span style="color: #af00ff;">let</span> ((str (format nil <span style="color: #87005f;">"~a"</span> matches)))
       (subseq str 2 (- (length str) 1)))))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">merge-plists</span> (<span style="color: #008700;">&amp;rest</span> plists)
  <span style="color: #87005f;">"Merge all the given plists into a new plist. The new plist has all</span>
<span style="color: #87005f;">the keys from each plist, with values of keys in later lists</span>
<span style="color: #87005f;">overriding the values of the same keys in earlier plists.</span>
<span style="color: #87005f;">No particular order of key/value pairs is guaranteed.</span>
<span style="color: #87005f;">E.g.:</span>
<span style="color: #87005f;">&gt; (merge-plists '(:a 1 :b 2) '(:a 3 :c 4) '(:d 5))</span>
<span style="color: #87005f;">(:D 5 :C 4 :A 3 :B 2)"</span>
(<span style="color: #af00ff;">let</span> ((result (copy-list (first plists))))
  (<span style="color: #af00ff;">dolist</span> (plist (rest plists))
    (<span style="color: #af00ff;">do*</span> ((prop (first plist) (first plist))
          (value (second plist) (second plist))
          (oldpl plist plist)
          (plist plist (cddr plist)))
         ((not oldpl))
      (setf (getf result prop) value)))
  result))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">eval-always</span>

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">eval-always</span> (<span style="color: #008700;">&amp;body</span> body)
  <span style="color: #87005f;">"Wrap &lt;_:arg body /&gt; in &lt;_:fun eval-when /&gt; with all keys \(compile, load and execute) mentioned"</span>
  `(<span style="color: #af00ff;">eval-when</span> (<span style="color: #5f5f87;">:compile-toplevel</span> <span style="color: #5f5f87;">:load-toplevel</span> <span style="color: #5f5f87;">:execute</span>)
     ,@body))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">#` syntax</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(eval-always</span>
<span style="color: #af0000;">;;   </span><span style="color: #af0000;">(defun |#`-reader| (stream char arg)</span>
<span style="color: #af0000;">;;     </span><span style="color: #af0000;">"Literal syntax for zero/one/two argument lambdas.</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">Use @ as the function's argument, % as the second.</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">Examples:</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">CL-USER&gt; #`(+ 2 @)</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">\(lambda (&amp;optional x y)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(+ 2 x))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">CL-USER&gt;  #`((1+ @) (print @))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">\(lambda (&amp;optional x y)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(1+ x)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(print x))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">CL-USER&gt; #`(+ 1 2)</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">\(lambda (&amp;optional x y)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(+ 1 2))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">CL-USER&gt;  #`(+ @ %)</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">\(lambda (&amp;optional x y)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">(+ x y))</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">"</span>
<span style="color: #af0000;">;;     </span><span style="color: #af0000;">(declare (ignore char arg))</span>
<span style="color: #af0000;">;;     </span><span style="color: #af0000;">(let ((sexp (read stream t nil t))</span>
<span style="color: #af0000;">;;           </span><span style="color: #af0000;">(x (gensym "X"))</span>
<span style="color: #af0000;">;;           </span><span style="color: #af0000;">(y (gensym "Y")))</span>
<span style="color: #af0000;">;;       </span><span style="color: #af0000;">`(lambda (&amp;optional ,x ,y)</span>
<span style="color: #af0000;">;;          </span><span style="color: #af0000;">(declare (ignorable ,x)</span>
<span style="color: #af0000;">;;                   </span><span style="color: #af0000;">(ignorable ,y))</span>
<span style="color: #af0000;">;;          </span><span style="color: #af0000;">,@(subst y '%</span>
<span style="color: #af0000;">;;                   </span><span style="color: #af0000;">(subst x '@</span>
<span style="color: #af0000;">;;                          </span><span style="color: #af0000;">(if (listp (car sexp))</span>
<span style="color: #af0000;">;;                              </span><span style="color: #af0000;">sexp</span>
<span style="color: #af0000;">;;                              </span><span style="color: #af0000;">(list sexp)))))))</span>
<span style="color: #af0000;">;;   </span><span style="color: #af0000;">;; set #`</span>
<span style="color: #af0000;">;;   </span><span style="color: #af0000;">(set-dispatch-macro-character #\# #\` #'|#`-reader|))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">anaphoric</span>

(eval-always
 (<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">if-it</span> (test then <span style="color: #008700;">&amp;optional</span> else)
   <span style="color: #87005f;">"Like IF. IT is bound to TEST."</span>
   `(<span style="color: #af00ff;">let</span> ((it ,test))
      (<span style="color: #af00ff;">if</span> it ,then ,else))))

(eval-always
 (<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">when-it</span> (test <span style="color: #008700;">&amp;body</span> body)
   <span style="color: #87005f;">"Like WHEN. IT is bound to TEST."</span>
   `(<span style="color: #af00ff;">let</span> ((it ,test))
      (<span style="color: #af00ff;">when</span> it
        ,@body))))

(eval-always
 (<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">and-it</span> (<span style="color: #008700;">&amp;rest</span> args)
   <span style="color: #87005f;">"Like AND. IT is bound to the value of the previous AND form."</span>
   (<span style="color: #af00ff;">cond</span> ((null args) t)
         ((null (cdr args)) (car args))
         (t `(<span style="color: #af00ff;">when-it</span> ,(car args) (and-it ,@(cdr args)))))))

(eval-always
 (<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">dowhile-it</span> (test <span style="color: #008700;">&amp;body</span> body)
   <span style="color: #87005f;">"Like DOWHILE. IT is bound to TEST."</span>
   `(<span style="color: #af00ff;">do</span> ((it ,test ,test))
        ((not it))
      ,@body)))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(eval-always</span>
<span style="color: #af0000;">;;  </span><span style="color: #af0000;">(defmacro cond-it (&amp;body body)</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">"Like COND. IT is bound to the passed COND test."</span>
<span style="color: #af0000;">;;    </span><span style="color: #af0000;">`(let (it)</span>
<span style="color: #af0000;">;;       </span><span style="color: #af0000;">(cond</span>
<span style="color: #af0000;">;;         </span><span style="color: #af0000;">,@(mapcar #``((setf it ,(car @)) ,(cadr @))</span>
<span style="color: #af0000;">;;                   </span><span style="color: #af0000;">;; uses the fact, that SETF returns the value set</span>
<span style="color: #af0000;">;;                   </span><span style="color: #af0000;">body)))))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">maybe</span>

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">maybecall</span> (val <span style="color: #008700;">&amp;rest</span> funs)
  `(and-it ,val
           ,@(mapcar (<span style="color: #af00ff;">lambda</span> (fun)
                       `(funcall ,fun it))
                     funs)))

(<span style="color: #af00ff;">defmacro</span> <span style="color: #0000ff;">maybe</span> (form)
  <span style="color: #87005f;">"Return a value, returned by a &lt;_:arg form /&gt; or nil, if &lt;_:class error /&gt; is signalled"</span>
  `(<span style="color: #af00ff;">restart-case</span>
       (<span style="color: #af00ff;">handler-bind</span> ((<span style="color: #ff0000; font-weight: bold;">error</span> #'(<span style="color: #af00ff;">lambda</span> (c)
                                 (<span style="color: #af00ff;">declare</span> (ignore condition))
                                 (invoke-restart 'skip))))
         ,form)
     (skip () nil)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> Глобальные определения</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">

<pre class="src src-lisp" id="globals">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">clear db</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">(drop '("profile" "vacancy"))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> Сущности и автоматы</h3>
<div class="outline-text-3" id="text-8-6">
<p>
Соберем все сущности и автоматы
</p>

<div class="org-src-container">

<pre class="src src-lisp" id="entity_and_automates">(<span style="color: #af00ff;">in-package</span> #<span style="color: #5f5f87;">:moto</span>)
&lt;&lt;gen_automat(<span style="color: #87005f;">"vacancy"</span>,     <span style="color: #87005f;">"&#1074;&#1072;&#1082;&#1072;&#1085;&#1089;&#1080;&#1080;"</span>,  vacancy_flds,      vacancy_state)&gt;&gt;
&lt;&lt;gen_automat(<span style="color: #87005f;">"resume"</span>,      <span style="color: #87005f;">"&#1088;&#1077;&#1079;&#1102;&#1084;&#1077;"</span>,    resume_flds,       vacancy_state)&gt;&gt;
&lt;&lt;gen_automat(<span style="color: #87005f;">"rule"</span>,        <span style="color: #87005f;">"&#1087;&#1088;&#1072;&#1074;&#1080;&#1083;&#1072;"</span>,   rule_flds,         rule_state)&gt;&gt;
&lt;&lt;gen_automat(<span style="color: #87005f;">"srcaccount"</span>,  <span style="color: #87005f;">"&#1072;&#1082;&#1082;&#1072;&#1091;&#1085;&#1090;&#1072;"</span>,  srcaccount_flds,   srcaccount_state)&gt;&gt;
<span style="color: #af0000;">;; </span><span style="color: #af0000;">&#1042;&#1089;&#1087;&#1086;&#1084;&#1086;&#1075;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1099;&#1077; &#1089;&#1091;&#1097;&#1085;&#1086;&#1089;&#1090;&#1080; &#1088;&#1077;&#1079;&#1102;&#1084;&#1077;</span>
&lt;&lt;gen_entity(<span style="color: #87005f;">"education"</span>, <span style="color: #87005f;">"&#1086;&#1089;&#1085;&#1086;&#1074;&#1085;&#1086;&#1075;&#1086; &#1086;&#1073;&#1088;&#1072;&#1079;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103;"</span>, education_flds)&gt;&gt;
&lt;&lt;gen_entity(<span style="color: #87005f;">"lang"</span>, <span style="color: #87005f;">"&#1103;&#1079;&#1099;&#1082;&#1072;"</span>, lang_flds)&gt;&gt;
&lt;&lt;gen_entity(<span style="color: #87005f;">"expirience"</span>, <span style="color: #87005f;">"&#1086;&#1087;&#1099;&#1090;&#1072; &#1088;&#1072;&#1073;&#1086;&#1090;&#1099;"</span>, expirience_flds)&gt;&gt;
&lt;&lt;gen_entity(<span style="color: #87005f;">"skill"</span>, <span style="color: #87005f;">"&#1082;&#1083;&#1102;&#1095;&#1077;&#1074;&#1099;&#1093; &#1085;&#1072;&#1074;&#1099;&#1082;&#1086;&#1074;"</span>, skill_flds)&gt;&gt;
&lt;&lt;gen_entity(<span style="color: #87005f;">"recommendation"</span>, <span style="color: #87005f;">"&#1088;&#1077;&#1082;&#1086;&#1084;&#1077;&#1085;&#1076;&#1072;&#1094;&#1080;&#1080;"</span>, recommendation_flds)&gt;&gt;
&lt;&lt;gen_entity(<span style="color: #87005f;">"portfolio"</span>, <span style="color: #87005f;">"&#1087;&#1086;&#1088;&#1090;&#1092;&#1086;&#1083;&#1080;&#1086;"</span>, portfolio_flds)&gt;&gt;
</pre>
</div>

<p>
Здесь придется повторить тот код, который собирает сущности и автоматы, несмотря на
то, что он есть в doc.org. Это может вызвать проблемы при обновлении в двух местах,
но я пока не нашел адекватного решения этой проблемы
</p>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Crypto</h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">

<pre class="src src-lisp">(ql:quickload <span style="color: #87005f;">"restas"</span>)
(ql:quickload <span style="color: #87005f;">"postmodern"</span>)
(ql:quickload <span style="color: #87005f;">"anaphora"</span>)
(ql:quickload <span style="color: #87005f;">"cl-who"</span>)
(ql:quickload <span style="color: #87005f;">"parenscript"</span>)
(ql:quickload <span style="color: #87005f;">"optima"</span>)
(ql:quickload <span style="color: #87005f;">"fare-quasiquote-extras"</span>)
(ql:quickload <span style="color: #87005f;">"fare-quasiquote-optima"</span>)
(ql:quickload <span style="color: #87005f;">"bit-smasher"</span>)

(load <span style="color: #87005f;">"~/repo/moto/src/package.lisp"</span>)
(load <span style="color: #87005f;">"~/repo/moto/src/mod/hh/m-util.lisp"</span>)

(<span style="color: #af00ff;">in-package</span> <span style="color: #5f5f87;">:moto</span>)
(use-package <span style="color: #5f5f87;">:bit-smasher</span>)

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*msg*</span> <span style="color: #87005f;">"&#1089;&#1083;&#1072;&#1074;&#1072; &#1088;&#1086;&#1073;&#1086;&#1090;&#1072;&#1084;"</span>)
(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*key*</span> <span style="color: #87005f;">"&#1085;&#1072;&#1096;&#1089;&#1091;&#1087;&#1077;&#1088;&#1082;&#1083;&#1102;&#1095;."</span>)

(<span style="color: #af00ff;">defconstant</span> <span style="color: #af5f00;">+size-of-char+</span> 16)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">splitter</span> (size param <span style="color: #008700;">&amp;optional</span> acc)
  <span style="color: #87005f;">"&#1056;&#1072;&#1079;&#1073;&#1080;&#1074;&#1072;&#1077;&#1090; &#1074;&#1093;&#1086;&#1076;&#1085;&#1091;&#1102; &#1087;&#1086;&#1089;&#1083;&#1077;&#1076;&#1086;&#1074;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;&#1089;&#1090;&#1100; =param=</span>
<span style="color: #87005f;">   &#1085;&#1072; &#1087;&#1086;&#1076;&#1087;&#1086;&#1089;&#1083;&#1077;&#1076;&#1086;&#1074;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;&#1089;&#1090;&#1080; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1086;&#1084; =size=.</span>
<span style="color: #87005f;">   &#1045;&#1089;&#1083;&#1080; &#1086;&#1089;&#1090;&#1072;&#1077;&#1090;&#1089;&#1103; &#1093;&#1074;&#1086;&#1089;&#1090;, &#1088;&#1072;&#1079;&#1084;&#1077;&#1088;&#1086;&#1084; &#1084;&#1077;&#1085;&#1100;&#1096;&#1077; size</span>
<span style="color: #87005f;">   - &#1089;&#1080;&#1075;&#1085;&#1072;&#1083;&#1080;&#1079;&#1080;&#1088;&#1091;&#1077;&#1090; &#1086;&#1096;&#1080;&#1073;&#1082;&#1091;"</span>
  (<span style="color: #af00ff;">cond</span> ((&gt;<span style="color: #af00ff;">=</span> (length param) size)
         (splitter size (subseq param size)
                   (append acc
                           (list (subseq param 0 size)))))
        ((<span style="color: #af00ff;">=</span> 0 (length param)) acc)
        (t (<span style="color: #ff0000; font-weight: bold;">error</span> param))))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(splitter 2 "010203040506") ;; =&gt; ("01" "02" "03" "04" "05" "06")</span>


(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">bit-list-&gt;integer</span> (bits)
  (reduce #'(<span style="color: #af00ff;">lambda</span> (first-bit second-bit)
              (+ (ash first-bit 1) second-bit))
          bits))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">integer-&gt;bit-list</span> (int <span style="color: #008700;">&amp;optional</span> acc)
  <span style="color: #87005f;">"&#1055;&#1088;&#1077;&#1086;&#1073;&#1088;&#1072;&#1079;&#1091;&#1077;&#1090; &#1074;&#1093;&#1086;&#1076;&#1085;&#1086;&#1077; &#1095;&#1080;&#1089;&#1083;&#1086; &#1074; &#1089;&#1087;&#1080;&#1089;&#1086;&#1082; &#1073;&#1080;&#1090;&#1086;&#1074;"</span>
  (<span style="color: #af00ff;">cond</span> ((&gt; int 0) (<span style="color: #af00ff;">multiple-value-bind</span> (i r)
                       (truncate int 2)
                     (integer-&gt;bit-list i (push r acc))))
        ((null acc) (push 0 acc))
        (t acc)))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(integer-&gt;bit-list 8) ;; =&gt; (1 0 0 0)</span>

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">string-&gt;bit-list</span> (string)
  (-&gt;&gt; string
       (map 'list #'identity)
       (mapcar #'char-code)
       (mapcar #'integer-&gt;bit-list)
       (mapcar #'(<span style="color: #af00ff;">lambda</span> (x)
                   (append (<span style="color: #af00ff;">loop</span> <span style="color: #5f5f87;">:repeat</span> (- +size-of-char+  (length x)) <span style="color: #5f5f87;">:collect</span> 0)
                           x)))
       (reduce #'append)
       ))

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(string-&gt;bit-list "hi") ;; =&gt; (0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 1)</span>


(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">bit-list-&gt;string</span> (string)
  (coerce
   (-&gt;&gt; string
        (string-&gt;bit-list)
        (splitter +size-of-char+)
        (mapcar #'bit-list-&gt;integer)
        (mapcar #'code-char))
   'string))

(bit-list-&gt;string '(0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 1))


(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*hex-chars*</span> <span style="color: #87005f;">"0123456789ABCDEF"</span>)

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*hex-to-char*</span>
  (<span style="color: #af00ff;">loop</span>
     <span style="color: #5f5f87;">:for</span> char <span style="color: #5f5f87;">:across</span> *hex-chars*
     <span style="color: #5f5f87;">:for</span> idx  <span style="color: #5f5f87;">:to</span> 16
     <span style="color: #5f5f87;">:collect</span> (<span style="color: #af00ff;">let</span> ((x (integer-&gt;bit-list idx)))
                (cons (append (<span style="color: #af00ff;">loop</span> <span style="color: #5f5f87;">:repeat</span> (- 4 (length x)) <span style="color: #5f5f87;">:collect</span> 0)
                              x)
                      char))))

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*char-to-hex*</span>
  (<span style="color: #af00ff;">loop</span> <span style="color: #5f5f87;">:for</span> (idx . char) <span style="color: #5f5f87;">:in</span> *hex-to-char* <span style="color: #5f5f87;">:collect</span> `(,char . ,idx)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">hex-to-char-lookup</span> (lst)
  (cdr (assoc lst *hex-to-char* <span style="color: #5f5f87;">:test</span> #'equal)))

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">char-to-hex-lookup</span> (lst)
  (cdr (assoc lst *char-to-hex* <span style="color: #5f5f87;">:test</span> #'equal)))

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*crypt*</span> (coerce
                       (mapcar #'hex-to-char-lookup
                               (splitter 4 (mapcar #'(<span style="color: #af00ff;">lambda</span> (a b)
                                                       (logxor a b))
                                                   (string-&gt;bit-list *msg*)
                                                   (string-&gt;bit-list *key*))))
                       'string))

(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*decrypt*</span> (coerce
                         (-&gt;&gt; (map 'list #'identity *crypt*)
                              (mapcar #'char-to-hex-lookup)
                              (reduce #'append)
                              (mapcar #'(<span style="color: #af00ff;">lambda</span> (a b)
                                          (logxor a b))
                                      (string-&gt;bit-list *key*))
                              (splitter +size-of-char+)
                              (mapcar #'bit-list-&gt;integer)
                              (mapcar #'code-char))
                         'string))

(<span style="color: #ff0000; font-weight: bold;">assert</span> (equal *msg* *decrypt*))

(ql:quickload <span style="color: #87005f;">"ltk"</span>)
(use-package <span style="color: #5f5f87;">:ltk</span>)
(<span style="color: #af00ff;">defparameter</span> <span style="color: #af5f00;">*msg*</span> <span style="color: #87005f;">"&#1089;&#1083;&#1072;&#1074;&#1072; &#1088;&#1086;&#1073;&#1086;&#1090;&#1072;&#1084;"</span>)

(<span style="color: #af00ff;">defun</span> <span style="color: #0000ff;">my-nbtest</span> ()
  (<span style="color: #af00ff;">with-ltk</span> ()
    (<span style="color: #af00ff;">let*</span> ((nb (make-instance 'notebook <span style="color: #5f5f87;">:width</span> 600 <span style="color: #5f5f87;">:height</span> 400))
           (t1 (make-instance 'text <span style="color: #5f5f87;">:master</span> nb <span style="color: #5f5f87;">:width</span> 40 <span style="color: #5f5f87;">:height</span> 10))
           (t2 (make-instance 'text <span style="color: #5f5f87;">:master</span> nb <span style="color: #5f5f87;">:width</span> 40 <span style="color: #5f5f87;">:height</span> 10))
           (b1 (make-instance 'button <span style="color: #5f5f87;">:master</span> nb <span style="color: #5f5f87;">:text</span> <span style="color: #87005f;">"Encrypt"</span>
                              <span style="color: #5f5f87;">:command</span> (<span style="color: #af00ff;">lambda</span> ()
                                         (setf (text t2)
                                               (coerce
                                                (mapcar #'hex-to-char-lookup
                                                        (splitter 4 (mapcar #'(<span style="color: #af00ff;">lambda</span> (a b)
                                                                                (logxor a b))
                                                                            (string-&gt;bit-list *msg*)
                                                                            (string-&gt;bit-list *key*))))
                                                'string)
                                               <span style="color: #af0000;">;; </span><span style="color: #af0000;">(format nil "the text is:~a~%" (text t1))</span>
                                               ))))
           (b2 (make-instance 'button <span style="color: #5f5f87;">:master</span> nb <span style="color: #5f5f87;">:text</span> <span style="color: #87005f;">"Decrypt"</span>
                              <span style="color: #5f5f87;">:command</span> (<span style="color: #af00ff;">lambda</span> ()
                                         (format t <span style="color: #87005f;">"the index is:~%"</span> )
                                         (finish-output))))
           )
      (pack nb <span style="color: #5f5f87;">:fill</span> <span style="color: #5f5f87;">:both</span> <span style="color: #5f5f87;">:expand</span> t)
      (pack t1 <span style="color: #5f5f87;">:fill</span> <span style="color: #5f5f87;">:both</span> <span style="color: #5f5f87;">:expand</span> t)
      (pack t2 <span style="color: #5f5f87;">:fill</span> <span style="color: #5f5f87;">:both</span> <span style="color: #5f5f87;">:expand</span> t)
      (pack b1 <span style="color: #5f5f87;">:side</span> <span style="color: #5f5f87;">:left</span>)
      (pack b2 <span style="color: #5f5f87;">:side</span> <span style="color: #5f5f87;">:right</span>)
      (append-text t1 *msg*)
      )))

(my-nbtest)

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(defparameter *nb* (make-instance 'notebook :width 600 :height 400))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">(defparameter *z* (make-instance 'text :master *nb* :width 40 :height 10))</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">ttk::notebook .nb  -width 600 -height 400</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">text .nb.t1 -width 40 -height 10</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">text .nb.t2 -width 40 -height 10</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">button .nb.b1 -text "Encrupt" -command {encrypt [.nb.t1 get 1.0 end] $key}</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">button .nb.b2 -text "Decrypt" -command {decrypt}</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">pack .nb -fill both -expand true</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">pack .nb.t1 -fill both -expand true</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">pack .nb.t2 -fill both -expand true</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">pack .nb.b1 -side left</span>
<span style="color: #af0000;">;; </span><span style="color: #af0000;">pack .nb.b2 -side right</span>

<span style="color: #af0000;">;; </span><span style="color: #af0000;">.nb.t1 insert 1.0 "qwertyuiop&#1094;&#1091;&#1072;"</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-tcl"><span style="color: #5f5f87;">puts</span> <span style="color: #87005f;">"zz"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: rigidus</p>
<p class="date">Created: 2017-09-08 Пт 04:52</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode )</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
