#+HTML_HEAD: <!-- -*- fill-column: 92 -*- -->
#+HTML_HEAD: <!-- org-toggle-inline-images -->

#+TITLE: Модуль HeadHunter

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

send_responds for all

* Цель

  Мы все ищем работу на профильных сайтах время от времени. Иногда на это уходит
  значительное время, т.к. мы выполняем множество рутинных действий, которых могли бы
  избежать. Попробуем автоматизировать этот процесс.

* Что это такое?

  Это средство автоматизации процесса поиска работы, выполненное в форме экспертной
  системы. Оно умеет обучаться по ходу взаимодействия со своим пользователем. Обучение
  производится с помощью внесения пользователем правил обработки входящего потока вакансий.

* Как это работает?
** Источник вакансий

   Пусть у нас есть источник вакансий, например, hh.ru. На нем можно сформулировать запрос и
   получить выборку в виде списка тизеров вакансий, каждый из которых ведет на полное
   описание вакансии.

   #+CAPTION: Это источник вакансий
   #+NAME: fig:vacancy_source
   [[./img/warehouse.jpg]]

** Фабрика генераторов вакансий

   Пусть у нас есть фабрика =генераторов функций= назовем его =factory=, которая принимает
   =источник вакансий= и параметры запроса (например: =профессиональную область=, =специализацию=,
   =город=) и возвращает =функцию-генератор в замыкании=.

   #+CAPTION: Фабрика генераторов вакансий
   #+NAME: fig:factory
   [[./img/factory.jpg]]

   Эта функция-генератор при каждом своем вызове вернет одну вакансию или =ложь= если все
   вакансии кончились.

   #+CAPTION: Функция-генератор, произведенная фабрикой
   #+NAME: fig:generator
   [[./img/generator.jpg]]

   Внутри себя эта функция по мере необходимости загружает и разбирает сначала тизеры
   вакансий, а потом и сами вакансии, при этом процесс превращения тизера в вакансию
   (=process-teaser=) вынесен из замыкания, т.к. не зависит от замкнутых переменных.

   #+NAME: factory
   #+BEGIN_SRC lisp :exports code :padline no :comments link
     (in-package #:moto)

     <<make_hh_url>>

     <<hh_get_page>>

     <<hh_parse_vacancy_teasers>>

     <<hh_parse_vacancy>>

     (defmethod process-teaser (current-teaser)
       (aif (hh-parse-vacancy (hh-get-page (format nil "http://spb.hh.ru/vacancy/~A" (getf current-teaser :id))))
            (merge-plists current-teaser it)
            nil))

     (defmethod factory ((vac-src (eql 'hh)) city prof-area &optional spec)
       (let ((url     (make-hh-url city prof-area spec))
             (page    0)
             (teasers nil))
         (alexandria:named-lambda get-vacancy ()
           (labels ((load-next-teasers-page ()
                      ;; (dbg "~~ LOAD (page=~A)" page)
                      (setf teasers (hh-parse-vacancy-teasers (hh-get-page (format nil url page))))
                      (incf page)
                      (when (equal 0 (length teasers))
                        (dbg "~~ FIN")
                        (return-from get-vacancy 'nil)))
                    (get-teaser ()
                      (when (equal 0 (length teasers))
                        (load-next-teasers-page))
                      (let ((current-teaser (car teasers)))
                        (setf teasers (cdr teasers))
                        current-teaser)))
             (tagbody get-new-teaser
                (let ((current-teaser (get-teaser)))
                  (let ((current-vacancy (process-teaser current-teaser)))
                    (if (null current-vacancy)
                        (go get-new-teaser)
                        (return-from get-vacancy current-vacancy)))))))))
   #+END_SRC

   Для работы этому генератору нужно уметь:
   - Собирать URL страницы, где лежат тизеры (краткие описания) вакансий из параметов запроса
     (=make-hh-url=)
   - Скачивать HTML-страницы (=hh-get-page=)
   - Разбирать тизеры из html-кода (=hh-parse-vacancy-teasers=)
   - Обрабатывать разобранные тизеры (=hh-parse-vacancy=), чтобы получить по ним вакансии.
   Но я не буду сейчас на этом останавливаться и опишу потом, в соответствующих разделах.

** Определение правила обработки

   Пусть у нас есть возможность создавать именованные =правила=, которые получают на вход
   список, представляющий собой тизер или вакансию, анализируют его, и выполняют какие-то
   действия. В качестве примера, мы могли бы создать правило, которое добавляет к вакансии
   поле =interesting= если зарплата и язык разработки нас устраивает.

   Правило принимает на вход условие срабатывания и код, который будет выполнен, в случае
   если условие выполняется на обрабатываемой вакансии.

   Примем соглашение, что правило возвращает два значения:
   - первое - вакансию (возможно измененную)
   - второе - указание процессору правил (например, прекратить обработку)

   #+NAME: define_rule
   #+BEGIN_SRC lisp :exports code :padline no :comments link
     (in-package #:moto)

     (defmacro define-rule ((name antecedent) &body consequent)
       `(list
          (defun ,(intern (concatenate 'string (symbol-name name) "-ANTECEDENT")) (vacancy)
            ,antecedent)
          (defun ,(intern (concatenate 'string (symbol-name name) "-CONSEQUENT")) (vacancy)
            (let ((result (progn ,@consequent)))
              (values vacancy result)))))

     ;; expand

     ;; (macroexpand-1 '(define-rule (hi-salary-java (and (> (getf vacancy :salary) 70000)
     ;;                                               (not (contains "Java" (getf vacancy :name)))))
     ;;                  (setf (getf vacancy :interesting) t)
     ;;                  :stop))

     ;; test

     ;; (define-rule (hi-salary-java (and (> (getf vacancy :salary) 70000)
     ;;                                   (not (contains "Java" (getf vacancy :name)))))
     ;;   (setf (getf vacancy :interesting) t)
     ;;   :stop)

     ;; (let ((vacancy '(:name "Python" :salary 80000)))
     ;;   (multiple-value-bind (vacancy-result rule-result)
     ;;       (if (hi-salary-java-antecedent vacancy)
     ;;           (hi-salary-java-consequent vacancy))
     ;;     (print (format nil "vacancy: ~A ||| rule-result: ~A" (bprint vacancy-result) (bprint rule-result)))))

     ;; ->"vacancy: (:INTERESTING T :NAME \"Python\" :SALARY 80000) ||| rule-result: :STOP"
   #+END_SRC

** Процессор правил

   Теперь мы можем создать процессор правил =process=, который применяет к вакансии правила
   поочередно. По сути, это =машина Э.Поста=, а все вместе представляет собой =продукционную
   систему= с прямой цепочкой вывода. Подробнее про продукционные системы [[http://www.ngpedia.ru/id429603p1.html][тут]] и [[http://www.myshared.ru/slide/445840/][тут]].

   #+CAPTION: Продукционная система
   #+NAME: fig:production_system
   [[./img/production_system.gif]]

   Процессор правил обрабатывает следущие особые случаи:
   - Если какое-то из правил возвращает во втором параметре =:stop= - обработка прекращается
     и возвращается текущий обработанный результат
   - Если какое-то из правил возвращает во втором параметре =:renew= - то обработка текущего
     входного результата начинается с самого первого правила.
   По окончании обработки возвращается результирующая вакансия, которая может быть
   модифицирована правилами

   #+BEGIN_SRC ditaa :file ./img/process.png
        +------------------------------------------------------------+
        |     +----------------------------------------+             |
        |     |                                        |             |
        V     V                                        |             |
    +-------------------------------------------+      |             |
    | Текущее правило:                cGRE  {d} |      |             |
    + +------------------+--------------------+ |      |             |
    | |если условие=true | выполнить действие | |      |             |
    | +------------------+--------------------+ |      |             |
    +---+---------------------------------------+      |             |
        |                        +---------------------+----------+  |
        |                        | Сделать текущим первое правило |  |
    +---+---------------------+  +---------------------+----------+  |
    |cPNK{io}                 |                        |             |
    |  правило вернуло RENEW? +------------------------+             |
    +---+---------------------+  Да                                  |
        |                                                            |
    +---+---------------------+                                      |
    |cPNK{io}                 +--+ Да                                |
    |  правило вернуло STOP?  |  |                                   |
    +---+---------------------+  |  +--------------------------------+--+
        |                        |  | Сделать текущим следующее правило |
        |                        |  +--------------------------------+--+
        V                        |                                   |
    +-------------------------+  |                                   |
    |cPNK{io}                 |  |  Да                               |
    |  Есть еще правила?      +--+-----------------------------------+
    +-------------------------+  |
        +------------------------+
        |
        V
   #+END_SRC

   #+results:
   [[file:./img/process.png]]

   #+NAME: process
   #+BEGIN_SRC lisp :exports code :padline no :comments link
     (in-package #:moto)

     (defun process (vacancy rules)
       (let ((vacancy vacancy))
         (tagbody
          renew
            (loop :for rule :in rules :do
               (let ((antecedent (concatenate 'string (symbol-name rule) "-ANTECEDENT"))
                     (consequent (concatenate 'string (symbol-name rule) "-CONSEQUENT")))
                 (if (funcall (intern antecedent) vacancy)
                     (multiple-value-bind (vacancy-result rule-result)
                         (funcall (intern consequent) vacancy)
                       (setf vacancy vacancy-result)
                       (when (equal rule-result :stop)
                         (return-from process vacancy))
                       (when (equal rule-result :renew)
                         (go renew)))))))
         vacancy))
   #+END_SRC

** Декоратор для process-teaser

   Поскольку и вакансии и их тизеры представлены у нас одинаково, мы можем применять правила
   и к тем и к другим. Это позволит отфильтровать некоторые вакансии только анализируя их
   тизеры и не загружать лишнего.

   Для того, чтобы сделать это удобным образом, обернем (:around method) =process-teaser=
   так, чтобы исключить из дальнейшей обрабоки те тизеры, которые нам не нравятся. Например
   те, у которых нет указания зарплаты или она слишком низка. После того, как тизер
   превратиться в вакансию мы применим к ней другой список правил, которые реализуют все
   остальную логику.


   #+BEGIN_SRC ditaa :file ./img/around.png
             +----------------+
             | current_teaser |
             +---+------------+
                 |
                 V
   +------------------------------------------------+
   | [AROUND]                                       |
   |   +-----------------------------------+        |  +-------------------+
   |   | process (current_teaser, rules)   |<-------+--+ rules_for_teasers |
   |   +---+-------------------------------+        |  +-------------------+
   |       | result_teaser                          |
   |   +---+----------------------+                 |
   |   |cPNK{io}                  | Нет             |
   |   |  result_teaser is false? +-------+         |
   |   +---+----------------------+       |         |
   |       | Да             result_teaser |         |
   |       |                        +-----|---------+
   |       |                        |+----+---------------------------+
   |       V                        ||                          cBLU  |
   |   +---+----------+             || process_teaser(current_teaser) |
   |   | Вернуть ложь |             ||                                |
   |   +---+----------+             |+----+---------------------------+
   |       |                        +-----|---------+
   |       |                      vacancy |         |
   |       |  +---------------------------+-+       |  +-------------------+
   |       |  | process (vacancy, rules)    |<------+--+ rules_for_vacancy |
   |       |  +---------------------------+-+       |  +-------------------+
   |       |               result_vacancy |         |
   |       |                              V         |
   |       |  +---------------------------+-+       |
   |       |  |cPNK{io}                     | Нет   |
   |       |  |  result_vacancy is false?   +---+   |
   |       |  +---+-------------------------+   |   |
   |       |   Да |                             V   |
   |       |  +---+----------+  +---------------+-+ |
   |       |  | Вернуть ложь |  | Вернуть vacancy | |
   |       |  +---+----------+  +---------------+-+ |
   |       |      |                             |   |
   |       +------+                     vacancy |   |
   |         ложь |                             |   |
   |              V                             V   |
   +--------------+-----------+-----------------+---+
                              |
                              V
                          +---------+
                          | vacancy |
                          +---------+


   #+END_SRC

   #+results:
   [[file:./img/around.png]]

   #+NAME: process_teaser_around
   #+BEGIN_SRC lisp :exports code :padline no :comments link
     (in-package #:moto)

     <<rules>>

     (defmethod process-teaser :around (current-teaser)
       (aif (process current-teaser (rules-for-teaser))
            (process (call-next-method it) (rules-for-vacancy))
            nil))
   #+END_SRC

** Получение и обработка вакансий правилами

   Теперь мы можем получить генератор, и, вызывая его, забирать вакансии, пока они не
   закончатся. Все вакансии будут корректно обработаны правилами - сначала на этапе получения
   тизеров, а потом на этапе получения вакансий.

   #+NAME: run
   #+BEGIN_SRC lisp :exports code :padline no :comments link
     (in-package #:moto)

     <<define_rule>>

     <<process>>

     <<process_teaser_around>>

     <<factory>>

     <<save_vacancy>>

     <<respond>>

     (defun run ()
       (let ((gen (factory 'hh "spb" "Информационные технологии, интернет, телеком"
                           "Программирование, Разработка")))
         (loop :for i :from 1 :to 100 :do
            ;; (dbg "~A" i)
            (let ((vacancy (funcall gen)))
              (when (null vacancy)
                (return))))))

     ;; (run)
   #+END_SRC

** Составление правил и работа с ними

   Теперь можно удобным и компактным способом добавить все необходимые правила и обеспечить
   методы их обработки

   #+NAME: rules
   #+BEGIN_SRC lisp :exports code :padline no :comments link
     (in-package #:moto)

     <<rules_for_vacancy>>

     <<rules_for_teasers>>

     (defun get-all-rules ()
       (let ((result (make-hash-table :test #'equal)))
         (loop :for var :being :the present-symbols :in (find-package "MOTO")
            :when (or
                   (and (search "CONSEQUENT" (symbol-name var))
                        (fboundp var))
                   (and (search "ANTECEDENT" (symbol-name var))
                        (fboundp var)))
            :collect (let ((key (ppcre:regex-replace "-ANTECEDENT" (symbol-name var) "")))
                       (setf key (ppcre:regex-replace "-CONSEQUENT" key ""))
                       (setf (gethash key result) "")))
         (mapcar #'intern
                 (sort
                  (alexandria:hash-table-keys result)
                  #'(lambda (a b)
                      (string< a b))))))

     (defun clear-all-rules ()
       (loop :for var :being :the present-symbols :in (find-package "MOTO")
          :when (or
                 (and (search "CONSEQUENT" (symbol-name var))
                      (fboundp var))
                 (and (search "ANTECEDENT" (symbol-name var))
                      (fboundp var)))
          :collect (fmakunbound var)))

     (defun rules-for-teaser ()
       (remove-if-not #'(lambda (x)
                          (search "DROP-TEASER-IF" (symbol-name x)))
                      (get-all-rules)))

     (defun rules-for-vacancy ()
       (remove-if #'(lambda (x)
                      (search "DROP-TEASER-IF" (symbol-name x)))
                  (get-all-rules)))
   #+END_SRC

** DONE Правила отсева тизеров

   Какие же правила и действия можно составить для того чтобы отсеять неинтересные тизеры
   вакансий? В основном те, которые не устраивают по зарплате и те, у которых в названиях
   упомянуты неинтересные технологии. К примеру, я не хочу даже смотреть на вакансии у
   которых не указана зарплата или она ниже минимально премлимой

   #+NAME: rules_for_teasers
   #+BEGIN_SRC lisp
     (in-package #:moto)

     <<sugar_for_teaser_rules>>

     (define-drop-teaser-rule (salary-1-no (null (getf vacancy :salary)))
       ;; (dbg "  - no salary")
       )

     (define-drop-teaser-rule (salary-2-low (< (getf vacancy :salary-max) 90000))
       ;; (dbg "  - no salary")
       )


     (define-drop-all-teaser-when-name-contains-rule
         "iOS" "Python" "Django" "IOS" "1C" "1С" "C++" "С++" "Ruby" "Ruby on Rails"
         "Frontend" "Front End" "Front-end" "Go" "Q/A" "QA" "C#" ".NET" ".Net"
         "Unity3D" "Flash" "Java" "Android" "ASP" "Objective-C" "Go" "Delphi"
         "Sharepoint" "Flash" "PL/SQL" "Oracle" "designer")
   #+END_SRC

** Макросы для определения правил отсева тизеров

   Для начала определим макрос, который создает правила отсева тизеров - эти правила
   отличаются тем, что всегда в первом параметре возвращают nil, а во втором - =:stop=

   #+NAME: sugar_for_teaser_rules
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defmacro define-drop-teaser-rule ((name antecedent) &body consequent)
       `(define-rule (,(intern (concatenate 'string "DROP-TEASER-IF-"(symbol-name name))) ,antecedent)
          ;; (dbg "drop teaser:")
          ,@consequent
          (setf vacancy nil)
          :stop))

     ;; expand

     ;; (print
     ;;  (macroexpand-1
     ;;   '(define-drop-teaser-rule (hi-salary-java (and (> (getf vacancy :salary) 70000)
     ;;                                              (not (contains "Java" (getf vacancy :name)))))
     ;;     (print (getf vacancy :name))
     ;;     (print (getf vacancy :salary)))))

     ;; (DEFINE-RULE (DROP-TEASER-IF-HI-SALARY-JAVA
     ;;               (AND (> (GETF VACANCY :SALARY) 70000)
     ;;                    (NOT (CONTAINS "Java" (GETF VACANCY :NAME)))))
     ;;   (PRINT (GETF VACANCY :NAME))
     ;;   (PRINT (GETF VACANCY :SALARY))
     ;;   (SETF VACANCY NIL)
     ;;   :STOP)
   #+END_SRC

   Теперь определим расширение предыдущего макроса, которое создает правило, отсеивающее
   тизер, в случае, если в поле =:name= есть вхождение переданной строки

   #+NAME: sugar_for_teaser_rules
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defmacro define-drop-teaser-by-name-rule (str &body consequent)
       `(define-drop-teaser-rule (,(intern (concatenate 'string "NAME-CONTAINS-" (string-upcase (ppcre:regex-replace-all "\\s+" str "-"))))
                                   (contains (getf vacancy :name) ,str))
          ;; (dbg "  - :name contains ~A" ,str)
          ,@consequent))

     ;; expand

     ;; (print
     ;;  (macroexpand-1
     ;;   '(define-drop-teaser-by-name-rule "Android")))

     ;; (DEFINE-DROP-TEASER-RULE (IF-NAME-CONTAINS-ANDROID
     ;;                           (CONTAINS (GETF VACANCY :NAME) "Android"))
     ;;   (DBG "drop:")
     ;;   (DBG "  name contains ~A" "Android"))

     ;; test

     ;; (define-drop-teaser-by-name-rule "Android")

     ;; ==> (DROP-TEASER-IF-IF-NAME-CONTAINS-ANDROID-ANTECEDENT
     ;;      DROP-TEASER-IF-IF-NAME-CONTAINS-ANDROID-CONSEQUENT)

   #+END_SRC

   Теперь в соответствии с принципом DRY определем макрос, который создаст список правил,
   отсеивающих тизеры по вхождению первой строки в поле =:name=

   #+NAME: sugar_for_teaser_rules
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defmacro define-drop-all-teaser-when-name-contains-rule (&rest names)
       `(list ,@(loop :for name :in names :collect
                   `(define-drop-teaser-by-name-rule ,name))))

     ;; expand
     ;; (macroexpand-1 '(define-drop-all-teaser-when-name-contains-rule "IOS" "1С" "C++"))

     ;; (LIST (DEFINE-DROP-TEASER-BY-NAME-RULE "IOS")
     ;;       (DEFINE-DROP-TEASER-BY-NAME-RULE "1С")
     ;;       (DEFINE-DROP-TEASER-BY-NAME-RULE "C++"))

     ;; test

     ;; (define-drop-all-teaser-when-name-contains-rule "IOS" "1С" "C++"))

     ;; =>
     ;; ((DROP-TEASER-IF-IF-NAME-CONTAINS-IOS-ANTECEDENT
     ;;   DROP-TEASER-IF-IF-NAME-CONTAINS-IOS-CONSEQUENT)
     ;;  (DROP-TEASER-IF-IF-NAME-CONTAINS-1С-ANTECEDENT
     ;;   DROP-TEASER-IF-IF-NAME-CONTAINS-1С-CONSEQUENT)
     ;;  (DROP-TEASER-IF-IF-NAME-CONTAINS-C++-ANTECEDENT
     ;;   DROP-TEASER-IF-IF-NAME-CONTAINS-C++-CONSEQUENT))
   #+END_SRC

** DONE Правила анализа вакансий

   - Я не хочу смотреть на вакансии, в компаниях где я уже работал.
   - Если это уже существующая в базе вакансия и ничего не изменилось - игнорируем и
     останавливаем ее обработку
   - Я хочу присвоить вакансии определенный ранг, в зависимости от з\п
   - Я хочу увеличивать этот ранг за упоминание в тексте описания вакансии моих любимых
     слов: Lisp, Erlang, Closure, Prolog, Haskell, Smalltalk
   - Я хочу особо отметить вакансии, у которых ранг выше [порогового ранга], чтобы
     [отправить отклик]
   - Я хочу занести вакансию в базу.
   - Я хочу вывести вакансию в консоль.

   #+NAME: rules_for_vacancy
   #+BEGIN_SRC lisp
     (in-package #:moto)

     <<sugar_for_vacancy_rules>>

     <<show_vacancy>>

     (define-drop-vacancy-rule (already-worked (contains (getf vacancy :emp-name) "Webdom"))
       ;; (dbg "already worked: ~A" (getf vacancy :emp-name))
       )

     (define-drop-vacancy-rule (already-exists-in-db (not (null (find-vacancy :src-id (getf vacancy :id)))))
       (let ((exists (car (find-vacancy :src-id (getf vacancy :id)))))
         (dbg "already exists: ~A : ~A : ~A" (id exists) (name exists) (emp-name exists))))

     (define-rule (set-rank t)
       (setf (getf vacancy :rank) (getf vacancy :salary)))

     (define-rule (set-rank-up-by-lisp (contains (format nil "~A" (bprint (getf vacancy :descr))) "Lisp"))
       ;; (dbg "up rank by Lisp")
       (setf (getf vacancy :rank) (+ (getf vacancy :rank) 30000)))

     (define-rule (set-rank-up-by-erlang (contains (format nil "~A" (bprint (getf vacancy :descr))) "Erlang"))
       ;; (dbg "up rank by Erlang")
       (setf (getf vacancy :rank) (+ (getf vacancy :rank) 15000)))

     (define-rule (set-rank-up-by-haskell (contains (format nil "~A" (bprint (getf vacancy :descr))) "Haskell"))
       ;; (dbg "up rank by Haskell")
       (setf (getf vacancy :rank) (+ (getf vacancy :rank) 10000)))

     (define-rule (z-print t)
       (show-vacancy vacancy))

     (define-rule (z-save t)
       (save-vacancy vacancy)
       :stop)
   #+END_SRC

** Макросы для определения правил анализа вакансий

   Для начала определим макрос, который создает правила отсева вакансий - эти правила
   отличаются тем, что всегда в первом параметре возвращают nil, а во втором - =:stop=

   #+NAME: sugar_for_vacancy_rules
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defmacro define-drop-vacancy-rule ((name antecedent) &body consequent)
       `(define-rule (,(intern (concatenate 'string "DROP-VACANCY-IF-"(symbol-name name))) ,antecedent)
          (dbg "drop vacancy:")
          ,@consequent
          (setf vacancy nil)
          :stop))

     ;; expand

     ;; (print
     ;;  (macroexpand-1
     ;;   '(define-drop-vacancy-rule (hi-salary-java (and (> (getf vacancy :salary) 70000)
     ;;                                              (not (contains "Java" (getf vacancy :name)))))
     ;;     (print (getf vacancy :name))
     ;;     (print (getf vacancy :salary)))))

     ;; (DEFINE-RULE (DROP-VACANCY-IF-HI-SALARY-JAVA
     ;;               (AND (> (GETF VACANCY :SALARY) 70000)
     ;;                    (NOT (CONTAINS "Java" (GETF VACANCY :NAME)))))
     ;;   (PRINT (GETF VACANCY :NAME))
     ;;   (PRINT (GETF VACANCY :SALARY))
     ;;   (SETF VACANCY NIL)
     ;;   :STOP)
  #+END_SRC

** Построение URL-ов, для скачивания тизеров

   Тизеры вакансий размещаются постранично, по 20 штук на странице, и мы можем собрать все
   страницы, если будем получать страницу за страницей, пока не получим страницу, на которой
   вакансий нет.

   В качестве GET-параметров запросы указываются =специализации= и город. Значения =cluster=
   и =area= не меняются. Поэтому, единственная сложность построения URL - это правильно
   сформировать =специализации=.

   #+NAME: make_hh_url
   #+BEGIN_SRC lisp
     (in-package #:moto)

     <<make_specialization_hh_url_string>>

     (defun make-hh-url (city prof-area &optional specs)
       "http://spb.hh.ru/search/vacancy?text=&specialization=1.221&area=2&items_on_page=100&no_magic=true&page=~A")

     ;; test

     (make-hh-url "spb" "Информационные технологии, интернет, телеком" "Программирование, Разработка")
   #+END_SRC

*** Построение специализаций

    Специализации задаются в формате "1.221", где цифра слева от точки представляет
    профессиональное направление, а справа - собственно специализацию. В интерфейсе
    допустимо выбрать одно направление и несколько специализаций в нем, при этом для каждой
    специализации формируется параметр GET-запроса. Допустимо выбрать только направление,
    без специализаций.

    По этой причине мы должны иметь дерево специализаций и транслятор названий специализаций
    в их номера.

    #+NAME: make_specialization_hh_url_string
    #+BEGIN_SRC lisp
      (in-package #:moto)

      <<prof_areas>>

      (defun make-specialization-hh-url-string (prof-area &optional specs)
        (let ((specialization (assoc prof-area *prof-areas* :test #'equal)))
          (when (null specialization)
            (err 'specialization-not-found))
          (when (stringp specs)
            (setf specs (list specs)))
          (if (null specs)
              (concatenate 'string
                           "&specialization="
                           (cadr specialization))
              (format nil "~{&~A~}"
                      (loop :for spec :in specs :collect
                         (let ((spec (cdr (assoc spec (caddr specialization) :test #'equal))))
                           (when (null spec)
                             (err 'spec-not-found))
                           (concatenate 'string "specialization=" (cadr specialization) "." spec)))))))

      ;; test

      ;; (make-specialization-hh-url-string "Информационные технологии, интернет, телеком")
      ;; (make-specialization-hh-url-string "Информационные технологии, интернет, телеком" '("Программирование, Разработка"))
      ;; (make-specialization-hh-url-string "Информационные технологии, интернет, телеком" "Программирование, Разработка")
      ;; (make-specialization-hh-url-string "Информационные технологии, интернет, телеком"
      ;;                                    '("Программирование, Разработка"
      ;;                                      "Web инженер"
      ;;                                      "Web мастер"
      ;;                                      "Стартапы"
      ;;                                      "Управление проектами"
      ;;                                      "Электронная коммерция"))
    #+END_SRC

    Дерево специализаций будем хранить в глобальном alist-е, т.к. оно никогда не меняется. Я
    не стал заполнять его целиком, ограничившись только профессиональной областью "ИТ". По
    необходимости заполню остальное.

    #+NAME: prof_areas
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defparameter *prof-areas*
        '(("Все профессиональные области" . (""))
          ("Информационные технологии, интернет, телеком"
           . ("1" (("CRM системы" . "536")
                   ("CTO, CIO, Директор по IT" . "3")
                   ("Web инженер" . "9")
                   ("Web мастер" . "10")
                   ("Администратор баз данных" . "420")
                   ("Аналитик" . "25")
                   ("Арт-директор" . "30")
                   ("Банковское ПО" . "395")
                   ("Игровое ПО" . "475")
                   ("Инженер" . "82")
                   ("Интернет" . "89")
                   ("Компьютерная безопасность" . "110")
                   ("Консалтинг, Аутсорсинг" . "113")
                   ("Контент" . "116")
                   ("Маркетинг" . "137")
                   ("Мультимедиа" . "161")
                   ("Начальный уровень, Мало опыта" . "172")
                   ("Оптимизация сайта (SEO)" . "400")
                   ("Передача данных и доступ в интернет" . "203")
                   ("Поддержка, Helpdesk" . "211")
                   ("Программирование, Разработка" . "221")
                   ("Продажи" . "225")
                   ("Продюсер" . "232")
                   ("Развитие бизнеса" . "246")
                   ("Сетевые технологии" . "270")
                   ("Системная интеграция" . "272")
                   ("Системный администратор" . "273")
                   ("Системы автоматизированного проектирования" . "274")
                   ("Системы управления предприятием (ERP)" . "50")
                   ("Сотовые, Беспроводные технологии" . "277")
                   ("Стартапы" . "474")
                   ("Телекоммуникации" . "295")
                   ("Тестирование" . "117")
                   ("Технический писатель" . "296")
                   ("Управление проектами" . "327")
                   ("Электронная коммерция" . "359"))))
          ("Бухгалтерия, управленческий учет, финансы предприятия" . ("2"))
          ("Маркетинг, реклама, PR" . ("3"))
          ("Административный персонал" . ("4"))
          ("Банки, инвестиции, лизинг" . ("5"))
          ("Управление персоналом, тренинги" . ("6"))
          ("Автомобильный бизнес" . ("7"))
          ("Безопасность" . ("8"))
          ("Высший менеджмент" . ("9"))
          ("Добыча сырья" . ("10"))
          ("Искусство, развлечения, масс-медиа" . ("11"))
          ("Консультирование" . ("12"))
          ("Медицина, фармацевтика" . ("13"))
          ("Наука, образование" . ("14"))
          ("Государственная служба, некоммерческие организации" . ("16"))
          ("Продажи" . ("17"))
          ("Производство" . ("18"))
          ("Страхование" . ("19"))
          ("Строительство, недвижимость" . ("20"))
          ("Транспорт, логистика" . ("21"))
          ("Туризм, гостиницы, рестораны" . ("22"))
          ("Юристы" . ("23"))
          ("Спортивные клубы, фитнес, салоны красоты" . ("24"))
          ("Инсталляция и сервис" . ("25"))
          ("Закупки" . ("26"))
          ("Начало карьеры, студенты" . ("15"))
          ("Домашний персонал" . ("27"))
          ("Рабочий персонал" . ("29"))))
    #+END_SRC

** Получение страниц

   Вот так мы можем получать страницы, к примеру те, на который находятся тизеры:

   #+NAME: hh_get_page
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defun hh-get-page (url)
       "Получение страницы"
       (flexi-streams:octets-to-string
        (drakma:http-request url
                             :user-agent "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:34.0) Gecko/20100101 Firefox/34.0"
                             :additional-headers `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
                                                   ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
                                                   ("Accept-Charset" . "utf-8")
                                                   ("Referer" . "http://spb.hh.ru/")
                                                   ("Cookie" . "redirect_host=spb.hh.ru; regions=2; __utma=192485224.1206865564.1390484616.1410378170.1417257232.29; __utmz=192485224.1390484616.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _xsrf=85014f262b894a1e9fc57b4b838e48e8; hhtoken=ES030IVQP52ULPbRqN9DQOcMIR!T; hhuid=x_FxSYWUbySJe1LhHIQxDA--; hhrole=anonymous; GMT=3; display=desktop; unique_banner_user=1418008672.846376826735616")
                                                   ("Cache-Control" . "max-age=0"))
                             :force-binary t)
        :external-format :utf-8))
   #+END_SRC

** Разбор тизеров вакансий

   Чтобы получить вакансии со страниц поисковой выдачи - воспользуемся парсером,
   который переведет полученный html в более удобное лисп-дерево. Используя сопоставление с
   образцом мы раз за разом преобразуем его до тех пор, пока там не остануться только
   интересующие нас данные:
   - название вакансии
   - идентификатор (ссылку)
   - дата размещения
   - название работодателя
   - идентификатор работодателя

   Если в вакансии указана зарплата, мы также получаем
   - Валюту зарплаты (3х-буквенный идентификатор)
   - Сумму
   - Текстовое выражение, содержащее "от" или "от и до"

   Иногда HeadHunter синдицирует вакансии с других платформ, к примеру с CAREER.RU, тогда в
   вакансии может отсутствовать работодатель.

   #+NAME: hh_parse_vacancy_teasers
   #+BEGIN_SRC lisp
     (in-package #:moto)

     <<maptree_transform>>

     <<parse_salary>>

     (defun hh-parse-vacancy-teasers (html)
       "Получение списка вакансий из html"
       (mapcar #'parse-salary
               (mtm (`("div" (("class" "search-result") ("data-qa" "vacancy-serp__results")) ,@rest) rest)
                    (mtm (`("div" (("data-qa" ,_) ("class" ,(or "search-result-item search-result-item_premium  search-result-item_premium"
                                                                "search-result-item search-result-item_standard "
                                                                "search-result-item search-result-item_standard_plus "))) ,@rest)
                           (let ((in (remove-if #'(lambda (x) (or (equal x 'z) (equal x "noindex") (equal x "/noindex"))) rest)))
                             (if (not (equal 1 (length in)))
                                 (progn (print in)
                                        (err "parsing failed, data printed"))
                                 (car in))))

                         (mtm (`("a" (("href" ,_) ("target" "_blank") ("class" "search-result-item__label search-result-item__label_discard")
                                      ("data-qa" "vacancy-serp__vacancy_rejected")) "Вам отказали") 'Z)
                              (mtm (`("a" (("href" ,_) ("target" "_blank") ("class" "search-result-item__label search-result-item__label_discard")
                                           ("data-qa" "vacancy-serp__vacancy_rejected")) "Вам отказали") 'Z)
                                   (mtm (`("a" (("title" "Премия HRBrand") ("href" ,_) ("rel" "nofollow")
                                                ("class" ,_)
                                                ("data-qa" ,_)) " ") 'Z)
                                        (mtm (`("div" (("class" "search-result-item__image")) ,_) 'Z)
                                             (mtm (`("script" (("data-name" "HH/VacancyResponseTrigger") ("data-params" ""))) 'Z)
                                                  (mtm (`("a" (("href" ,_) ("target" "_blank") ("class" ,_)
                                                               ("data-qa" "vacancy-serp__vacancy_responded")) "Вы откликнулись") 'Z)
                                                       (mtm (`("div" (("class" "search-result-item__star")) ,@_) 'Z)
                                                            (mtm (`("div" (("class" "search-result-item__description")) ,@rest)
                                                                   (loop :for item :in rest :when (consp item) :append item))
                                                                 (mtm (`("div" (("class" "search-result-item__head"))
                                                                               ("a" (("class" ,(or "search-result-item__name search-result-item__name_standard"
                                                                                                   "search-result-item__name search-result-item__name_standard_plus"
                                                                                                   "search-result-item__name search-result-item__name_premium"))
                                                                                     ("data-qa" "vacancy-serp__vacancy-title") ("href" ,id) ("target" "_blank")) ,name))
                                                                        (list :id (parse-integer (car (last (split-sequence:split-sequence #\/ id)))) :name name))
                                                                      (mtm (`("div" (("class" "b-vacancy-list-salary") ("data-qa" "vacancy-serp__vacancy-compensation"))
                                                                                    ("meta" (("itemprop" "salaryCurrency") ("content" ,currency)))
                                                                                    ("meta" (("itemprop" "baseSalary") ("content" ,salary))) ,salary-text)
                                                                             (list :currency currency :salary (parse-integer salary) :salary-text salary-text))
                                                                           (mtm (`("div" (("class" "search-result-item__company")) ,emp-name)
                                                                                  (list :emp-name emp-name))
                                                                                (mtm (`("div" (("class" "search-result-item__company"))
                                                                                              ("a" (("href" ,emp-id)
                                                                                                    ("class" "search-result-item__company-link")
                                                                                                    ("data-qa" "vacancy-serp__vacancy-employer"))
                                                                                                   ,emp-name))
                                                                                       (list :emp-id (parse-integer (car (last (split-sequence:split-sequence #\/ emp-id))) :junk-allowed t)
                                                                                             :emp-name emp-name))
                                                                                     (mtm (`("div" (("class" "search-result-item__info")) ,@rest)
                                                                                            (loop :for item :in rest :when (consp item) :append item))
                                                                                          (mtm (`("span" (("class" "searchresult__address")
                                                                                                          ("data-qa" "vacancy-serp__vacancy-address")) ,city ,@rest)
                                                                                                 (let ((metro (loop :for item in rest :do
                                                                                                                 (when (and (consp item) (equal :metro (car item)))
                                                                                                                   (return (cadr item))))))
                                                                                                   (list :city city :metro metro)))
                                                                                               (mtm (`("span" (("class" "metro-station"))
                                                                                                              ("span" (("class" "metro-point") ("style" ,_))) ,metro)
                                                                                                      (list :metro metro))
                                                                                                    (mtm (`("span" (("class" "b-vacancy-list-date")
                                                                                                                    ("data-qa" "vacancy-serp__vacancy-date")) ,date)
                                                                                                           (list :date date))
                                                                                                         (mtm (`("span"
                                                                                                                 (("class" "vacancy-list-platform")
                                                                                                                  ("data-qa" "vacancy-serp__vacancy_career"))
                                                                                                                 "  •  " ("span" (("class" "vacancy-list-platform__name"))
                                                                                                                                 "CAREER.RU"))
                                                                                                                (list :platform 'career.ru))
                                                                                                              (block subtree-extract
                                                                                                                (mtm (`("div"
                                                                                                                        (("class" "search-result")
                                                                                                                         ("data-qa" "vacancy-serp__results"))
                                                                                                                        ,@rest)
                                                                                                                       (return-from subtree-extract rest))
                                                                                                                     (html5-parser:node-to-xmls
                                                                                                                      (html5-parser:parse-html5-fragment html)))))))))))))))))))))))))

     ;; (hh-parse-vacancy-teasers
     ;;  (hh-get-page "http://spb.hh.ru/search/vacancy?text=&specialization=1&area=2&salary=&currency_code=RUR&only_with_salary=true&experience=doesNotMatter&order_by=salary_desc&search_period=30&items_on_page=100&no_magic=true"))
   #+END_SRC

*** Трансформация дерева

    #+NAME: maptree_transform
    #+BEGIN_SRC lisp
     (in-package #:moto)

     ;; Это аналог maptree-if, но здесь одна функция и ищет и трансформирует узел дерева
     (defun maptree (predicate-transformer tree)
       (multiple-value-bind (t-tree control)
           (aif (funcall predicate-transformer tree)
                it
                (values tree #'mapcar))
         (if (and (consp t-tree)
                  control)
             (funcall control
                      #'(lambda (x)
                          (maptree predicate-transformer x))
                      t-tree)
             t-tree)))

     ;; maptree-transformer - синтаксический сахар для maptree
     (defmacro mtm (transformer tree)
       (let ((lambda-param (gensym)))
         `(maptree #'(lambda (,lambda-param)
                       (values (match ,lambda-param ,transformer)
                               #'mapcar))
                   ,tree)))
    #+END_SRC

*** Определение минимальной и максимальной зарплаты

    #+NAME: parse_salary
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun parse-salary (vacancy)
        (let ((currency (getf vacancy :CURRENCY))
              (salary-text (ppcre:regex-replace-all " " (getf vacancy :salary-text) ""))
              (salary-min nil)
              (salary-max nil))
          (cond ((equal currency "RUR")
                 (setf salary-text (ppcre:regex-replace-all " руб." salary-text "")))
                ((equal currency "USD")
                 (setf salary-text (ppcre:regex-replace-all " USD" salary-text "")))
                ((equal currency "EUR")
                 (setf salary-text (ppcre:regex-replace-all " EUR" salary-text "")))
                ((equal currency nil)
                 'nil)
                (t (progn
                     (print (getf vacancy :currency))
                     (err 'unk-currency))))
          (cond ((search "от " salary-text)
                 (setf salary-min (parse-integer (ppcre:regex-replace-all "от " salary-text ""))))
                ((search "до " salary-text)
                 (setf salary-max (parse-integer (ppcre:regex-replace-all "до " salary-text ""))))
                ((search "–" salary-text)
                 (let ((splt (ppcre:split "–" salary-text)))
                   (setf salary-min (parse-integer (car splt)))
                   (setf salary-max (parse-integer (cadr splt))))))
          (when (null salary-min)
            (setf salary-min salary-max))
          (when (null salary-max)
            (setf salary-max salary-min))
          (setf (getf vacancy :salary-min) salary-min)
          (setf (getf vacancy :salary-max) salary-max)
          vacancy))

      ;; (hh-parse-vacancy-teasers
      ;;  (hh-get-page "http://spb.hh.ru/search/vacancy?text=&specialization=1&area=2&salary=&currency_code=RUR&only_with_salary=true&experience=doesNotMatter&order_by=salary_desc&search_period=30&items_on_page=100&no_magic=true"))
    #+END_SRC

** Разбор вакансий

   Теперь, можно написать функцию, которая трансформирует описание, очищая его от всего
   лишнего:

   #+NAME: transform_description
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defun transform-description (tree-descr)
       (labels ((rem-z (tree)
                  (cond ((consp tree)
                         (cons (if (equal (car tree) 'z)
                                   (rem-z (cdr tree))
                                   (rem-z (car tree)))
                               (rem-z (remove-if #'(lambda (x) (equal x 'z))
                                                 (cdr tree)))))
                        (t tree)))
                (rem-nil (tree)
                  (cond ((consp tree) (cons (rem-nil (car tree))
                                            (rem-nil (remove-if #'(lambda (x) (or (equal x " ")
                                                                                  (equal x NIL)))
                                                                (cdr tree)))))
                        (t tree))))
         (rem-z
          (mtm (`("p" ,@in) in)
               (mtm (`("li" ,@in) `(:l ,in))
                    (mtm (`("ul" ,@in) `(:u ,in))
                         (mtm (`("li" ,in) `(:l ,in))
                              (mtm (`("p" ,in) in)
                                   (mtm (`("strong" ,in) `(:b ,in))
                                        (mtm (`("em" ,in) `(:b ,in))
                                             (mtm (`("br") 'Z)
                                                  (rem-nil tree-descr))))))))))))

     ;; (print
     ;;  (hh-parse-vacancy (hh-get-page "http://spb.hh.ru/vacancy/12586420")))
   #+END_SRC

   И, наконец, применим все что мы подготовили, чтобы разобрать вакансию:

   #+NAME: hh_parse_vacancy
   #+BEGIN_SRC lisp
     (in-package #:moto)

     <<transform_description>>

     (defun hh-parse-vacancy (html)
       (let* ((tree (html5-parser:node-to-xmls (html5-parser:parse-html5-fragment html))))
         (append (block header-extract
                   (mtm (`("div" (("class" "b-vacancy-custom g-round")) ("meta" (("itemprop" "title") ("content" ,_)))
                                 ("h1" (("class" "title b-vacancy-title")) ,name ,@archive) ,@rest)
                          (return-from header-extract
                            (append (list :name name :archive (if archive t nil))
                                    (block emp-block (mtm (`("div" (("class" "companyname")) ("a" (("itemprop" "hiringOrganization") ("href" ,emp-lnk)) ,emp-name))
                                                            (return-from emp-block
                                                              (list :emp-id (parse-integer (car (last (split-sequence:split-sequence #\/ emp-lnk))) :junk-allowed t)
                                                                    :emp-name emp-name))) rest)))))
                        tree))
                 (let ((salary-result (block salary-extract
                                        (mtm (`("div" (("class" "l-paddings"))
                                                      ("meta" (("itemprop" "salaryCurrency") ("content" ,currency)))
                                                      ("meta" (("itemprop" "baseSalary") ("content" ,base-salary)))
                                                      ,salary-text)
                                               (return-from salary-extract (list :currency currency :base-salary (parse-integer base-salary) :salary-text salary-text)))
                                             tree))))
                   (if (equal 6 (length salary-result))
                       salary-result
                       (list :currency nil :base-salary nil :salary-text nil)))
                 (let ((city-result (block city-extract (mtm (`("td" (("class" "l-content-colum-2 b-v-info-content")) ("div" (("class" "l-paddings")) ,city))
                                                               (return-from city-extract (list :city city))) tree))))
                   (if (equal 2 (length city-result)) city-result (list :city nil)))
                 (let ((exp-result (block exp-extract (mtm (`("td" (("class" "l-content-colum-3 b-v-info-content"))
                                                                   ("div" (("class" "l-paddings") ("itemprop" "experienceRequirements")) ,exp))
                                                             (return-from exp-extract (list :exp exp))) tree))))
                   (if (equal 2 (length exp-result)) exp-result (list :exp nil)))
                 (block descr-extract
                   (mtm (`("div" (("class" "b-vacancy-desc-wrapper") ("itemprop" "description")) ,@descr)
                          (return-from descr-extract (list :descr (transform-description descr)))) tree)))))

     ;; (print
     ;;  (hh-parse-vacancy (hh-get-page "http://spb.hh.ru/vacancy/12561525")))

     ;; (print
     ;;  (hh-parse-vacancy (hh-get-page "http://spb.hh.ru/vacancy/12581768")))
   #+END_SRC

** Сохранение вакансии и ее структура данных

   Опишем структуру данных вакансии:

   #+CAPTION: Данные вакансии
   #+NAME: vacancy_flds
   | field name  | field type           | note                                            |
   |-------------+----------------------+-------------------------------------------------|
   | id          | serial               | идентификатор                                   |
   | src-id      | integer              | идентификатор вакансии в источнике              |
   | archive     | boolean              | призак, что вакансия в архиве                   |
   | name        | varchar              | название вакансии                               |
   | currency    | (or db-null varchar) | валюта зарплаты                                 |
   | base-salary | (or db-null integer) | размер компенсации в тизере                     |
   | salary      | (or db-null integer) | размер компенсации                              |
   | salary-text | (or db-null varchar) | размер компенсации                              |
   | salary-max  | (or db-null integer) | максимальный уровень зарплаты                   |
   | salary-min  | (or db-null integer) | минимальный уровень зарплаты                    |
   | emp-id      | (or db-null integer) | идентификатор работодателя на удаленном ресурсе |
   | emp-name    | varchar              | имя работодателя на удаленном ресурсе           |
   | city        | varchar              | город                                           |
   | metro       | varchar              | метро                                           |
   | experience  | varchar              | требуемый опыт работы                           |
   | date        | varchar              | дата опубликования в источнике                  |
   | descr       | varchar              | описание вакансии                               |
   | notes       | (or db-null varchar) | заметки по вакансии                             |
   | response    | (or db-null varchar) | текст отклика на вакансию                       |

   Напишем процедуру сохранения вакансии в базу данных

   #+NAME: save_vacancy
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defparameter *saved-vacancy* nil)

     (defmethod save-vacancy (vacancy)
       (setf *saved-vacancy*
             (append *saved-vacancy*
                     (list (make-vacancy
                            :src-id (getf vacancy :id)
                            :name (getf vacancy :name)
                            :currency (getf vacancy :currency)
                            :salary (aif (getf vacancy :salary) it 0)
                            :base-salary (aif (getf vacancy :base-salary) it 0)
                            :salary-text (getf vacancy :salary-text)
                            :salary-max (getf vacancy :salary-max)
                            :salary-min (getf vacancy :salary-min)
                            :emp-id (getf vacancy :emp-id)
                            :emp-name (getf vacancy :emp-name)
                            :city (getf vacancy :city)
                            :metro (getf vacancy :metro)
                            :experience (getf vacancy :exp)
                            :archive (getf vacancy :archive)
                            :date (getf vacancy :date)
                            :state ":UNSORT"
                            :descr (bprint (show-descr (getf vacancy :descr)))
                            :notes ""
                            :response "Здравствуйте, я подхожу под ваши требования. Когда можно договориться о собеседовании? Михаил 8(911)286-92-90")))))
   #+END_SRC

** Состояния вакансий

   После загрузки, вакансия получает статус =unsort=

   После сортировки пользователем ваканисия может принять один из статусов: =unsort=,
   =interesting= или =uninteresting=

   Пользователь, работая с этими интересными вакансиями, отслеживает их состояния, выполняя
   действия, переводящие вакансию из одного состояния в другое: когда пользователь
   отправляет отзыв  вакансия становится =responded=.

   #+CAPTION: Состояния конечного автомата вакансии
   #+NAME: vacancy_state
   | action             | from          | to            |
   |--------------------+---------------+---------------|
   | set-uninteresting  | unsort        | uninteresting |
   | set-interesting    | unsort        | interesting   |
   | loop-interesting   | interesting   | interesting   |
   | loop-uninteresting | uninteresting | uninteresting |
   | respond            | interesting   | responded     |

   Теперь мы можем полностью описать поведение вакансии как конечный автомат:

   #+NAME: vacancy_state_graph
   #+BEGIN_SRC emacs-lisp :var table=vacancy_state :results output
     (mapcar #'(lambda (x)
                 (princ (format "%s -> %s [label =\"%s\"];\n"
                                (second x) (third x) (first x))))
             table)
   #+END_SRC

   #+BEGIN_SRC dot :file img/vacancy-state.png :var input=vacancy_state_graph :exports results
     digraph G {
       rankdir = LR;
       $input
     }
   #+END_SRC

   #+results:
   [[file:img/vacancy-state.png]]

   #+NAME: hh_fn_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defun teaser-rejection ()
       "teaser-rejection")

     (defun rejection-favorite ()
       "rejection-favorite")

     (defun set-interesting ()
       "set-interesting")

     (defun loop-interesting ()
       "loop-interesting")

     (defun loop-uninteresting ()
       "loop-uninteresting")
   #+END_SRC

** Печать вакансий

   Пока у нас нет веб-интерфейса мы будем выводить вакансии в консоль

   #+NAME: show_vacancy
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defmethod show-vacancy (vacancy)
       (format t "~%")
       (format t "~%~A :~A: ~A [~A]"
            (getf vacancy :salary-text)
            (getf vacancy :currency)
            (getf vacancy :name)
            (getf vacancy :id))
       (format t "~%~A" (getf vacancy :emp-name))
       (format t "~A" (show-descr (getf vacancy :descr))))

     (defun show-descr (tree)
       (let ((output (make-string-output-stream))
             (indent 2)
             (prefix ""))
         (labels ((out (format tree)
                    (format output "~A~A" (make-string indent :initial-element #\Space)
                            (format nil format tree)))
                  (rec (tree)
                    (cond ((consp tree) (cond ((and (equal 2 (length tree))
                                                    (equal :L (car tree))
                                                    (stringp (cadr tree))) (prog1 nil
                                                                             (format output "~A-> ~A~%" prefix (cadr tree))))
                                              ((equal :U (car tree)) (prog1 nil
                                                                       (setf prefix (concatenate 'string (make-string indent :initial-element #\Space) prefix))
                                                                       (rec (cdr tree))
                                                                       (setf prefix (subseq prefix indent))))
                                              ((and (equal 2 (length tree))
                                                    (equal :B (car tree))
                                                    (stringp (cadr tree))) (format output "~A[~A]~%" prefix (cadr tree)))
                                              (t (cons (rec (car tree))
                                                       (rec (cdr tree))))))
                          (t (cond ((stringp tree) (format output "~A~A~%" prefix tree)))))))
           (rec tree))
         (get-output-stream-string output)))
   #+END_SRC

** Отправка отклика

   #+NAME: respond
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defun make-additional-headers (referer cookies)
         `(("Accept"           . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
           ("Accept-Language"  . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
           ("Accept-Charset"   . "utf-8")
           ("Referer"          . ,referer)
           ("Cache-Control"    . "no-cache")
           ("Cookie"           . ,(format nil "~{~{~A=~A~}~^; ~}" cookies))))

     (defun respond (vacancy-id resume-id letter)
       (let* ((hhtoken     "ES030IVQP52ULPbRqN9DQOcMIR!T")
              (hhuid       "x_FxSYWUbySJe1LhHIQxDA--")
              (xsrf        "ed689ea1ff02a3074c848b69225e3c78")
              (hhrole      "applicant")
              (crypted-id  "2B9E046016B13C9E701CAC5A276D51C8A5471C6F722104504734B32F0D03E9F8")
              (cookie-jar (make-instance 'drakma:cookie-jar))
              (html (flexi-streams:octets-to-string
                     (drakma:http-request
                      (format nil "http://spb.hh.ru/vacancy/~A" vacancy-id)
                      :user-agent "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:34.0) Gecko/20100101 Firefox/34.0"
                      :additional-headers (make-additional-headers "http://spb.hh.ru/"
                                                                   `(("redirect_host"       "spb.hh.ru")  ("regions"             "2")        ("_xsrf"               ,xsrf)
                                                                     ("hhtoken"             ,hhtoken)     ("hhuid"               ,hhuid)     ("hhrole"              ,hhrole)
                                                                     ("GMT"                 "3")          ("display"             "desktop")))
                      :cookie-jar cookie-jar :force-binary t)
                     :external-format :utf-8))
              (cookie-data (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
                              (list (intern (string-upcase (drakma:cookie-name cookie)) :keyword) (drakma:cookie-value cookie))))
              (unique-banner-user (getf cookie-data :unique_banner_user)))
         (assert (equal crypted-id (getf cookie-data :crypted_id)))
         (assert (equal "applicant" (getf cookie-data :hhrole)))
         (assert (equal xsrf (getf cookie-data :_xsrf)))
         (let* ((tree (html5-parser:node-to-xmls (html5-parser:parse-html5-fragment html)))
                (name (block namer (mtm (`("div" (("class" "navi-item__switcher HH-Navi-MenuItems-Switcher") ("data-qa" "mainmenu_normalUserName"))
                                                 ,name ("span" (("class" "navi-item__post"))))
                                          (return-from namer name))
                                        tree))))
           (assert (equal "Михаил Михайлович Глухов" name))
           (sleep 1)
           (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
             (flexi-streams:octets-to-string
              (drakma:http-request
               "http://spb.hh.ru/applicant/vacancy_response/popup"
               :user-agent "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:34.0) Gecko/20100101 Firefox/34.0"
               :method :post
               :content (format nil "~{~A~^&~}"
                                (mapcar #'(lambda (x)
                                            (format nil "~A=~A" (car x) (cdr x)))
                                        `(("vacancy_id" . ,(format nil "~A" vacancy-id))
                                          ("resume_id" . ,(format nil "~A" resume-id))
                                          ("letter" . ,(drakma:url-encode letter :utf-8))
                                          ("_xsrf" . ,xsrf)
                                          ("ignore_postponed" . "true"))))
               :content-type "application/x-www-form-urlencoded; charset=UTF-8"
               :additional-headers `(("Accept"           . "*/*")
                                     ("Accept-Language"  . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
                                     ("Accept-Encoding"  . "gzip, deflate")
                                     ("X-Xsrftoken"      . ,xsrf)
                                     ("X-Requested-With" . "XMLHttpRequest")
                                     ("Referer"          . ,(format nil "http://spb.hh.ru/vacancy/~A" vacancy-id))
                                     ("Cookie"           . ,(format nil "~{~A~^;~}"
                                                                    (mapcar #'(lambda (x)
                                                                                (format nil "~A=~A" (car x) (cdr x)))
                                                                            `(("redirect_host" . "vladivostok.hh.ru")
                                                                              ("regions" . "2")
                                                                              ("__utma" . "192485224.1206865564.1390484616.1421799450.1421859024.49")
                                                                              ("__utmz" . "192485224.1390484616.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none)")
                                                                              ("hipsterShown" . "true")
                                                                              ("hhref" . "")
                                                                              ("vishnu1.userid" . "2B9E046016B13C9E701CAC5A276D51C8A5471C6F722104504734B32F0D03E9F8")
                                                                              ("lt-vc" . "11")
                                                                              ("hhtoken" . ,hhtoken)
                                                                              ("hhuid" . ,hhuid)
                                                                              ("hhrole" . ,hhrole)
                                                                              ("GMT" . "3")
                                                                              ("display" . "desktop")
                                                                              ("_xsrf" . ,xsrf)
                                                                              ("JSESSIONID" . "1i5cpqbtgjgh7ztfwncgixv8c")
                                                                              ("lrp" . "\"http://spb.hh.ru/\"")
                                                                              ("lrr" . "true")
                                                                              ("crypted_id" . ,crypted-id)
                                                                              ("lt-tl" . "8xmy,rn2r,21i1,6gix")
                                                                              ("lt-on-site-time" . "1421859023")
                                                                              ("_xsrf" . "ed689ea1ff02a3074c848b69225e3c78")
                                                                              ("crypted_id" . ,crypted-id)
                                                                              ("unique_banner_user" . ,unique-banner-user)
                                                                              ("__utmb" . "192485224.39.10.1421859024")
                                                                              ("__utmc" . "192485224")
                                                                              ("lt-8xmy" . "46005334")
                                                                              ("lt-rn2r" . "46005334")
                                                                              ("lt-21i1" . "46005334")
                                                                              ("__utmt_vishnu1" . "1")
                                                                              ("lt-6gix" . "46005334")))))
                                     ("Cache-Control" . "no-cache"))
               :cookie-jar cookie-jar
               :force-binary t)
              :external-format :utf-8)))))

     ;; (let ((respond (respond 12646549 7628220 "тест")))
     ;;   (print respond))

     ;; (setf drakma:*header-stream* *standard-output*)
   #+END_SRC

* Interface

  Соберем веб-интерфейс:

  #+NAME: iface
  #+BEGIN_SRC lisp :tangle src/mod/hh/iface.lisp :noweb tangle :padline no :comments link
    ;;;; iface.lisp

    (in-package #:moto)

    ;; Страницы
    <<iface_contents>>
  #+END_SRC

** Главная страница модуля

   http://isocra.com/2008/02/table-drag-and-drop-jquery-plugin/
   http://romka.eu/blog/jquery-table-drag-and-drop

   #+NAME: iface_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (define-page hh-main "/hh"
       (labels ((mrg (param)
                  (if (null param)
                      (vac-elt 0 "Нет вакансий" 0 "highlight")
                      (reduce #'(lambda (x y)
                                  (concatenate 'string x (string #\NewLine) y))
                              (mapcar #'(lambda (x)
                                          (ps-html ((:li :id (src-id x)
                                                         :class (if (equal ":UNSORT" (state x)) "highlight" ""))
                                                    ((:span) (salary-max x))
                                                    ((:a :href (format nil "/vac/~A" (src-id x)))
                                                     (name x)))))
                                      param)))))
         (let* ((vacs (aif (all-vacancy) it (err "null vacancy")))
                (sorted-vacs (sort vacs #'(lambda (a b) (> (salary a) (salary b)))))
                (breadcrumb (breadcrumb "HeadHunter"))
                (user       (if (null *current-user*) "Анонимный пользователь" (name (get-user *current-user*)))))
           (base-page (:breadcrumb breadcrumb)
             ((:script)
              (ps
                (defun get-child-ids (selector)
                  ((@ ((@ ((@ ($ selector) children)) map) (lambda (i elt) (array ((@ ((@ $) elt) attr) "id")))) get)))
                (defun save ()
                  ((@ $ post) "/hh" (create :act "SAVE" :not ((@ (get-child-ids "#not") join)) :yep ((@ (get-child-ids "#yep") join)))
                   (lambda (data status)
                     (if (not (equal status "success"))
                         (alert (concatenate 'string "err-ajax-fail: " status))
                         (eval data))))
                  false)))
             (content-box ()
               (heading ("Модуль HeadHunter") "Желтым выделены вакансии, которые появились в момент последнего сбора данных. "
                        "По умолчанию они помещаются в правый столбик - к интересующим вакансиям. "
                        "После сортировки следует сохранить состояния вакансий и тогда выделение исчезнет."))
             (content-box (:style "position:relative; x: -600")
               %SAVE%
               ((:section :class "dnd-area")
                ((:ul :class "connected handles list" :id "not")
                 (mrg (remove-if-not #'(lambda (x)
                                         (equal ":UNINTERESTING" (state x)))
                                     sorted-vacs)))
                ((:ul :class "connected handles list no2" :id "yep")
                 (mrg (remove-if #'(lambda (x)
                                     (equal ":UNINTERESTING" (state x)))
                                 sorted-vacs)))))
             (ps-html ((:span :class "clear"))))))
       (:SAVE (ps-html
               ((:input :type "hidden" :name "act" :value "SAVE"))
               (submit "SAVE" :onclick "save();return false;"))
              (progn
                (setf *tmp1* (split-sequence:split-sequence #\, (getf p :not)))
                (setf *tmp2* (split-sequence:split-sequence #\, (getf p :yep)))
                (mapcar #'(lambda (x)
                            (takt (car (find-vacancy :src-id (parse-integer x))) :uninteresting))
                        (split-sequence:split-sequence #\, (getf p :not)))
                (mapcar #'(lambda (x)
                            (takt (car (find-vacancy :src-id (parse-integer x))) :interesting))
                        (split-sequence:split-sequence #\, (getf p :yep)))
                (error 'ajax :output (ps (@ ((@ ($ ".highlight") remove-class) "highlight")))))
              ))
   #+END_SRC

** Страница вакансии

   #+NAME: iface_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defmethod to-html ((vac vacancy) &key filter &allow-other-keys)
       (ps-html
        ((:table :border 0 :style "font-size: small;")
         ((:tr)
          ((:td) "id:")         ((:td) (id vac))         ((:td) "&nbsp;&nbsp;&nbsp;")
          ((:td) "src-id:")     ((:td) (src-id vac))     ((:td) "&nbsp;&nbsp;&nbsp;")
          ((:td) "archive:")    ((:td) (archive vac))    ((:td) "&nbsp;&nbsp;&nbsp;")
          ((:td) "emp-id:")     ((:td) (emp-id vac))     ((:td) "&nbsp;&nbsp;&nbsp;")
          ((:td) "emp-name:")   ((:td) (emp-name vac))   ((:td) "&nbsp;&nbsp;&nbsp;")
          ((:td) "city:")       ((:td) (city vac))       ((:td) "&nbsp;&nbsp;&nbsp;")
          ((:td) "metro:")      ((:td) (metro vac))      ((:td) "&nbsp;&nbsp;&nbsp;")
          ((:td) "experience:") ((:td) (experience vac)) ((:td) "&nbsp;&nbsp;&nbsp;")
          ((:td) "date:")       ((:td) (date vac))       ((:td) "&nbsp;&nbsp;&nbsp;")))
        ((:h3) (name vac) "&nbsp;&nbsp;&nbsp;" ((:span :style "color:red") (salary-text vac)))
        ((:pre) (descr vac))
        ((:table :border 0)
         ((:th) "notes")
         ((:th) "response")
         ((:tr)
          ((:td :width 500 :valign "top") ((:textarea :name "notes" :cols 60 :rows 6) (notes vac)))
          ((:td :width 500 :valign "top") ((:textarea :name "response" :cols 60 :rows 6) (response vac)))))))

     (define-page vacancy "/vacancy/:id"
       (ps-html
        ((:form :method "POST")
          (format nil "~{~A~}"
               (list
                (to-html (car (find-vacancy :src-id id)))
                %save% %respond%))))
       (:save  "<input type=\"submit\" name=\"act\" value=\"SAVE\" />"
               (id (upd-vacancy (car (find-vacancy :src-id id))
                                (list :notes (getf p :notes) :response (getf p :response)))))
       (:respond "<input type=\"submit\" name=\"act\" value=\"RESPOND\" />"
                 (progn
                   (id (upd-vacancy (car (find-vacancy :src-id id))
                                    (list :response (getf p :response))))
                   (respond id 7628220 (getf p :response)))))
   #+END_SRC

** Галлерея (parenscript)

   #+NAME: iface_contents
   #+BEGIN_SRC lisp
     (defparameter *slideshows* (make-hash-table :test 'equalp))

     (defun add-slideshow (slideshow-name image-folder)
       (setf (gethash slideshow-name *slideshows*)
             (mapcar (lambda (pathname)
                       (url-encode (format nil "~a.~a"
                                           (pathname-name pathname)
                                           (pathname-type pathname))))
                     (list-directory image-folder))))

     (add-slideshow "img" "/home/rigidus/repo/moto/img/")
     (add-slideshow "pic" "/home/rigidus/repo/moto/pic/")

     (alexandria:hash-table-plist *slideshows*)

     (defmacro/ps slideshow-image-uri (slideshow-name image-file)
       `(concatenate 'string ,slideshow-name "/" ,image-file))

     (restas:define-route y ("y")
       (ps
         (define-symbol-macro fragment-identifier (@ window location hash))
         (defun show-image-number (image-index)
           (let ((image-name (aref *images* (setf *current-image-index* image-index))))
             (setf (chain document (get-element-by-id "slideshow-img-object") src)
                   (slideshow-image-uri *slideshow-name* image-name)
                   fragment-identifier
                   image-name)))
         (defun previous-image ()
           (when (> *current-image-index* 0)
             (show-image-number (1- *current-image-index*))))
         (defun next-image ()
           (when (< *current-image-index* (1- (getprop *images* 'length)))
             (show-image-number (1+ *current-image-index*))))
         ;; this gives bookmarkability using fragment identifiers
         (setf (getprop window 'onload)
               (lambda ()
                 (when fragment-identifier
                   (let ((image-name (chain fragment-identifier (slice 1))))
                     (dotimes (i (length *images*))
                       (when (string= image-name (aref *images* i))
                         (show-image-number i)))))))))

     (defun slideshow-handler (slideshow-name)
       (let* ((images (gethash slideshow-name *slideshows*))
              (current-image-index (or (position (get-parameter "image") images :test #'equalp)
                                       0))
              (previous-image-index (max 0 (1- current-image-index)))
              (next-image-index (min (1- (length images)) (1+ current-image-index))))
         (with-html-output-to-string (s)
           (:html
            (:head
             (:title "Parenscript slideshow")
             (:script :type "text/javascript"
                      (str (ps* `(progn
                                   (var *slideshow-name* ,slideshow-name)
                                   (var *images* (array ,@images))
                                   (var *current-image-index* ,current-image-index)))))
             (:script :type "text/javascript" :src "/y")
             )
            (:body
             (:div :id "slideshow-container"
                   :style "width:100%;text-align:center"
                   (:img :id "slideshow-img-object"
                         :src (slideshow-image-uri slideshow-name
                                                   (elt images current-image-index)))
                   :br
                   (:a :href (format nil "?image=~a" (elt images previous-image-index))
                       :onclick (ps (previous-image) (return false))
                       "Previous")
                   " "
                   (:a :href (format nil "?image=~a" (elt images next-image-index))
                       :onclick (ps (next-image) (return false))
                       "Next")
                   ))))))

     (restas:define-route x ("/x")
       (slideshow-handler "pic"))

     (restas:define-route z ("/z")
       (slideshow-handler "img"))
   #+END_SRC

* TODO СТОП!!!

    После отправки отклика звонит работодатель и приглашает на интервью. Но это уже
    интерфейсная часть.

    В этот момент я хочу [найти вакансию], глянуть ее и в зависимости от того до чего мы
    договорились с работодателем выставить ей некоторое состояние.

    Я также хочу чтобы система проходила по вакансиям и в зависимости от сочетания условий
    выполняла какие-то действия

    - напоминание мне о собеседованиях, звонках (календарь)
    - автоматическое ранжирование вакансий (по перспективам найма, зарплате и.т.п)

    Система анализирует компании с т.з. выставляемых вакансий и формирует профиль
    компании. По выставляемым вакансиям можно сделать интересные выводы - например когда у
    компании внезапно появляются вакансии на одного сеньера и нескольких линейных
    разработчиков - это напоминает открытие нового отдела/проекта.

    Система классифицирует сохраненные вакансии по формальным признакам, таким как:
    - новые вакансии
    - измененные
    - закрытые (о закрытости вакансии можно судить по ряду критериев)
    - особенно интересные
    - необычные

    В случае изменений или появления новых интересующих пользователя вакансий пользователю отправляется
    уведомление (через систему очередей сообщений и по email).

    Исходя из анализа DESCRIPTION можно определить требуемую технологию и требуемую степень
    владения ею.

    Предоставление рекомендаций и отбор вакансий на основе модифицируемых правил и фактах
    предметной области, таких как "работодатель - компания по разработке ПО" или "ИТ-поддержка
    не является приоритетом компании"

    Предсказание поведения (путей достижения целей) компании (в процессе найма и вне его) на
    основе моделей и целей.

    Выбор вариантов поведения в ответ на предьявляемые требования (цикл распознавание-действие
    в продукционной системе)

    Построение концептуальных моделей и преобразования в них - выбор стратегии действий и
    постановка целей

    Выбор способа представления знаний (правила, фреймы, концептуальные графы)

    Выбор стратегии поиска

    Включение терма из набора технологий в заголовке вакансии - присвоение классификатора
    (тега)

    Правила вывода - сопоставление с профилем

    Вычисление различий (дифф) требований и профильных навыков

    Интерактивное построение профиля (ответы на вопросы). Необходим видимый прогресс и
    предварительная классификация предложений

    Построение новых правил на основе известных

   Когда вакансия переносится в архив - мы должны отслеживать это на стороннем сайте и
   реагировать, устанавливая статус =archive=

   TODO: Конечный автомат тут сложен и будет еще уточняться... Пока состояния такие:
   =просмотрено= (с датой), =отобрано=, =не-берут-трубку=, =не-актуально=,
   =приглашен-на-интервью=, =тестовое-задание=, =получен-оффер=, =отказано-работодателем=,
   =отказ-соискателя=, =вакансия-снята= итп.

   Когда мы собираем вакансии, распарсивая их с других сайтов, мы должны отслеживать их
   состояние на этих сайтах. Мы узнаем о вакансии, ко

*** Для красоты
    Хотелось бы чтобы в сгенерированном html можно было сворачивать куски исходников, ну и
    красивую подсветку. Также нужны имена кусков.

*** WAIT Обход дерева и извлечение узлов

    Чтобы эффективнее (с точки зрения скорости написания кода) разбирать вакансии мы
    разберем всю полученную страницу в дерево, из которого будем извлекать необходимые нам
    элементы.

    Чтобы делать это будем обходить дерево, сопоставляя каждый узел с предикатом, в который
    скомпилируется образец. Начнем с обхода дерева, для этого напишем рекурсивную функцию
    =match-tree=, которую определим с помощью =labels=, чтобы окружить ее формой =let=
    с аккумулятором.

    Определим параметры этой функции:
    - =tree= - под-дерево, которое мы рекурсивно обходим
    - =predict= - функция-предикат, которая может совпасть с обходимым поддеревом
    - =if-match= - параметр чтобы иметь возможность передавать =стратегию=. Про стратегии
      поговорим чуть позже.

    #+NAME: cond_tree
    #+BEGIN_SRC lisp
      (labels ((match-tree (tree f-predict &optional (if-match :return-first-match))
               (cond ((null tree) nil)
                     ((atom tree) nil)
                     (t
                      <<cons>>))))
        <<call>>)
    #+END_SRC

    Теперь переходим к рассмотрению плейсхолдера =cons=, который выполняет основную
    работу. В первую очередь нам следует сравнить текущий узел с параметром =predict= и в
    случае если =predict= вернул T - выполнить какие-то действия. В противном случае -
    обрабатываем поддеревья этого узла.

    #+NAME: cons
    #+BEGIN_SRC lisp
      (if (funcall f-predict tree)
          <<match_ok>>
          <<sub_trees>>)
    #+END_SRC

    #+NAME: sub_trees
    #+BEGIN_SRC lisp
      (cons
       (funcall #'match-tree (car tree) f-predict if-match)
       (funcall #'match-tree (cdr tree) f-predict if-match))
    #+END_SRC

    *Теперь о стратегиях*

    В случае, когда узел совпал с =predict= мы можем реализовать следующие стратегии:
    - Немедленно вернуть совпавший узел и более не обрабатывать никакие узлы.
    - Прекратить обработку всех подузлов совпавшего узла, запомнить его и перейти к обработке
      следующего за ним.
    - Запомнить совпавший узел и продолжить обработку вглубь совпавшего узла, а затем и всех
      остальных узлов.
    - Наиболее общий вариант - применить к сопавшему узлу переданную лямбда-функцию, которая
      может с ним что-то сделать - например записать в какую-нибудь переменную на более
      высоком уровне.
    Реализуем эти стратегии друг за другом.

    Реализуем выбор стратегии в общих чертах - будем использовать =cond= по параметру
    =if-match=. В случае, если в этом параметре не лежит keyword symbol с именем стратегии -
    считаем, что там функция, если это не так - сигнализируем ошибку
    =strategy-not-implemented= (которая пока нигде не определена - я считаю что ее имя
    говорит само за себя).

    #+NAME: match_ok
    #+BEGIN_SRC lisp
      (cond ((equal if-match :return-first-match)
             <<return_first_match>>)
            ((equal if-match :return-first-level-match)
             <<return_first_level_match>>)
            ((equal if-match :return-all-match)
             <<return_all_match>>)
            ((equal 'function (type-of if-match))
             (funcall if-match tree))
            (t (error 'strategy-not-implemented)))
    #+END_SRC

    Теперь приступим к реализации (первой) стратегии: немедленного возврата совпавшего
    узла. Для этого нам понадобится определить внешнюю функцию =tree-match=, чтобы
    возвращаться из нее, а не из текущего рекурсивного вызова =match-tree=. Мы сделаем это
    несколько позже, а пока заполним плейсхолдер =return-first-match=:

    #+NAME: return_first_match
    #+BEGIN_SRC lisp
      (return-from tree-match tree)
    #+END_SRC

    Теперь переходим ко второй стратегии - прекратить обработку всех подузлов сопавшего
    узла, запомнить его и перейти к обработке следующего за ним. Нам понадобится переменная
    =collect= чтобы хранить значения, запомним это и реализуем добавление узла в нее. После
    того, как узел сохранен, мы не проводим обработку его под-деревьев, а переходим в
    следующему узлу этого уровня.

    #+NAME: return_first_level_match
    #+BEGIN_SRC lisp
      (setf collect
            (append collect (list tree)))
    #+END_SRC

    И наконец, реализуем последнюю оставшуюся стратегию, которая представляет из себя
    расширение предыдущей, но с обработкой вложенных узлов. Так и запишем:

    #+NAME: return_all_match
    #+BEGIN_SRC lisp
    (progn
        <<return_first_level_match>>
        <<sub_trees>>)
    #+END_SRC

    Теперь нам осталось лишь правильно возвращать результат. Если используются
    аккумулирующие стратегии, то мы возвращаем содержимое переменной =collect=, в случае
    немедленного возврата совпавшего узла мы никогда не окажемся в этом месте, а в случае
    передачи в =if-match= лямбда-фукции - мы будем считать, что она как-нибудь сама
    заботится о передачи значений. Поэтому всегда будем возвращать =collect=.

    #+NAME: call
    #+BEGIN_SRC lisp
      (match-tree tree predict if-match)
      collect
    #+END_SRC

    Осталось обернуть это все во внешнюю функцию, с аккумулятором:

    #+NAME: tree_match
    #+BEGIN_SRC lisp
      (defun tree-match (tree predict &optional (if-match :return-first-match))
        (let ((collect))
          <<cond_tree>>))
    #+END_SRC

    Но для удобной работы этого недостаточно, поэтому напишем компилер шаблона в
    соответствующий ему =predict=. Этот компилер будет принимать в качестве параметра форму,
    которая будет связываться с элементами шаблона с помощью =destructuring-bind=. Попытка
    связывания будет проводиться для каждого элемента дерева. Ошибки, которые возникают в
    случае невозможности связывания, игнорируются.

    #+NAME: with_predict
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defmacro with-predict (pattern &body body)
        (let ((lambda-param (gensym)))
          `#'(lambda (,lambda-param)
               (handler-case
                   (destructuring-bind ,pattern
                       ,lambda-param
                     ,@body)
                 (sb-kernel::arg-count-error nil)
                 (sb-kernel::defmacro-bogus-sublist-error nil)))))

      ;; (macroexpand-1 '
      ;;  (with-predict (a ((b c)) d &rest e)
      ;;    (aif (and (string= a "div")
      ;;              (string= c "title b-vacancy-title"))
      ;;         (prog1 it
      ;;           (setf **a** a)
      ;;           (setf **b** b)))))

      ;; => #'(LAMBDA (LAMBDA-PARAM)
      ;;        (HANDLER-CASE
      ;;            (DESTRUCTURING-BIND
      ;;                  (A ((B C)) D &REST E)
      ;;                LAMBDA-PARAM
      ;;              (AIF (AND (STRING= A "div") (STRING= C "title b-vacancy-title"))
      ;;                   (PROG1 IT (SETF **A** A) (SETF **B** B))))
      ;;          (SB-KERNEL::ARG-COUNT-ERROR NIL)
      ;;          (SB-KERNEL::DEFMACRO-BOGUS-SUBLIST-ERROR NIL))), T
    #+END_SRC

    Вот так, к примеру, это можно совместить с поиском по дереву:

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (tree-match '("div"
                    (("class" "b-vacancy-custom g-round"
                      ("meta" (("itemprop" "title") ("content" "Ведущий android-разработчик")))
                      ("h1" (("class" "title b-vacancy-title")) "Ведущий android-разработчик")
                      ("table" (("class" "l"))
                               ("tr" NIL
                                     ("td" (("colspan" "2") ("class" "l-cell")))
                                     ("td" (("class" "l-cell")))))))
                    (("class" "g-round plus"))`
                    ("meta" (("itemprop" "title") ("content" "Ведущий android-разработчик"))))
                  (with-predict (a b &rest c)
                    (aif (and (stringp a)
                              (string= a "class"))
                         (prog1 it
                           (setf **a** a)
                           (setf **b** b))))
                  :return-all-match)
    #+END_SRC

    Для еще большей лаконичности мы можем определить оборачивающий макрос, который позволит
    нам не писать ничего, кроме условия в =aif=:

    #+NAME: with_predict_if
    #+BEGIN_SRC lisp
      (in-package #:moto)

      <<with_predict>>

      (defmacro with-predict-if (pattern &body condition)
        `(with-predict ,pattern
           (aif ,@condition
                (prog1 it
                  ,@(mapcar #'(lambda (x)
                                `(setf ,(intern (format nil "**~A**" (symbol-name x))) ,x))
                            (remove-if #'(lambda (x)
                                           (or (equal x '&rest)
                                               (equal x '&optional)
                                               (equal x '&body)
                                               (equal x '&key)
                                               (equal x '&allow-other-keys)
                                               (equal x '&environment)
                                               (equal x '&aux)
                                               (equal x '&whole)
                                               (equal x '&allow-other-keys)))
                                       (alexandria:flatten pattern)))))))

      ;; (macroexpand-1 '
      ;;  (with-predict-if (a b &rest c)
      ;;    (and (stringp a)
      ;;         (string= a "class"))))

      ;; => (WITH-PREDICT (A B &REST C)
      ;;      (AIF (AND (STRINGP A) (STRING= A "class"))
      ;;           (PROG1 IT
      ;;             (SETF **A** A)
      ;;             (SETF **B** B)
      ;;             (SETF **C** C))))
    #+END_SRC

    Таким образом мы инжектируем переменные шаблона в глобальную область видимости, если они
    не определены в более высокоуровневом =let=.

    Теперь мы можем использовать =tree-match= так:

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (print
       (tree-match '("div" (("class" "b-vacancy-custom g-round"))
                     ("meta" (("itemprop" "title") ("content" "Ведущий android-разработчик")))
                     ("h1" (("class" "title b-vacancy-title")) "Ведущий android-разработчик")
                     ("table" (("class" "l"))
                      ("tbody" NIL
                       ("tr" NIL
                             ("td" (("colspan" "2") ("class" "l-cell"))
                                   ("div" (("class" "employer-marks g-clearfix"))
                                          ("div" (("class" "companyname"))
                                                 ("a" (("itemprop" "hiringOrganization") ("href" "/employer/1529644"))
                                                      "ООО Нимбл"))))
                             ("td" (("class" "l-cell")))))))
                   (with-predict-if (a b &rest c)
                     (and (stringp a)
                          (string= a "class")))
                   :return-all-match))

      ;; => (("class" "b-vacancy-custom g-round") ("class" "title b-vacancy-title")
      ;;     ("class" "l") ("class" "l-cell") ("class" "employer-marks g-clearfix")
      ;;     ("class" "companyname") ("class" "l-cell"))

      (print **b**)
      ;; => "l-cell"
    #+END_SRC

*** WAIT Сопоставление и преобразование узлов

    Разбирая вакансию мы должны извлечь несколько блоков:
    - блок заголовка
    - общие данные, такие как уровень зарплаты, город, требуемый опыт работы
    - собственно описание вакансии
    Из каждого блока будем извлекать конкретные данные, возвращаемы как plist.

    Описание вакансии представляет из себя дерево, в котором нам важна структура, так как
    требования, обязанности и прочее описываются списком. В этом списке много лишнего
    форматирования, для удаления которого нам необходимо уметь преобразовывать дерево.

    Напишем для этого рекурсивный преобразователь, который возвращает новое дерево,
    рекурсивно вызывая аргумент =transformer= на =sub-tree=, которые удовлетворяют аргументу
    =predicate=.

    Аргумент =predicate= должен быть лямбда-функцией, которая принимает на вход =subtree= и
    возвращает T или NIL

    Аргумент =transformer= должен быть лямбда-функцией, которая принимает на вход =subtree= и
    возвращает =atom= или =subtree= в первом параметре, а во втором может возвратить функцию
    =control=. Если эта функция возвращена, тогда дерево возвращается с замененным
    =transformer=-ом узлами по следующему алгоритму:

    #+BEGIN_SRC lisp
      (funcall control
               #'(lambda (x)
                   (maptree-if predicate transformer x))
               transformed-tree)
    #+END_SRC

    В противном случае оно возвращается как есть.

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun maptree-if (predicate transformer tree)
        (multiple-value-bind (t-tree control)
            (if (funcall predicate tree)
                (funcall transformer tree)
                (values tree #'mapcar))
          (if (and (consp t-tree)
                   control)
              (funcall control
                       #'(lambda (x)
                           (maptree-if predicate transformer x))
                       t-tree)
              t-tree)))
    #+END_SRC

    Несколько примеров работы:

    #+BEGIN_SRC lisp
      (in-package #:moto)

      ;; Нерекурсивная замена
      (maptree-if #'(lambda (x)
                      (and (consp x)
                           (eq (car x) 'ping)))
                  #'(lambda (x)
                      `(pong ,@(cdr x)))
                  '(progn (ping (ping (ping 1)))))
      ;; => (PROGN (PONG (PING (PING 1))))

      ;; Рекурсивная замена
      (maptree-if #'(lambda (x)
                      (and (consp x)
                           (eq (car x) 'ping)))
                  #'(lambda (x)
                      (values `(pong ,@(cdr x)) #'mapcar))
                  '(progn (ping (ping (ping 1)))
                    ping))
      ;; => (PROGN (PONG (PONG (PONG 1))))

      ;; Применение совместно с with-predict-if и использованием **переменных**
      (maptree-if #'(lambda (x)
                      (and (consp x)
                           (funcall (with-predict-if (a b &rest c)
                                      (and (equal b 'ping)))
                                    x)))
                  #'(lambda (x)
                      (values `(,**a** pong ,@(cddr x)) #'mapcar))
                  '(progn (ping (ping ping (ping 1)))
                    ping))
    #+END_SRC

    И макрос для более лаконичной записи того же:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defmacro with-predict-maptree (pattern condition replace tree)
        (let ((lambda-param (gensym)))
          `(maptree-if #'(lambda (,lambda-param)
                           (and (consp ,lambda-param)
                              (funcall (with-predict-if ,pattern
                                         ,condition)
                                       ,lambda-param)))
                       ,replace
                       ,tree)))

      ;; (macroexpand-1
      ;;  '(with-predict-maptree (a b &rest c)
      ;;    (and (equal b 'ping))
      ;;    #'(lambda (x)
      ;;        (values `(,**a** pong ,@(cddr x)) #'mapcar))
      ;;    '(progn (ping (ping ping (ping 1))) ping)))

      ;; (with-predict-maptree (a b &rest c)
      ;;   (and (equal b 'ping))
      ;;   #'(lambda (x)
      ;;       (values `(,**a** pong ,@(cddr x)) #'mapcar))
      ;;   '(progn (ping (ping ping (ping 1))) ping))
    #+END_SRC

* Хотелки

  Мы все ищем работу на профильных сайтах, но, к сожалению, не всегда на них хватает
  функционала, особенно нестандартного. Работая с сайтом в автоматическом режиме мы можем
  восполнить этот пробел.

  Кроме того есть множество конкурирующих сайтов для поиска работы, информацию с которых
  можно аггрегировать.

  При поиске работы основной сценарий использования - =поиск вакансий=, и практически все
  сайты его предоставляют. Однако мне бы хотелось дополнительно иметь дополнительный
  функционал:

  - заметки по каждой вакансии
  - статусы или теги, такие как:
    - =просмотрено= (с датой),
    - =отобрано=,
    - =не-берут-трубку=,
    - =не-актуально=,
    - =приглашен-на-интервью=,
    - =выслали-тестовое-задание=,
    - =отправил-тестовое-задание=,
    - =получен-оффер=,
    - =вакансия-закрыта= итп.

  Я бы хотел ранжировать вакансии вручную (по выставленным приоритетам) и автоматически
  (т.е. скриптом), например в зависимости от зарплаты или удаленности.

  Я бы хотел иметь возможность планировать маршрут, когда еду на собеседование и иметь
  календарь, чтобы не пропустить встречу.

  Я бы хотел иметь версии вакансий, чтобы отслеживать их изменения, например изменения
  зарплаты до и после моего интервью - это позволит анализировать рынок и получать больше
  информации.

  Мне также интересно составлять профили компаний и отслеживать как меняется набор
  сотрудников которых они ищут - это поможет планировать долгосрочную стратегию. Особенно в
  этом плане интересны лидеры рынка - Яндекс, Гугл и.т.п.

  Я бы хотел иметь возможность пообщаться с теми кто работал или работает в интересующей
  меня компании, иметь подмножество функционала социальных сетей или интеграцию с ними

  Иногда мне приятно работать с уже знакомыми людьми, так что в целом я бы не отказался
  создавать на таком сайте что-то типа т.н. =рабочих коллективов=, чтобы наниматься сразу
  командой. Возможно работодателям такой вариант найма тоже будет интересен.

   В ряде случаев компании меняют свои вакансии, некоторые делают это методом удаления
   предыдущей и создания новой. Мне как соискателю хотелось бы не обнаруживать уже
   просмотренную и возможно собеседованную вакансию в новых. Поэтому хотелось бы
   предусмотреть механизм, который связывает очень похожие вакансии друг с другом.

   Иногда вакансии меняются, или в них меняются существенные условия. Например, две недели
   назад, когда я смотрел вакансию из предыдущей сборки меня не устроила зарпалата, а
   сегодня вакансия стала интереснее. Я хочу отслеживать что вакансия поменялась.

   Таким образом при создании вакансии мы должны проверять, может она уже есть в базе и
   тогда указывать, что эта вакансия включена в несколько сборок (требует таблицы связи)

   Несколько вакансий могут быть от одной компании. В этом случае мне бы хотелось
   отслеживать это в профиле компании, кроме того интересна аналитика по этой компании за
   определенный период времени.

   С социальной точки зрения интересно получать отзывы о компании от ее работников, в том
   числе и уволенных.

   Действия по вакансии: звонки, скайп-интервью, собеседования

   В эту таблицу заносим что сделано по каждой вакансии, которая находится в разработке

   Теги вакансий Помогают ориентироваться, когда вакансий много.

   Важно: Для обеспечения социальных взаимодействий нужно предусмотреть, чтобы вакансию
   можно было "передать", т.е. у нее минимум должен быть URI.

   Если пользователь просмотрел вакансию, но пока не хочет отправлять отзыв - он может
   добавить вакансию в закладки - в этом случае ее статус меняется на =favorited=

   Из =favorited= мы снова можем отправить отзыв.

   Из =favorited= пользователь может вернуть вакансию обратно в =interesting= или =hidden=.

   Из =hidden= пользователь может вернуть вакансию в =interesting=.

   Если по вакансии позвонили, пользователю обычно нужно ее быстро найти. Нужна форма поиска
   по вакансиям в статусе =responded= - пользователь ищет обычно по названию фирмы.

   После звонка вакансия может быть выкинута или переведена из =responded= в статус "был
   телефонный звонок" - =called=. Выкидывая вакансию пользователь может выбрать reason - для
   них можно будет потом сделать отдельную таблицу но пока просто пишем в поле
   вакансии. Если в результате телефонного звонка была достигнута договоренность о
   собеседовании - пользователь переводит вакансию в состояние "пригласили на интервью" -
   =wait-interview= и заносит в вакансию данные о том, куда и во сколько ехать. Если по
   телефону рекрутер предложил тестовое задание - статус - "ожидание тестового задания" -
   =wait-test=. Если договорились о интервью по скайпу - "ожидание скайп-интервью" -
   =wait-skype-interview=.

   Получив тестовое задание пользователь переводит вакансию из статуса =wait-test= в
   "выполнение тестового задания" =run-test=, а оттуда либо в =test-cancel= либо в
   =test-sended=. Либо выкидывает.

   Пользователи иногда забивают на интервью (случаются накладки) - в этом случае рекрутер
   часто передоговаривается на другое время. Делать петли в графе значит излишне усложнять
   его, наверно пусть можно будет просто изменить данные о времени интервью.

   После интервью или скайп-интервью от вакансии можно либо отказаться (=refuse-employer=,
   =refuse-applicant=) либо перевести в статус "ожидание результата" - =wait-result=. Нужно
   включать таймер, по истечении которого напоминать пользователю позвонить рекрутеру и
   узнать, как дела.

   Иногда после скайп-интервью назначают очное интервью. Также бывает прямо на интервью
   предлагают оффер - =offer= и соискатель берет время на подумать.

   Из "ожидания результата" можно перескочить в "предложен оффер", "отказ работодателя" -
   =refuse-employer= или "отказ соискателя" - =refuse-аpplicant=.

   История статусов нужна, в нее нужно заносить время когда изменяется статус и возможно
   примечания по изменению. Будет красиво, если в интерфейсе будет отображаться полный граф
   статусов и текущее положение вакансии в нем.

   | refuse-new                             | new                  | uninteresting       |
   | set-interesting                         | new                  | interesting           |
   | refuse-interesting                      | interesting           | hidden               |
   | respond                                | interesting           | responded            |
   | favor                                  | interesting           | favorited            |
   | send-respond-from-favorited            | favorited            | responded            |
   | unfavor                                | favorited            | interesting           |
   | hide-after-favor                       | favorited            | hidden               |
   | call                                   | responded            | called               |
   | invite-interview                       | called               | wait_interview       |
   | invite-skype-interview                 | called               | wait_skype_interview |
   | invite-test                            | called               | wait_test            |
   | interview                              | wait_interview       | interview            |
   | skype-interview                        | wait_skype_interview | skype_interview      |
   | call-after-skype-interview             | skype_interview      | called               |
   | execute-test                           | wait_test            | run_test             |
   | send-test                              | run_test             | send_test            |
   | called-after-test                      | send_test            | called               |
   | refuse-employer-after-interview        | interview            | refuse_employer      |
   | refuse-applicant-after-interview       | interview            | refuse_applicant     |
   | wait-result-after-interview            | interview            | wait_result          |
   | refuse-employer-after-skype-interview  | skype_interview      | refuse_employer      |
   | refuse-applicant-after-skype-interview | skype_interview      | refuse_applicant     |
   | wait-result-after-skype-interview      | skype_interview      | wait_result          |
   | invite-next-interview                  | wait_result          | interview            |
   | invite-interview-after-skype           | skype_interview      | interview            |
   | invite-offer                           | wait_result          | offer                |
   | employer-refuse-after-wait-result      | wait_result          | refuse_employer      |
   | applicant-refuse-after-wait-result     | wait_result          | refuse_applicant     |

** Процесс найма с т.з. соискателя

   С точки зрения соискателя процесс найма выглядит так:

   - Этап составления резюме
   - Этап опубликования резюме
   - Этап поиска
     - Поиск и просмотр вакансий, отсев, ранжирование
     - Рассылка откликов
   - Этап телефонных переговоров
     - Получение звонков, обсуждение деталей по телефону
     - Договоренность о еще одном звонке
     - Тестовое задание на почту
     - Договоренность о skype-интервью
   - Этап удаленного тестирования
     - Skype-интервью
     - Ожидание тестового задания
     - Выполнение тестового задания
   - Этап очного собеседования
     - Приглашение на интервью
     - Интервью
   - Этап отбора предложений
     - Получение предложений
     - Выбор предложения

** Процесс найма с т.з. HR-а

   Когда HR-специалист ищет вакансии, он пользуется несколькими путями:
   - Личные знакомства
   - Рекомендации
   - Социальные сети
     - LinkedIn
     - vkontakte
   - Помощь коллег
   - Специализированные сайты

   Как правило, HR-специалист менее компетентен в предметной области, чем нанимаемый
   сотрудник, поэтому для него имеет большой вес мнение рекомендателей и коллег
   соискателя. Вероятно, рекомендательный сервис был бы очень актуален.

   Компании-работодатели выбирают одну из моделей найма, в соответствии со своим бюджетом и
   задачами:
   - Всегда (на любую позицию) нанимать (переманивать) лучших
   - Нанимать начинающих в подчинение лучшим
   - Нанимать начинающих (конвеерная разработка, большая текучка)
   - Нанимать тех, кто понравится лидеру отдела
   - Нанимать тех, кто лучше соответствует корпоративной культуре

   Для каждой из этих моделей характерны свои необходимые сервисы. К примеру, для модели
   "нанимать лучших" совершенно необходимо вести и актуализировать базу этих "лучших", чтобы
   вовремя сделать предложение кандидату. О примерах внедрения таких сервисов мне ничего не
   известно. Также интересно уточнить у HR-специалистов из =разных= компаний их методы
   работы.

   Для HR-специалиста процесс найма выгядит (в общих чертах) так.

   - Этап составления вакансий
   - Этап опубликования вакансий
   - Этап поиска резюме
     - По ключевым словам
     - По фильтру
     - Используя автоподбор
   - Этап анализа откликов (неразобранные, подумать, приглашенные, отклоненные)
   - Телефонный звонок соискателю (с целью уточнить детали или пригласить)
   - Возможно отправка тестового задания
   - Получение тестового задания
   - Проверка тестового задания
   - Скайп-интервью
   - Этап собеседования
     - Опциоанльно: заполнение анкеты
     - Собеседование с HR-специалистом (об условиях)
     - Тесты (например: на знание языка, ООП, БД, многопоточность)
     - Тестовое задание
     - Проверка тестового задания
     - Собеседование с тех. спецом, (как правило нач. отдела)

   HR-специалист анализирует обратную связь о составляемых им вакансиях - у него есть
   статистическая информация о кол-ве просмотров вакансий и количестве поступивших
   откликов. Из этих данных можно, например, сделать вывод, что предложенная зарплата
   неактуальна на рынке.

   Также HR-специалист заинтересован в технической поддержке при решении задач типа:
   - Мониторинг резюме (сообщения о обновлении резюме, просмотр старой версии)
   - Ведение базы кандидатов (часто в экселе)

   HR-специалист заинтересован в том, чтобы иметь возможность построить процесс найма под
   себя.

* Сценарии использования
** Пользовательские
*** Авторизация/регистрация

    Пользователь регистрируется и авторизуется для получения доступа к своем аккаунту. За
    это отвечает модуль auth.

*** Формализация предпочтений

    Пользователь формулирует свои предпочтения относительно вакансий (и фирм их размещающих)
    в виде некоторых формализованных утверждений.

*** Отбор и сортировка вакансий

    Пользователь отбирает интересные и неинтересные ему вакансии вручную и автоматически -
    путем применения к ним скриптов

*** Внесение заметок к вакансиям

    Пользователь вносит свои соображения и заметки связанные с вакансией, или
    фирмой-работодателем

*** Заполнение резюме

    Пользователь заполняет резюме

*** Написание сопроводительных писем

    Пользователь пишет шаблоны сопроводительных писем, которые будут отправлены вместе с
    отзывом на вакансию

*** Отправка отзывов

    Пользователь отправляет отзыв на вакансию.

    Основные этапы:
    - Регистрация/логин (цель - войти на сайт)
    - Заполнение профиля (цель - определить поисковые запросы)
    - Написание резюме (несколько резюме, возможно под каждую особо-интересную вакансию)
    - Написание сопроводительных писем (тоже несколько, под вакансии)
    - Сбор тизеров по поисковому запросу
    - Ранжирование тизеров (положительный/отрицательный отсев)
    - Таггирование тизеров
    - Написание автоматических скриптов ранжирования по тегам (для продвинутых)
    - Сбор заинтересовавших вакансий (выше чем определенный ранг)
    - Ранжирование вакансий (положительный/отрицательный отсев)
    - Связывание с резюме и сопроводительными письмами
    - Отправка отзывов
    - Внесение заметок
    - Остальные переводы статуса и действия

    Зарегистрированный пользователь создает "поисковый профиль", в который заносит поисковый
    запрос и (в будущем) источники данных. Поля профиля описаны в секции [[Поисковые профили]].

    Потом он запрашивает сбор данных по этому поисковому профилю. Собираются тизеры
    вакансий. Если появились новые вакансии они добавляются в набор. Изменившиеся вакансии
    обновляются и помечаются как обновившиеся, не изменившиеся - не попадают в набор.

    После сбора данных пользователь просматривает набор и фильтрует его, отсеивая неинтересные
    вакансии, (которые скрываются) и помечая особенно понравившиеся (звездочкой).

    После фильтрации у отобранных вакансий скачиваются описания

    Выбрав вакансию, пользователь может оставить к ней заметки и начинает движение по графу состояний.

** Поисковые профили

   Разумеется, лучше собирать не все подряд, а только то что необходимо соискателю. Когда
   соискатель пользуется профильным сайтом он использует поисковые запросы, на основании
   которых мы можем формировать, гм... назовем это =поисковыми профилями=. Поисковый
   профиль - это запрос пользователя, плюс набор связанных с ним вакансий=.

   Вакансии на сайтах размещаются =компаниями= и привязываются к ним. Мне, как соискателю,
   интересно посмотреть какие вакансии размещала ранее конкретная компания, какие она
   размещает теперь, как изменялись зарплаты - и тому подобная аналитическая информация.

   Загрузка данных начинается с автоматического использования поиска. Мне интересны разные
   поисковые запросы - например, "веб-программист", "менеджер проекта", "руководитель
   отдела" и.т.п. По каждому из них можно составить поисковый профиль, который кроме текущих
   актуальных вакансий в нем содержит еще и "сборки" - с датой и временем получения данных и
   "изменения", т.е диффы между предыдущей сборкой и этой. Таким образом, например, можно
   отслеживать только что появляющиеся вакансии, которые часто представляют наибольший
   интерес.

   Мне бы хотелось осуществлять =сбор данных в многопоточном режиме=.

*** Список поисковых профилей

    Чтобы управлять поисковыми профилями нам понадобится страничка на которой их можно
    создать, удалить и просмотреть.

    #+NAME: iface_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (define-iface-add-del-entity all-profiles "/profiles"
        "Поисковые профили"
        "Новый профиль"
        "Когда соискатель пользуется профильным сайтом он использует
         поисковые запросы, на основании которых мы можем формировать,
         гм... назовем это =поисковыми профилями=. Поисковый профиль - это
         запрос пользователя, плюс набор связанных с ним вакансий"
         #'all-profile "profile"
        (name)
        (frm
         (tbl
          (list
           (row "Название" (fld "name"))
           (row "Запрос" (fld "search"))
           (row "" %new%))))
        (:new (act-btn "NEW" "" "Создать")
              (progn
                (make-profile :name (getf p :name)
                              :user-id 1
                              :search-query (getf p :search)
                              :ts-create (get-universal-time)
                              :ts-last (get-universal-time))
                "Профиль создан"))
        (:del (act-btn "DEL" (id i) "Удалить")
              (progn
                (del-profile (getf p :data)))))
    #+END_SRC

*** Страничка поискового профиля

    На страничке поискового профиля мы выводим все собранные по этому поисковому профилю
    вакансии. Будем считать что нас не особо интересуют вакансии без указания зарплаты,
    поэтому мы их просто отфильтровываем. После фильтрации сортируем в направлении уменьшения
    зарплаты.

    #+NAME: iface_contents
    #+BEGIN_SRC lisp

      (in-package #:moto)

      ;; (defun vacancy-table (raw)
      ;;   (let ((vacs (sort (remove-if #'(lambda (x)
      ;;                                    (equal 0 (salary x)))
      ;;                                raw)
      ;;                     #'(lambda (a b)
      ;;                         (> (salary a) (salary b))))))
      ;;     (format nil "<h2>Вакансий: ~A</h2>~%~A" (length vacs)
      ;;             (tbl
      ;;              (with-collection (vac vacs)
      ;;                (tr
      ;;                 (td
      ;;                  (state vac))
      ;;                 (td
      ;;                  (format nil "<div style=\"background-color:green\">~A</div>"
      ;;                          (input "radio" :name (format nil "R~A" (id vac)) :value "y"
      ;;                                 :other (if (string= ":INTERESTING" (state vac)) "checked=\"checked\"" ""))))
      ;;                 (td
      ;;                  (format nil "<div style=\"background-color:red\">~A</div>"
      ;;                          (input "radio" :name (format nil "R~A" (id vac)) :value "n"
      ;;                                 :other (if (string= ":UNINTERESTING" (state vac)) "checked=\"checked\"" ""))))
      ;;                 (td (format nil "<a href=\"/vacancy/~A\">~A</a>" (id vac) (name vac)))
      ;;                 (td (salary-text vac))
      ;;                 (td (currency vac))))
      ;;              :border 1))))

      ;; (define-page profile "/profile/:userid"
      ;;   (let* ((i (parse-integer userid))
      ;;          (page-id (parse-integer userid))
      ;;          (u (get-profile i))
      ;;          (vacs (sort (remove-if #'(lambda (x)
      ;;                                     (equal 0 (salary x)))
      ;;                                 (find-vacancy :profile-id page-id))
      ;;                      #'(lambda (a b)
      ;;                          (> (salary a) (salary b))))))
      ;;     (if (null u)
      ;;         "Нет такого профиля"
      ;;         (format nil "~{~A~}"
      ;;                 (list
      ;;                  "<script>
      ;;                          function test (param) {
      ;;                             $.post(
      ;;                                \"/profile/1\",
      ;;                                {act: param},
      ;;                                function(data) {
      ;;                                   $(\"#dvtest\").html(data);
      ;;                                }
      ;;                            );
      ;;                          };
      ;;                   </script>"
      ;;                  (format nil "<h1>Страница поискового профиля ~A</h1>" (id u))
      ;;                  (format nil "<h2>Данные поискового профиля ~A</h2>" (name u))
      ;;                  (frm
      ;;                   (tbl
      ;;                    (with-element (u u)
      ;;                      (row "Имя профиля" (fld "name" (name u)))
      ;;                      (row "Запрос" (fld "search" (search-query u)))
      ;;                      (row (hid "profile_id" (id u)) %change%))
      ;;                    :border 1))
      ;;                  (tbl
      ;;                   (tr
      ;;                    (td %show-all%)
      ;;                    (td %show-interests%)
      ;;                    (td %show-not-interests%)
      ;;                    (td %show-other%)))
      ;;                  (frm %proceess-interests%)
      ;;                  (frm
      ;;                   (list
      ;;                    "<br /><br />"
      ;;                    %clarify%
      ;;                    "<div id=\"dvtest\">dvtest</div>"))))))
      ;;   (:change  (act-btn "CHANGE" "" "Изменить")
      ;;             (id (upd-profile (get-profile (parse-integer userid))
      ;;                              (list :name (getf p :name) :search-query (getf p :query)))))
      ;;   (:clarify (act-btn "CLARIFY" "" "Уточнить")
      ;;             (loop :for key :in (cddddr p) :by #'cddr :collect
      ;;                (let* ((val (getf p key))
      ;;                       (id  (parse-integer (subseq (symbol-name key) 1)))
      ;;                       (vac (get-vacancy id)))
      ;;                  (list id
      ;;                        (cond ((string= "y" val)
      ;;                               (unless (string= ":INTERESTING" (state vac))
      ;;                                 (takt vac :interesting)))
      ;;                              ((string= "n" val)
      ;;                               (unless (string= ":UNINTERESTING" (state vac))
      ;;                                 (takt vac :uninteresting)))
      ;;                              (t "err param"))))))
      ;;   (:show-all (format nil "<input type=\"button\" onclick=\"test('SHOW-ALL');\" value=\"все\">")
      ;;              (error 'ajax :output (vacancy-table (find-vacancy :profile-id 1))))
      ;;   (:show-interests (format nil "<input type=\"button\" onclick=\"test('SHOW-INTERESTS');\" value=\"интересные\">")
      ;;                    (error 'ajax :output (vacancy-table (find-vacancy :state ":INTERESTING" :profile-id 1))))
      ;;   (:show-not-interests (format nil "<input type=\"button\" onclick=\"test('SHOW-NOT-INTERESTS');\" value=\"неинтересные\">")
      ;;                        (error 'ajax :output (vacancy-table (find-vacancy :state ":UNINTERESTING" :profile-id 1))))
      ;;   (:show-other (format nil "<input type=\"button\" onclick=\"test('SHOW-OTHER');\" value=\"остальные\">")
      ;;                (error 'ajax :output (vacancy-table (remove-if #'(lambda (x)
      ;;                                                                   (or (string= ":UNINTERESTING" (state x) )
      ;;                                                                       (string= ":INTERESTING" (state x))))
      ;;                                                               (find-vacancy :profile-id 1)))))
      ;;   (:proceess-interests (act-btn "PROCEESS-INTERESTS" "" "Собрать данные интересных вакансий")
      ;;                        "TODO"))

      ;; (profile-id (car (all-vacancy)))

      ;; (mapcar #'(lambda (x)
      ;;             (salary x))
      ;;         (find-vacancy :profile-id 1))

      ;; (car
      ;;  (remove-if #'(lambda (x)
      ;;                 (null (getf x :salary)))
      ;;             *teasers*))

      ;; (currency
      ;;  (car
      ;;   (remove-if #'(lambda (x)
      ;;                  (equal (salary x) 0))
      ;;              (all-vacancy))))
    #+END_SRC

** Поиск вакансий

   Внутри вакансий необходимо искать по критериям, которые я уточню позже

   Мне хотелось бы чтобы вакансии были упорядочены по зарплате

   Мне бы хотелось сразу получать представление, насколько свежая вакансия

   Мне было бы интересно, сколько интервью было проведено и запланировано по вакансии - эту
   информацию можно узнать из анализа активности по ней других пользователей

   Мне было бы интересно, как менялась вакансия с момента ее размещения компанией - можно
   находить и отслеживать похожие вакансии по расстоянию Левенштейна в описании, к
   примеру. Динамика изменения зарплатного предложения может многое сказать об отношении к
   вакансии.

** Ручной отбор вакансий
** Автоматический отбор вакансий
** Внесение заметок по вакансии
** Просмотр и отбор вакансий, заметки и выставление статусов

   Когда я читаю вакансию, я бы хотел, чтобы она переходила в статус "просмотрено" (и к ней
   добавлялась дата просмотра)

   Читая вакансию, мне бы хотелось устанавливать ей приоритет и вносить заметки, чтобы
   отслеживать такие моменты, как например: необходимость позвонить позже, или все, что мне
   сказал hr по телефону. Есть типовые вещи, которые можно просто сделать кнопками.

   Если я отправляю отзыв на вакансию или звоню по телефону - я бы хотел, чтобы эти действия
   сопровождались временем и изменением статуса, чтобы потом можно было отследить историю
   взаимодействия с фирмой.

   При этом, мне хотелось бы видеть на дашборде те вакансии, с которыми я договорился о
   встрече и те, по которым нет движения долгое время, чтобы ничего не забывалось.

** Дашборд

   Если у нас есть формализованный алгоритм (а он есть, так как найм - это линейный
   процесс), то я хочу получать напоминания о моем следующем шаге в отношении тех вакансий,
   которые мне интересны.

   Мне бы хотелось видеть на каком я этапе в тех вакансиях, которые меня интересуют.

** Отзывы соискателей о компаниях и вакансиях

   Можно сэкономить кучу времени и денег просто не нанимаясь в те компании, в которых "все
   плохо". В этом плане соискатели могут помоч друг другу. Возможно и компании тоже будут
   прислушиваться к такому фидбеку

** Размещение резюме

   Пользователь просто размещает свое резюме. На самом деле - несколько резюме, так как
   наиболее продвинутые пользователи пишут резюме под вакансию, а не рассылают одно и то же
   резюме всем подряд

** Маршрут

   Иногда я хочу спланировать маршрут поездки по собеседованиям. Это сервис с картами,
   которые можно сделать позже.

** Создание вакансии работодателем
** Вакансия становится неактуальной

   Вакансия может стать неактуальной если работодатель снимет ее, но работодатели могут
   забывать это сделать, поэтому можно предусмотреть тайм-аут или даже некоторое кол-во
   голосов соискателей, которые дозвонились но им сказали, что вакансия уже неактуальна.

* Тесты

  #+NAME: hh_test
  #+BEGIN_SRC lisp :noweb tangle

    ;; Тестируем hh
    (defun hh-test ()
      <<hh_test_contents>>
      (dbg "passed: hh-test~%"))
    (hh-test)
  #+END_SRC

  #+NAME: hh_test_contents
  #+BEGIN_SRC lisp :noweb tangle

  #+END_SRC
* Точки входа

  Соберем шаблоны:

  #+NAME: hh_tpl
  #+BEGIN_SRC closure-template-html :tangle src/mod/hh/hh-tpl.htm :noweb tangle
    // -*- mode: closure-template-html; fill-column: 140 -*-
    {namespace hhtpl}

    <<hhtpl_contents>>
  #+END_SRC

  Скомпилируем шаблоны при подготовке модуля

  #+NAME: hh_prepare
  #+BEGIN_SRC lisp :tangle src/mod/hh/hh-prepare.lisp :noweb tangle
    (in-package #:moto)

    ;; Скомпилируем шаблон
    (closure-template:compile-template
     :common-lisp-backend
     (pathname
      (concatenate 'string *base-path* "mod/hh/hh-tpl.htm")))
  #+END_SRC

  Соберем контроллеры и все функции, которые контроллеры вызывают

  #+NAME: hh_fn
  #+BEGIN_SRC lisp :tangle src/mod/hh/hh.lisp :noweb tangle
    (in-package #:moto)

    <<tree_match>>

    ;; special syntax for pattern-matching
    (named-readtables:in-readtable :fare-quasiquote)

    <<run>>

    <<_hh_fn_contents>>

    <<_hh_parse>>

    <<_hh_test>>
  #+END_SRC

* Сборка
** Фунциональные утилиты

   #+NAME: f_util
   #+BEGIN_SRC lisp :tangle src/mod/hh/f-util.lisp :noweb tangle :padline no :comments link
     (in-package #:moto)

     <<f_util_contents>>
   #+END_SRC

*** Point-free определения:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defmacro define (form* form)
        (etypecase form*
          (symbol (etypecase form
                    ;; alias for function or macro
                    (symbol `(defmacro ,form* (&rest args)
                               `(,',form ,@args)))
                    ;; alias for lambda
                    (cons   `(defun ,form* (&rest args)
                               (apply ,form args)))))
          (cons     ;; scheme-like function definition
           ` (defun ,(first form*) ,(rest form*)
               ,form))))
    #+END_SRC

    Тут typecase используется до генерации кода - в зависимости от того символы или списки
    связываются друг с другом генерируются различные определения. Можно определять
    псевдонимы для функций и маросов, псевдоним будет макросом:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (define head car)
      (define tail cdr)
      (define \\   lambda)
      (define $    funcall)
    #+END_SRC

    Можно определить функцию f2, которая является псевдонимом для лямбды, возвращённой
    формой (f1 a1):

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (define f2 (f1 a1))
      (f2 a2) ~ (apply (f1 a1) a2)
    #+END_SRC

    Простое определение функций в Scheme-стиле, более соответствующее представлению о
    редукции форм:

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (define (f1 a1) (f2 a2))
      (f1 a1) ~ (defun f1 (a1) (f2 a2))
    #+END_SRC

    Также, чтобы определять функции миксующую аргументы с другой функцией, можно ввести
    такой макрос:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defmacro define* (form* form)
        `(defun ,(first form*) ,(rest form*)
           (,(first form) ,@(rest form) ,@(rest form*))))
    #+END_SRC

    Пример:

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (define* (f1 a1) (f2 a2))
      (f1 a1) ~ (f2 a2 a1)
    #+END_SRC

    Либо использовать карринг.

*** Flip, карринг, композиции:

    далее f, g, ... обозначают функции,
    a, b, ... - их аргументы.

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (define (self object) object)
      (define (flip f)      (\\ (a b) ($ f b a)))
      (define (curry f a)   (\\ (b)   ($ f a b)))
      (define (curry* f g)  (\\ (a b) ($ f g a b)))
      (define (compose f g) (\\ (a)   ($ f ($ g a))))
    #+END_SRC

*** Свёртки и "развёртки":

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (define (foldl f a list)
          (typecase list
            (null a)
            (cons (foldl f ($ f a (head list)) (tail list)))))

      (define (foldr f a list)
          (typecase list
            (null a)
            (cons ($ f (head list) (foldr f a (tail list))))))

      (define (unfold f i p)
          (if ($ p i)
              (cons i '())
              (cons i (unfold f ($ f i) p))))

      (define fold foldl)
      (define my-reduce fold)
    #+END_SRC

*** Отображения и фильтрации:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      ;; map & filter
      (define (my-map f list) (foldr (\\ (x y) (cons ($ f x) y)) '() list))
      (define (filter p list) (foldr (\\ (x y) (if ($ p x) (cons x y) y)) '() list))
    #+END_SRC

*** Функции для списков на основе карринга и свёрток:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      ;; functions for lists
      (define (my-list &rest objs)         objs)
      (define (my-length list)             (fold (\\ (x y) (1+ x)) 0 list))
      (define (my-reverse list)            (fold (flip 'cons) '() list))
      (define (my-append list &rest lists) (fold (flip (curry* 'foldr 'cons)) list lists))
    #+END_SRC

*** Функции для чисел:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      ;; functions for numbers
      (define zero?                    (curry '= 0))
      (define positive?                (curry '< 0))
      (define negative?                (curry '> 0))
      (define (odd? number)            (= (mod number 2) 1))
      (define (even? number)           (= (mod number 2) 0))
      (define (my-max a &rest numbers) (fold (\\ (y z) (if (> y z) y z)) a numbers))
      (define (my-min a &rest numbers) (fold (\\ (y z) (if (< y z) y z)) a numbers))
      (define (summa &rest numbers)    (fold '+ 0 numbers))
      (define (product &rest numbers)  (fold '* 1 numbers))
    #+END_SRC

*** И для булевых чисел:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      ;; functions for booleans
      (define (my-and &rest list)   (fold 'and t list))
      (define (my-or &rest list)    (fold 'or nil list))
      (define (any? p &rest list)   (apply 'my-or (my-map p list)))
      (define (every? p &rest list) (apply 'my-and (my-map p list)))

    #+END_SRC

*** Многие другие функции представляются свёртками, например:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      ;; member & assoc
      (flet ((helper (p op)
               (\\ (a next) (if (and (not a) ($ p ($ op next))) next a))))

        (define (my-member object list &key (test 'equal))
            (fold (helper (curry test object) 'self) nil list))

        (define (my-assoc object alist &key (test 'equal))
            (fold (helper (curry test object) 'car) nil alist)))
    #+END_SRC

*** Свёртки для деревьев:

    Теперь, собственно, код для деревьев. Нужно заметить, что учитывая весь код для
    "абстракций", получается существенно меньше, чем при реализации "в лоб" (как у Грэхама,
    например).

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      ;; for (1 . (2 . 3)) trees

      (define (my-append a b)
          (append (if (atom a) (list a) a)
                  (if (atom b) (list b) b)))

      (define (fold-tree f g tree)
          (typecase tree
            (atom ($ f tree))
            (cons ($ g (fold-tree f g (head tree))
                     (fold-tree f g (tail tree))))))

      (define* (summa/tree tree) (fold-tree 'self '+))
      (define* (depth/tree tree) (fold-tree 'one 'max+1))
      (define* (flatten tree)    (fold-tree 'self 'my-append))

    #+END_SRC

** Другие утилиты

   #+NAME: f_util_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     ;; (defun my-range (n)
     ;;   (let ((i 0))
     ;;     #'(lambda ()
     ;;         (if (< i n) (incf i) nil))))

     ;; (let ((f (my-range 3)))
     ;;   (list
     ;;    (funcall f)
     ;;    (funcall f)
     ;;    (funcall f)
     ;;    (funcall f)
     ;;    (funcall f)
     ;; ))

     ;; (range 3)

     ;; (defmacro do-closure ((i clos) &body body)
     ;;   (let ((c (gensym)))
     ;;     `(let ((,c ,clos))
     ;;        (loop for ,i = (funcall ,c)
     ;;           while ,i do ,@body))))

     ;; (do-closure (i (my-range 100)) (print i))


     (declaim (inline zip))
     (defun zip (&rest args)
       "
     Zips the elements of @arg{args}.
     Example:
     @lisp
     > (zip '(2 3 4) '(a b c) '(j h c s))
     => ((2 A J) (3 B H) (4 C C))
     @end lisp
     "
       (apply #'map 'list #'list args))

     (defun symstuff (l)
       "From the Common Lisp Cookbook - http://cl-cookbook.sourceforge.net/macros.html
     Helper function to (build-symbol)"
       `(concatenate 'string
                     ,@(for (x :in l)
                            (cond ((stringp x)
                                   `',x)
                                  ((atom x)
                                   `',(format nil "~a" x))
                                  ((eq (car x) ':<)
                                   `(format nil "~a" ,(cadr x)))
                                  ((eq (car x) ':++)
                                   `(format nil "~a" (incf ,(cadr x))))
                                  (t
                                   `(format nil "~a" ,x))))))

     (defmacro build-symbol (&rest l)
       "From the Common Lisp Cookbook - http://cl-cookbook.sourceforge.net/macros.html"
       (let ((p (find-if (lambda (x) (and (consp x) (eq (car x) ':package)))
                         l)))
         (cond (p
                (setq l (remove p l))))
         (let ((pkg (cond ((eq (cadr p) 'nil)
                           nil)
                          (t `(find-package ',(cadr p))))))
           (cond (p
                  (cond (pkg
                         `(values (intern ,(symstuff l) ,pkg)))
                        (t
                         `(make-symbol ,(symstuff l)))))
                 (t
                  `(values (intern ,(symstuff l))))))))

     (defun remove-nth (n seq)
       "Remove nth element from sequence"
       (remove-if (constantly t) seq :start n :count 1))

     (defun make-hash (&rest keyvals)
       "Create a hash table given keys and values"
       (plist-hash-table keyvals))

     (defmacro make-hash* (&rest keyvals)
       "Make a hash table given key/value pairs, allowing use of prior key/val pairs in late r definitions"
       (loop while keyvals
          for k = (intern (symbol-name (pop keyvals)))
          for v = (pop keyvals)
          collect `(,k ,v) into letargs
          collect (make-keyword k) into objargs
          collect k into objargs
          finally (return
                    `(let* (,@letargs)
                       (make-hash ,@objargs)))))

     (defun maphash2 (fn ht)
       "Returns a hash-table with the results of the function of key & value as values"
       (let ((ht-out (make-hash-table
                      :test (hash-table-test ht)
                      :size (hash-table-size ht)
                      :rehash-size (hash-table-rehash-size ht)
                      :rehash-threshold (hash-table-rehash-threshold ht))))
         (maphash #'(lambda (k v)
                      (setf (gethash k ht-out) (funcall fn k v)))
                  ht)
         ht-out))

     (defun maphash-values2 (fn ht)
       "Returns a hash-table with the results of the function of value as values"
       (let ((ht-out (make-hash-table)))
         (maphash #'(lambda (k v) (setf (gethash k ht-out) (funcall fn v))) ht)
         ht-out))

     (defmacro swap (pl1 pl2)
       "Macro to swap two places"
       (let ((temp1-name (gensym)) ; don't clobber existing names
             (temp2-name (gensym)))
         `(let ((,temp1-name ,pl1)
                (,temp2-name ,pl2))
            (setf ,pl1 ,temp2-name)
            (setf ,pl2 ,temp1-name))))

     (defun print-hash-key-or-val (kv stream)
       (format stream (typecase kv
                        (keyword " :~a")
                        (string " \"~a\"")
                        (symbol " '~a")
                        (list " '~a")
                        (t " ~a")) kv))

     (defun printhash (h &optional (stream t))
       "Pretty print a hash table as :KEY VAL on separate lines"
       (format stream "#<HASH-TABLE~{~a~a~^~&~}>"
               (loop for k being the hash-keys in h using (hash-value v)
                  collect (print-hash-key-or-val k nil)
                  collect (print-hash-key-or-val v nil))))

     (defmacro lethash (keys h &body body)
       "Let form binding hash table entries to let variables names"
       (let ((ht (gensym)))
         `(let ((,ht ,h))
            (let ,(loop for key in keys
                     collect `(,key (gethash ,(make-keyword key) ,ht)))
              ,@body))))

     (defmacro with-keys (keys h &body body)
       "Make keys of hash table available to body for use & changable via setf"
       (let ((ht (gensym)))
         (loop for key in keys
            for newbody = (subst `(gethash ,(make-keyword key) ,ht) key body)
            then (subst `(gethash ,(make-keyword key) ,ht) key newbody)
            finally (return `(let ((,ht ,h))
                               ,@newbody)))))

     (defun linear-interpolation (ys xs x)
       "Linear interpolation: calculate y(x) at x given table of ys and xs. Also returns ind ex of lookup table interval. Works from first x to less than last x."
       (let* ((i (position x xs :test #'>= :from-end t))
              (x0 (elt xs i))
              (x1 (elt xs (1+ i)))
              (y0 (elt ys i))
              (y1 (elt ys (1+ i))))
         (+ y0 (* (- y1 y0) (- x x0) (/ (- x1 x0))))))

     (defun maptree (f tree)
       "Map a function on the leaves of a tree"
       (cond
         ((null tree) nil)
         ((atom tree) (funcall f tree))
         (t (cons (maptree f (car tree))
                  (maptree f (cdr tree))))))

     (defmethod diff ((l list))
       "Return list of the 1st differences of given list: l(1)-l(0),...,l(n)-l(n-1)"
         (loop for i below (1- (length l))
            for li in l
            collect (- (elt l (1+ i)) li)))

     (defmethod diff ((v vector))
       "Return vector of the 1st differences of given vector: v(1)-v(0),...,v(n)-v(n-1)"
       (let* ((n (length v))
              (v2 (make-array (1- n))))
         (dotimes (i (1- n))
           (setf (aref v2 i) (- (aref v (1+ i)) (aref v i))))
         v2))

     (defun slot-ref (obj slots)
       "Reference nested objects by a list of successive slot names. For example, (slot-ref  o 'foo 'bar 'baz) should return (slot-value (slot-value (slot-value o 'foo) 'bar) 'baz) "
       (cond
         ((atom slots) (slot-value obj slots))
         ((null (cdr slots)) (slot-value obj (car slots)))
         (t (slot-ref (slot-value obj (first slots)) (rest slots)))))

     (defun slot-ref-set (obj slots val)
       "Set nested object slot reference to new value"
       (cond
         ((atom slots) (setf (slot-value obj slots) val))
         ((null (cdr slots)) (setf (slot-value obj (car slots)) val))
         (t (slot-ref-set (slot-value obj (first slots)) (rest slots) val))))

     (defsetf slot-ref slot-ref-set)

     (defmacro bind-nested-slots (forms obj &body body)
       "For each form of (VAR SLOT1 SLOT2 ...) bind VAR to (NESTED-SLOT OBJ SLOT1 SLOT2 ...) "
       `(let ,(loop for form in forms
                 collect `(,(first form) (slot-ref ,obj ',(rest form))))
          ,@body))

     (defmacro defpfun (name args pargs &body body)
       "Define pandoric function given name, arguments, pandoric arguments,
     & body forms."
       `(setf (symbol-function ',name)
              (plambda ,args ,pargs
                       ,@body)))
   #+END_SRC

** Утилиты

   #+NAME: utility_file
   #+BEGIN_SRC lisp :tangle src/mod/hh/util.lisp :noweb tangle :exports code  :padline no :comments link
     (in-package #:moto)

     (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0")

     (defparameter *cookies*
       (list "portal_tid=1291969547067-10909"
             "__utma=189530924.115785001.1291969547.1297497611.1297512149.377"
             "__utmc=3521885"))

     (setf *drakma-default-external-format* :utf-8)

     (defun get-headers (referer)
       `(
         ("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
         ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
         ("Accept-Charset" . "utf-8")
         ("Referer" . ,referer)
         ;; ("Cookie" . ,(format nil "~{~a; ~}" *cookies*))
         ("Cookie" . "ad20c=2; ad17c=2; __utma=48706362.2093251633.1396569814.1413985658.1413990550.145; __utmz=48706362.1413926450.142.18.utmcsr=vk.com|utmccn=(referral)|utmcmd=referral|utmcct=/im; email=avenger-f%40yandex.ru; password=30e3465569cc7433b34d42baeadff18f; PHPSESSID=ms1rrsgjqvm3lhdl5af1aekvv0; __utmc=48706362; __utmb=48706362.5.10.1413990550")
         ))

     (defmacro web (to ot)
       (let ((x-to (append '(format nil) to))
             (x-ot (append '(format nil) ot)))
         `(let ((r (sb-ext:octets-to-string
                    (drakma:http-request ,x-to
                                         :user-agent *user-agent*
                                         :additional-headers (get-headers ,x-ot)
                                         :force-binary t)
                    :external-format :utf-8)))
            r)))

     (defmacro fnd (var pattern)
       `(multiple-value-bind (all matches)
            (ppcre:scan-to-strings ,pattern ,var)
          (let ((str (format nil "~a" matches)))
            (subseq str 2 (- (length str) 1)))))

     (defun merge-plists (&rest plists)
       "Merge all the given plists into a new plist. The new plist has all
     the keys from each plist, with values of keys in later lists
     overriding the values of the same keys in earlier plists.
     No particular order of key/value pairs is guaranteed.
     E.g.:
     > (merge-plists '(:a 1 :b 2) '(:a 3 :c 4) '(:d 5))
     (:D 5 :C 4 :A 3 :B 2)"
     (let ((result (copy-list (first plists))))
       (dolist (plist (rest plists))
         (do* ((prop (first plist) (first plist))
               (value (second plist) (second plist))
               (oldpl plist plist)
               (plist plist (cddr plist)))
              ((not oldpl))
           (setf (getf result prop) value)))
       result))

     ;; eval-always

     (defmacro eval-always (&body body)
       "Wrap <_:arg body /> in <_:fun eval-when /> with all keys \(compile, load and execute) mentioned"
       `(eval-when (:compile-toplevel :load-toplevel :execute)
          ,@body))

     ;; #` syntax

     ;; (eval-always
     ;;   (defun |#`-reader| (stream char arg)
     ;;     "Literal syntax for zero/one/two argument lambdas.
     ;; Use @ as the function's argument, % as the second.
     ;; Examples:
     ;; CL-USER> #`(+ 2 @)
     ;; \(lambda (&optional x y)
     ;;    (+ 2 x))
     ;; CL-USER>  #`((1+ @) (print @))
     ;; \(lambda (&optional x y)
     ;;    (1+ x)
     ;;    (print x))
     ;; CL-USER> #`(+ 1 2)
     ;; \(lambda (&optional x y)
     ;;    (+ 1 2))
     ;; CL-USER>  #`(+ @ %)
     ;; \(lambda (&optional x y)
     ;;    (+ x y))
     ;; "
     ;;     (declare (ignore char arg))
     ;;     (let ((sexp (read stream t nil t))
     ;;           (x (gensym "X"))
     ;;           (y (gensym "Y")))
     ;;       `(lambda (&optional ,x ,y)
     ;;          (declare (ignorable ,x)
     ;;                   (ignorable ,y))
     ;;          ,@(subst y '%
     ;;                   (subst x '@
     ;;                          (if (listp (car sexp))
     ;;                              sexp
     ;;                              (list sexp)))))))
     ;;   ;; set #`
     ;;   (set-dispatch-macro-character #\# #\` #'|#`-reader|))

     ;; anaphoric

     (eval-always
      (defmacro if-it (test then &optional else)
        "Like IF. IT is bound to TEST."
        `(let ((it ,test))
           (if it ,then ,else))))

     (eval-always
      (defmacro when-it (test &body body)
        "Like WHEN. IT is bound to TEST."
        `(let ((it ,test))
           (when it
             ,@body))))

     (eval-always
      (defmacro and-it (&rest args)
        "Like AND. IT is bound to the value of the previous AND form."
        (cond ((null args) t)
              ((null (cdr args)) (car args))
              (t `(when-it ,(car args) (and-it ,@(cdr args)))))))

     (eval-always
      (defmacro dowhile-it (test &body body)
        "Like DOWHILE. IT is bound to TEST."
        `(do ((it ,test ,test))
             ((not it))
           ,@body)))

     ;; (eval-always
     ;;  (defmacro cond-it (&body body)
     ;;    "Like COND. IT is bound to the passed COND test."
     ;;    `(let (it)
     ;;       (cond
     ;;         ,@(mapcar #``((setf it ,(car @)) ,(cadr @))
     ;;                   ;; uses the fact, that SETF returns the value set
     ;;                   body)))))

     ;; maybe

     (defmacro maybecall (val &rest funs)
       `(and-it ,val
                ,@(mapcar (lambda (fun)
                            `(funcall ,fun it))
                          funs)))

     (defmacro maybe (form)
       "Return a value, returned by a <_:arg form /> or nil, if <_:class error /> is signalled"
       `(restart-case
            (handler-bind ((error #'(lambda (c)
                                      (declare (ignore condition))
                                      (invoke-restart 'skip))))
              ,form)
          (skip () nil)))
   #+END_SRC

** Глобальные определения

   #+NAME: globals
   #+BEGIN_SRC lisp :tangle src/mod/hh/globals.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:moto)

     ;; clear db
     ;; (drop '("profile" "vacancy"))
   #+END_SRC

** Сущности и автоматы

   Соберем все сущности и автоматы

   #+NAME: entity_and_automates
   #+BEGIN_SRC lisp :tangle src/mod/hh/entityes.lisp :noweb tangle :padline no :comments link
     (in-package #:moto)
     <<gen_automat("vacancy", "вакансии", vacancy_flds, vacancy_state)>>
   #+END_SRC

   #+NAME: gen_automat
   #+BEGIN_SRC emacs-lisp :var name="" docstring="" flds='() states='() :exports none
     (let ((result))
       (push (format "(define-automat %s \"Автомат %s\"" name docstring) result)
       (push (gen-fields flds) result)
       (push (gen-states states) result)
       (push (gen-actions states) result)
       (push ")\n" result)
       (mapconcat 'identity (reverse result) ""))
   #+END_SRC
