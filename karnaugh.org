#+HTML_HEAD: <!-- -*- fill-column: 87 -*- -->
#+HTML_HEAD: <!-- org-toggle-inline-images -->

#+TITLE: Karnaugh

#+INFOJS_OPT: view:overview toc:nil

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="/css/css.css" />
#+END_HTML

* Имитация цифровых электронных схем

  Цифровые электронные схемы строятся путем соединения простых элементов, таких как:
  - инвертор
  - и - элемент
  - или - элемент
  - или-не - элемент
  Хотя поведение этих составляющих элементов примитивно, сети, из них собранные, могут
  обладать весьма сложным поведением. Компьютерная имитация проектируемых электронных
  схем служит важным инструментом для инженеров-специалистов по цифровым системам.

  Cпроектируем систему для имитационного моделирования цифровых схем. Система эта будет
  служить примером программ особого вида, называемых =имитация, управляемая событиями=
  (event-driven simulation), в которых действия (события) вызывают другие события,
  которые происходят спустя некоторое время и при этом в свою очередь вызывают события,
  и так далее.

  Наша вычислительная модель цифровой схемы будет состоять из объектов, соответствующих
  элементарным компонентам, из которых строится схема. Имеются =провода=, несущие
  =цифровые сигналы=. В каждый момент цифровой сигнал может иметь только одно из двух
  возможных значений, 0 или 1.

  Кроме того, имеются различные виды =функциональных элементов=, которые соединяют
  провода, несущие входные сигналы, с выходными проводами. Такие элементы порождают
  выходные сигналы, вычисляя их на основе входных сигналов.

  Выходной сигнал задерживается на время, зависящее от типа функционального
  элемента. Мы не пренебрегаем задержкой в нашей функциональной модели, т.к. она не
  только отражает причинность реальности, но и служит защитой от зацикливания внутри
  вызывающих друг друга событий.

  Например, =инвертор= (inverter) — элементарный функциональный элемент, который
  обращает свой входной сигнал. Если входной сигнал инвертора становится 0, то на одну
  инверторную задержку позже сигнал на выходе станет равен 1. Если входной сигнал
  станет 1, то на инверторную задержку позже на выходе появится 0.

  #+BEGIN_EXAMPLE

             |\
             | \
    ---------+  o----
             | /
             |/

  #+END_EXAMPLE

  =И-элемент= (and-gate) имеет два входа и один выход. Он обеспечивает на выходе
  сигнал, равный =логическому И= от входов. Это означает, что если оба входных сигнала
  становятся равными 1, то одну И-задержку спустя И-элемент заставит свой выходной
  сигнал стать 1; в противном случаена выходе будет 0.

  #+BEGIN_EXAMPLE
              ___
    _________|   `-.
             |      \_______
    _________|      /
             |___,-'

  #+END_EXAMPLE


  =ИЛИ-элемент= (or-gate) представляет собой подобный же элементарный функциональный
  элемент, который обеспечивает на выходе сигнал, равный =логическому ИЛИ= своих
  входов. А именно, выходной сигнал станет равен 1, если хотя бы один из входных
  сигналов окажется 1; в противном случае на выходе будет 0.

  #+BEGIN_EXAMPLE
            ___
    -------\   `-._
            \      `.______
            /     _,'
    -------/___,-'

  #+END_EXAMPLE

  Соединяя элементарные функции, можно получать более сложные. Для этого надо
  подсоединять выходы одних функциональных элементов ко в ходам других. Например, схема
  =полусумматора= (half-adder) состоит из ИЛИ-элемента, двух И-элементов и
  инвертора. Полусумматор получает два входа, A и B, и имеет два выхода, S и C.

  #+BEGIN_EXAMPLE

                ____
    A ----+-----\   `-._    D       ___
          |      \      `._________|   `-.
          |      /     _,'         |      \_______ S
    B ----|--+--/___,-'        E   |      /
          |  |               +-----|___,-'
          |  |               o
          |  |               |
          |  |              / \
          |  |   ___       /___\
          +--|--|   `-.      |
             |  |      \_____|____________________ C
             |  |      /
             +--|___,-'

  #+END_EXAMPLE


  S становится 1, когда ровно один из сигналов A и B равен 1, а C тогда, когда и A, и B
  равны 1. Из схемы можно видеть, что по причине задержек выходные сигналы могут
  генерироваться в разное время. Отсюда происходят многие сложности в проектировании
  цифровых схем.

  [[file:./img/half-adder.png]]

  Теперь мы построим программу для имитации цифровых логических схем, которые мы хотим
  изучать. Программа будет строить вычислительные объекты, моделирующие провода,
  которые "содержат" сигналы. Функциональные элементы будут моделироваться процедурами,
  которые обеспечивают нужное отношение между сигналами.

  Одним из базовых элементов нашей имитации будет процедура make-wire, которая
  порождает провода. Например, мы можем создать шесть проводов так:

  #+BEGIN_EXAMPLE
    (defparameter *a* (make-instance 'wire))
    (defparameter *b* (make-instance 'wire))
    (defparameter *c* (make-instance 'wire))
    (defparameter *d* (make-instance 'wire))
    (defparameter *e* (make-instance 'wire))
    (defparameter *s* (make-instance 'wire))
  #+END_EXAMPLE

  Мы подсоединяем функциональный элемент к проводу во время вызова процедуры, которая
  создает данный вид элемента. Аргументами порождающей процедуры служат провода,
  подсоединяемые к элементу. Например, если мы умеем создавать И-элементы, ИЛИ-элементы
  и инверторы, мы можем собрать полусумматор:

  #+BEGIN_EXAMPLE
    (or-gate *a* *b* *d*)
    (and-gate *a* *b* *c*)
    (inverter *c* *e*)
    (and-gate *d* *e* *s*)
  #+END_EXAMPLE

  Даже лучше того, можно присвоить этой операции имя, определив процедуру half-adder,
  конструирующую схему, используя четыре внешних провода, которые нужно подсоединить к
  полусумматору:

  #+NAME: half_adder
  #+BEGIN_SRC lisp
    (defun half-adder (a b s c coord-x coord-y
                       &key (d (make-instance 'wire)) (e (make-instance 'wire)))
      (list
       (or-gate a b d (+ coord-x 15) (+ coord-y 0))
       (and-gate a b c (+ coord-x 0) (+ coord-y 50))
       (inverter c e (+ coord-x 90) (+ coord-y 50))
       (and-gate d e s (+ coord-x 145) (+ coord-y 6))))
  #+END_SRC

  Преимущество этого определения в том, что теперь мы можем использовать =half-adder=
  как строительный блок при создании более сложных схем. Например, сумматор
  (full-adder), состоящий из двух полусумматоров и ИЛИ-элемента.

  [[file:./img/full-adder.png]]

  Сумматор можно сконструировать так:

  #+NAME: full_adder
  #+BEGIN_SRC lisp
    (defun full-adder (a b c sum c-out coord-x coord-y
                       &key
                         (s (make-instance 'wire))
                         (c1 (make-instance 'wire))
                         (c2 (make-instance 'wire))
                         (d1 (make-instance 'wire))
                         (e1 (make-instance 'wire))
                         (d2 (make-instance 'wire))
                         (e2 (make-instance 'wire)))
      (append
       (half-adder b c s c1 coord-x (+ 0 coord-y) :d d1 :e e1)
       (half-adder a s sum c2 (+ coord-x 250) coord-y :d d2 :e e2)
       (list
        (or-gate c2 c1 c-out 390 150))))
  #+END_SRC

  Определив full-adder как процедуру, мы можем ее использовать как строительный блок
  для еще более сложных схем. В сущности, наша имитация дает инструмент, с помощью
  которого строится язык описания схем. Можно сказать, что элементарные функциональные
  элементы являются примитивами языка, связывание их проводами представляет собой
  средство комбинирования, а определение шаблонных схем в виде процедур служит
  средством абстракции.

* Элементарные функциональные элементы

  Элементарные функциональные элементы изображают «силы», через посредство которых
  изменение сигнала в одном проводе влечет изменение сигнала в других проводах. Для
  построения функциональных элементов мы будем пользоваться следующими операциями над
  проводами:

  - (get-signal =провод= ) возвращает текущее значение сигнала в проводе.
  - (set-signal =провод= =новое-значение= ) заменяет значение сигнала в проводе на указанное
  - (add-action =провод= =процедура без аргументов= ) указывает, чтобы
    процедура-аргумент вызывалась каждый раз, когда сигнальный провод изменяет
    значение. Такие процедуры служат передаточным механизмом, с помощью которого
    изменение значения сигнала в одном проводе передается другим проводам. В
    дополнение, мы будем пользоваться процедурой =after-delay=, которая принимает
    значение задержки и процедуру. Она выполняет процедуру после истечения задержки.

  При помощи этих процедур можно определить элементарные функции цифровой логики. Чтобы
  соединить вход с выходом через инвертор, мы используем =add-action= и ассоциируем со
  входным проводом процедуру, которая будет вызываться всякий раз, когда сигнал на
  входе элемента изменит значение. Процедура вычисляет =logical-not= (логическое
  отрицание) входного сигнала, а затем, переждав inverter-delay, устанавливает выходной
  сигнал в новое значение:

  #+NAME: inverter
  #+BEGIN_SRC lisp
    (defun logical-not (s)
      (cond ((equal s 0) 1)
            ((equal s 1) 0)
            (t (err "logical not error signal"))))

    (defun inverter (input output coord-x coord-y)
      (let* ((obj (make-instance 'not-elt :base (make-point :x coord-x :y coord-y)))
             (x (point-x (base obj)))
             (y (point-y (base obj))))
        (setf (inputs obj)
              (list (make-inout
                     :coord (make-point :x x :y (+ y 15))
                     :is-out nil
                     :wire (name input))))
        (setf (outputs obj)
              (list (make-inout
                     :coord (make-point :x (+ x 55) :y (+ y 15))
                     :is-out t
                     :wire (name output))))
        (flet ((invert-input ()
                 (let ((new-value (logical-not (get-signal input))))
                   (after-delay *the-agenda* *inverter-delay*
                                (lambda ()
                                  (set-signal output new-value))))))
          (add-action input #'invert-input))
        obj))
  #+END_SRC

  И-элемент устроен немного сложнее. Процедура-действие должна вызываться, когда
  меняется любое из значений на входе. Она при этом через процедуру, подобную
  logical-not, вычисляет logical-and (логическое И) значений сигналов на входных
  проводах, и затем требует, чтобы изменение значения выходного провода произошло
  спустя задержку длиной в and-gate-delay.

  #+NAME: and-gate
  #+BEGIN_SRC lisp
    (defun logical-and (a b)
      (cond ((and (equal a 1) (equal b 1)) 1)
            ((and (equal a 0) (equal b 1)) 0)
            ((and (equal a 1) (equal b 0)) 0)
            ((and (equal a 0) (equal b 0)) 0)
            (t (err "logical-and error signal"))))

    (defun and-gate (a1 a2 output coord-x coord-y)
      (let* ((obj (make-instance 'and-elt :base (make-point :x coord-x :y coord-y)))
             (x (point-x (base obj)))
             (y (point-y (base obj))))
        (setf (inputs obj)
              (list (make-inout
                     :coord (make-point :x x :y (+ y 09))
                     :is-out nil
                     :wire (name a1))
                    (make-inout
                     :coord (make-point :x x :y (+ y 21))
                     :is-out nil
                     :wire (name a2))))
        (setf (outputs obj)
              (list (make-inout
                     :coord (make-point :x (+ x 55) :y (+ y 15))
                     :is-out t
                     :wire (name output))))
        (flet ((and-action-procedure ()
                 (let ((new-value (logical-and (get-signal a1) (get-signal a2))))
                   (after-delay *the-agenda*  *and-gate-delay*
                                (lambda ()
                                  (set-signal output new-value))))))
          (add-action a1 #'and-action-procedure)
          (add-action a2 #'and-action-procedure))
        obj))
  #+END_SRC

  Аналогичным образом определим ИЛИ-элемент:

  #+NAME: or-gate
  #+BEGIN_SRC lisp
    (defun logical-or (a b)
      (cond ((and (equal a 1) (equal b 1)) 1)
            ((and (equal a 0) (equal b 1)) 1)
            ((and (equal a 1) (equal b 0)) 1)
            ((and (equal a 0) (equal b 0)) 0)
            (t (err "logical-or error signal"))))

    (defun or-gate (a1 a2 output coord-x coord-y)
      (let* ((obj (make-instance 'or-elt :base (make-point :x coord-x :y coord-y)))
             (x (point-x (base obj)))
             (y (point-y (base obj))))
        (setf (inputs obj)
              (list (make-inout
                     :coord (make-point :x x :y (+ y 09))
                     :is-out nil
                     :wire (name a1))
                    (make-inout
                     :coord (make-point :x x :y (+ y 21))
                     :is-out nil
                     :wire (name a2))))
        (setf (outputs obj)
              (list (make-inout
                     :coord (make-point :x (+ x 55) :y (+ y 15))
                     :is-out t
                     :wire (name output))))
        (flet ((or-action-procedure ()
                 (let ((new-value (logical-or (get-signal a1) (get-signal a2))))
                   (after-delay *the-agenda* *or-gate-delay*
                                (lambda ()
                                  (set-signal output new-value))))))
          (add-action a1 #'or-action-procedure)
          (add-action a2 #'or-action-procedure))
        obj))
  #+END_SRC

* Представление проводов

  Провод в нашей имитации будет объектом с тремя переменными:
  - имя провода, для его отображения на схеме
  - значение сигнала =signal-value= (вначале равное 0)
  - набор процедур-действий =action-procedures=, подлежащих исполнению, когда сигнал
    изменяется.

  #+NAME: wire_class
  #+BEGIN_SRC lisp
    (defclass wire ()
      ((name               :initarg :name               :accessor name          :initform (gensym "WIRE-"))
       (signal-value       :initarg :signal-value       :accessor signal-value  :initform 0)
       (action-procedures  :initarg :action-procedures  :accessor action-procedures :initform nil)))
  #+END_SRC

  Метод =get-signal= возвращает текущее значение сигнала в проводе:

  #+NAME: wire_get_signal
  #+BEGIN_SRC lisp
    (defmethod get-signal ((obj wire))
      (signal-value obj))
  #+END_SRC

  Метод =set-signal= проверяет, отличается ли новое значение сигнала в проводе от
  старого. Если да, то он запускает все процедуры-действия:

  #+NAME: wire_set_signal
  #+BEGIN_SRC lisp
    (defmethod set-signal ((obj wire) new-value)
      (if (not (equal (signal-value obj) new-value))
          (progn
            (setf (signal-value obj) new-value)
            (loop :for procedure :in (action-procedures obj) :do (funcall procedure)))))
  #+END_SRC

  Метод =add-action= добавляет процедуру к списку действий, а затем один раз запускает
  добавленную процедуру, чтобы сделать инициализацию:

  #+NAME: wire_add_action
  #+BEGIN_SRC lisp
    (defmethod add-action ((obj wire) procedure)
      (setf (action-procedures obj)
            (append (action-procedures obj) (list procedure)))
      (funcall procedure))
  #+END_SRC

* Представление очередей

  Очередь (=queue=) представляет собой последовательность, в которую можно добавлять
  элементы с одного конца (=rear=) и убирать с другого (=front=).

  - конструктор (make-queue) возвращает пустую очередь
  - два селектора: =empty-queue= проверяет, пуста ли очередь, =front-queue= возвращает
    объект, находящийся в голове очереди. Если очередь пуста, он сообщает об
    ошибке. Очередь не модифицируется.
  - два мутатора: =insert-queue= вставляет элемент в
    хвост очереди и возвращает в качестве значения измененную очередь; =delete-queue!=
    удаляет элемент в голове очереди и возвращает в качестве значения измененную
    очередь. Если перед уничтожением элемента очередь оказывается пустой, выводится
    сообщение об ошибке.

  Поскольку очередь есть последовательность элементов, ее, разумеется, можно было бы
  представить как обыкновенный список; головой очереди был бы =car= этого списка, вставка
  элемента в очередь сводилась бы к добавлению нового элемента в конец списка, а
  уничтожение элемента из очереди состояло бы просто во взятии =cdr= списка.

  Однако такая реализация неэффективна, поскольку для вставки элемента нам пришлось бы
  просматривать весь список до конца. Поскольку единственный доступный нам метод
  просмотра списка — это последовательное применение =cdr=, такой просмотр требует Θ(n)
  шагов для очереди с n членами.

  Простое видоизменение спискового представления преодолевает этот недостаток, позволяя
  нам реализовать операции с очередью так, чтобы все они требовали Θ(1) шагов; то есть,
  чтобы число шагов алгоритма не зависело от длины очереди.

  Сложность со списковым представлением возникает из-за необходимости искать конец
  списка. Искать приходится потому, что, хотя стандартный способ представления списка в
  виде цепочки пар дает нам указатель на начало списка, легкодоступного указателя на
  конец он не дает. Модификация, обходящая этот недостаток, состоит в том, чтобы
  представлять очередь в виде списка, и держать еще дополнительный указатель на его
  последнюю пару.

  В таком случае, когда требуется вставить элемент, мы можем просто посмотреть на этот
  указатель и избежать за счет этого просмотра всего списка. Очередь, таким образом,
  представляется в виде пары указателей, front-ptr и rear-ptr, которые обозначают,
  соответственно, первую и последнюю пару обыкновенного списка.

  #+NAME: queue_class
  #+BEGIN_SRC lisp
    (defclass queue ()
      ((front-ptr   :initarg :front-ptr   :accessor front-ptr :initform nil)
       (rear-ptr    :initarg :rear-ptr    :accessor rear-ptr  :initform nil)))
  #+END_SRC

  Теперь можно реализовать сами операции над очередью. Очередь будет считаться пустой,
  если ее головной указатель указывает на пустой список:

  #+NAME: queue_empty
  #+BEGIN_SRC lisp
    (defmethod empty ((obj queue))
      (null (front-ptr obj)))
  #+END_SRC

  При обращении к элементу в голове очереди мы возвращаем car пары, на которую
  указывает головной указатель:

  #+NAME: queue_front
  #+BEGIN_SRC lisp
    (defmethod front ((obj queue))
      (if (empty obj)
          (err "front-queue: empty queue")
          (car (front-ptr obj))))
  #+END_SRC

  Чтобы вставить элемент в конец очереди, первым делом мы создаем новую пару, =car=
  которой содержит вставляемый элемент, а =cdr= — пустой список. Если очередь была
  пуста, мы перенаправляем на эту пару и головной, и хвостовой указатели. В противном
  случае, мы изменяем последнюю пару очереди так, чтобы следующей была новая пара, и
  хвостовой указатель тоже перенаправляем на нее же:

  #+NAME: queue_insert
  #+BEGIN_SRC lisp
    (defmethod insert ((obj queue) item)
      (let ((new-pair (cons item '())))
        (cond ((empty obj)
               (progn
                 (setf (front-ptr obj) new-pair)
                 (setf (rear-ptr obj) new-pair)))
              (t
               (progn
                 (setf (cdr (rear-ptr obj)) new-pair)
                 (setf (rear-ptr obj) new-pair))))
        obj))
  #+END_SRC

  Чтобы уничтожить элемент в голове очереди, мы просто переставляем головной указатель
  на второй элемент очереди, а его можно найти в =cdr= первого элемента:

  #+NAME: queue_del
  #+BEGIN_SRC lisp
    (defmethod del ((obj queue))
      (cond ((empty obj) (err "delete-queue: empty"))
            (t (setf (front-ptr obj) (cdr (front-ptr obj)))))
      obj)
  #+END_SRC

  В случае, если первый элемент — одновременно и последний, после его уничтожения
  головной указатель окажется пустым списком, и это будет означать, что очередь пуста;
  нам незачем заботиться о хвостовом ука зателе, который по-прежнему будет указывать на
  уничтоженный элемент, поскольку =empty= смотрит только на голову.

* План действий

  Теперь для завершения модели нам остается только написать =after-delay=.

  Здесь идея состоит в том, чтобы организовать структуру данных под названием план
  действий (agenda), где будет храниться расписание того, что нам надо сделать. Для
  планов действий определены следующие операции:

  - =empty-agenda= - истинно, если план пуст.
  - =first-agenda-item= - возвращает первый элемент плана.
  - =remove-first-agenda-item= - модифицирует план, убирая из него первый элемент.
  - =add-to-agenda= модифицирует план, добавляя процедуру-действие, которую нужно
    запустить в указанное время.
  - current-time возвращает текущее время модели.

  Сам по себе план действий является одномерной таблицей временных отрезков. Сегменты
  отсортированы в порядке возрастания времени. В дополнение к этому мы храним текущее
  время (current time) (т. е. время последнего исполненного действия) в поле
  плана. Свежесозданный план не содержит временных отрезков, а его текущее время равно
  нулю:

  #+NAME: agenda_class
  #+BEGIN_SRC lisp
    (defclass agenda ()
      ((current-time  :initarg :current-time  :accessor current-time  :initform 0)
       (segments      :initarg :segments      :accessor segments      :initform nil)))
  #+END_SRC

  План пуст, если в нем нет ни одного временного отрезка:

  #+NAME: agenda_empty
  #+BEGIN_SRC lisp
    (defmethod empty ((obj agenda))
      (null (segments obj)))
  #+END_SRC

  Экземпляр плана, которым мы будем пользоваться, будет обозначаться =the-agenda=.

  #+NAME: agenda_object
  #+BEGIN_SRC lisp
    (defparameter *the-agenda* (make-instance 'agenda))
  #+END_SRC

  Процедура =after-delay= добавляет новый элемент в план:

  #+NAME: after_delay
  #+BEGIN_SRC lisp
    (defmethod after-delay ((obj agenda) delay action)
      (add-to-agenda obj
                     (+ delay (current-time obj))
                     action))
  #+END_SRC

  Имитация управляется процедурой =propagate=, которая работает с объектом, по очереди
  выполняя процедуры, содержащиеся в плане. В общем случае, при работе модели в план
  добавляются новые элементы, =propagate= продолжает работу, пока план не становится
  пустым:

  #+NAME: propagate
  #+BEGIN_SRC lisp
    (defmethod propagate ((obj agenda))
      (if (empty obj)
          (return-from propagate nil)
          ;; else
          (let ((first-item (first-agenda-item obj)))
            (funcall first-item)
            (remove-first-agenda-item obj)
            (propagate obj))))
  #+END_SRC

  Наконец, мы описываем детали структуры данных плана действий, которая хранит
  процедуры, предназначенные для исполнения в будущем.

  План состоит из временных отрезков. Каждый временной отрезок является структурой
  состоящей из числа (значения времени) и очереди, которая содержит процедуры,
  предназначенные к исполнению в этот временной отрезок.

  #+NAME: time_segment_class
  #+BEGIN_SRC lisp
    (defclass time-segment ()
      ((timepoint  :initarg :timepoint  :accessor timepoint  :initform 0)
       (queue      :initarg :queue     :accessor queue      :initform nil)))
  #+END_SRC

  Для того, чтобы добавить в план новое действие, прежде всего мы проверяем, не пуст ли
  план. Если пуст, мы создаем для действия новый отрезок и вставляем его в план. Иначе
  мы просматриваем план, глядя на времена отрезков. Если мы находим отрезок с
  назначенным временем, мы добавляем действие к соответствующей очереди. Если же мы
  обнаруживаем время, большее, чем назначенное, мы вставляем новый отрезок перед
  текущим. Если мы доходим до конца плана, мы вставляем новый отрезок в конец.

  #+NAME: agenda_add
  #+BEGIN_SRC lisp
    (defun belongs-before (time segments)
      (or (null segments)
          (< time (timepoint (car segments)))))

    (defun make-new-time-segment (time action)
      (let ((que (make-instance 'queue)))
        (insert que action)
        (make-instance 'time-segment :timepoint time :queue que)))

    (defun add-to-segments (segments time action)
      (if (equal (timepoint (car segments)) time)
          (insert (queue (car segments)) action)
          ;; else
          (let ((rest (cdr segments)))
            (if (belongs-before time rest)
                (setf (cdr segments)
                      (append (cdr segments)
                              (list (make-new-time-segment time action))))
                ;; else
                (add-to-segments rest time action)))))

    (defmethod add-to-agenda ((obj agenda) time action)
      (let ((segments (segments obj)))
        (if (belongs-before time segments)
            (setf (segments obj)
                  (append (segments obj)
                          (list (make-new-time-segment time action))))
            ;; else
            (add-to-segments segments time action))))
  #+END_SRC

  Процедура, которая убирает из плана первый элемент, уничтожает элемент в начале
  очереди первого отрезка времени. Если в результате отрезок становится пустым, мы
  изымаем его из списка отрезков.

  #+NAME: agenda_remove_first_item
  #+BEGIN_SRC lisp
    (defmethod remove-first-agenda-item ((obj agenda))
      (let ((segments (segments obj)))
        (when (null segments)
          (err "remove-first-agenda-item: empty segments"))
        (let ((que (queue (car segments))))
          (del que)
          (if (empty que)
              (setf (segments obj)
                    (cdr (segments obj)))))))
  #+END_SRC

  Первый элемент плана находится в начале очереди в первом временном отрезке. Каждый
  раз, когда мы обращаемся к такому элементу, мы обновляем текущее время. Таким
  образом, текущее время всегда будет совпадать с временем последнего обработанного
  действия. Благодаря тому, что это время хранится в поле плана, оно всегда доступно,
  даже если соответствующий отрезок времени был уничтожен:

  #+NAME: agenda_first_item
  #+BEGIN_SRC lisp
    (defmethod first-agenda-item ((obj agenda))
      (if (null (segments obj))
          (err "agenda empty")
          (let ((first-seg (car (segments obj))))
            (setf (current-time obj) (timepoint first-seg))
            (front (queue first-seg)))))
  #+END_SRC

* Пример работы модели

  Следующая процедура, которая навешивает на провод «тестер», показывает имитационную
  модель в действии. Тестер говорит проводу, что, каждый раз, когда сигнал изменяет
  значение, нужно напечатать новое значение сигнала, а также текущее время и имя
  провода:

  #+NAME: probe
  #+BEGIN_SRC lisp
    (defun probe (name wire)
      (add-action wire #'(lambda ()
                           (format t "~%name: ~A; time: ~A; value: ~A"
                                   name
                                   (current-time *the-agenda*)
                                   (get-signal wire)))))
  #+END_SRC

  Сначала мы инициализируем план действий и указываем задержки для элементарных
  функциональных элементов:

  #+NAME: init
  #+BEGIN_SRC lisp
    (defparameter *the-agenda* (make-instance 'agenda))
    (defparameter *inverter-delay* 2)
    (defparameter *and-gate-delay* 3)
    (defparameter *or-gate-delay* 5)
  #+END_SRC

  Затем мы создаем четыре провода и к двум из них подсоединяем тестеры:

  #+NAME: components
  #+BEGIN_SRC lisp
    (defparameter *input-1* (make-instance 'wire :name '|a|))
    (defparameter *input-2* (make-instance 'wire :name '|b|))
    (defparameter *sum* (make-instance 'wire :name '|sum|))
    (defparameter *carry* (make-instance 'wire :name '|cf|))

    (probe 'sum *sum*)
    (probe 'carry *carry*)
  #+END_SRC

  Затем мы связываем провода, образуя схему полусумматора (как на рис. 3.25),
  устанавливаем сигнал на входе =input-1= в 1, и запускаем модель:

  #+NAME: components
  #+BEGIN_SRC lisp
    (half-adder *input-1* *input-2* *sum* *carry*)
    (set-signal *input-1* 1)
    (propagate *the-agenda*)

    (set-signal *input-2* 1)
    (propagate *the-agenda*)

    ;; (mapcar #'(lambda (x)
    ;;             (list (timepoint x) (front-ptr (queue x))))
    ;;         (segments *the-agenda*))
  #+END_SRC

* START Визуализация

  Чтобы визуализировать функциональный элемент, нужно иметь объект, который будет
  содержать координаты изображения и всех его входов и выходов. Базовая координата -
  двухэлементная структура, содержащая X и Y.

  В списках входов и выходов каждый элемент - структура =inout=, состоящая из
  координат, типа (вход или выход) и имени провода, с которым связан вывод:

  #+NAME: vis_class
  #+BEGIN_SRC lisp
    (defstruct point
      (x 0 :type integer)
      (y 0 :type integer))

    (defstruct inout
      (coord   nil :type point)
      (is-out  nil :type boolean)
      (wire    nil :type symbol))

    (defclass vis ()
      ((base     :initarg :base     :accessor base    :type point)
       (inputs   :initarg :inputs   :accessor inputs  :type list-of-inout :initform nil)
       (outputs  :initarg :outputs  :accessor outputs :type list-of-inout :initform nil)))
  #+END_SRC

  От этого класса мы можем наследовать классы функциональных элементов, которые
  отличаются только методами:
  - Метод =get-drawer= возвращает функцию отрисовки, которая принимает =canvas=, на
    котором рисует элемент.

  #+NAME: elt_class_drivers
  #+BEGIN_SRC lisp
    (defclass and-elt (vis) ())
    (defclass or-elt  (vis) ())
    (defclass not-elt (vis) ())

    (defmethod get-drawer ((obj and-elt))
      (let ((x (point-x (base obj)))
            (y (point-y (base obj))))
        (lambda (canvas)
          (create-line canvas `(,(+ x 10) ,(+ y 0) ,(+ x 30) ,(+ y 0)))
          (create-line canvas `(,(+ x 10) ,(+ y 0) ,(+ x 10) ,(+ y 30)))
          (create-line canvas `(,(+ x 10) ,(+ y 30) ,(+ x 30) ,(+ y 30)))
          (create-arc canvas (+ x 15) y (+ x 45) (+ y 30) :start -90 :extent 180 :style "arc")
          (create-line canvas `(,(+ x 0) ,(+ y 09) ,(+ x 10) ,(+ y 09)))
          (create-oval canvas (+ x -1) (+ y 08) (+ x 1) (+ y 10))
          (create-line canvas `(,(+ x 0) ,(+ y 21) ,(+ x 10) ,(+ y 21)))
          (create-oval canvas (+ x -1) (+ y 20) (+ x 1) (+ y 22))
          (create-line canvas `(,(+ x 45) ,(+ y 15) ,(+ x 55) ,(+ y 15)))
          (create-oval canvas (+ x 54) (+ y 14) (+ x 56) (+ y 16))
          (create-text canvas (+ x 15) (+ y 7) "and"))))

    (defmethod get-drawer ((obj or-elt))
      (let ((x (point-x (base obj)))
            (y (point-y (base obj))))
        (lambda (canvas)
          (create-line canvas `(,(+ x 10) ,(+ y 0) ,(+ x 20) ,(+ y 0)))
          (create-line canvas `(,(+ x 10) ,(+ y 0) ,(+ x 10) ,(+ y 30)))
          (create-line canvas `(,(+ x 10) ,(+ y 30) ,(+ x 20) ,(+ y 30)))
          (create-arc canvas (+ x -15) (+ y 00) (+ x 45) (+ y 60) :start 30 :extent 60 :style "arc")
          (create-arc canvas (+ x -15) (+ y 30) (+ x 45) (- y 30) :start -30 :extent -60 :style "arc")
          (create-line canvas `(,(+ x 0) ,(+ y 09) ,(+ x 10) ,(+ y 09)))
          (create-oval canvas (+ x -1) (+ y 08) (+ x 1) (+ y 10))
          (create-line canvas `(,(+ x 0) ,(+ y 21) ,(+ x 10) ,(+ y 21)))
          (create-oval canvas (+ x -1) (+ y 20) (+ x 1) (+ y 22))
          (create-line canvas `(,(+ x 40) ,(+ y 15) ,(+ x 55) ,(+ y 15)))
          (create-oval canvas (+ x 54) (+ y 14) (+ x 56) (+ y 16))
          (create-text canvas (+ x 15) (+ y 7) "or"))))

    (defmethod get-drawer ((obj not-elt))
      (let ((x (point-x (base obj)))
            (y (point-y (base obj))))
        (lambda (canvas)
          (create-line canvas `(,(+ x 10) ,(+ y 0) ,(+ x 10) ,(+ y 30)))
          (create-line canvas `(,(+ x 10) ,(+ y 00) ,(+ x 35) ,(+ y 15)))
          (create-line canvas `(,(+ x 10) ,(+ y 30) ,(+ x 35) ,(+ y 15)))
          (create-oval canvas (- (+ x 40) 5) (- (+ y 15) 5) (+ (+ x 40) 5) (+ (+ y 15) 5))
          (create-line canvas `(,(+ x 0) ,(+ y 15) ,(+ x 10) ,(+ y 15)))
          (create-oval canvas (+ x -1) (+ y 14) (+ x 1) (+ y 16))
          (create-line canvas `(,(+ x 45) ,(+ y 15) ,(+ x 55) ,(+ y 15)))
          (create-oval canvas (+ x 54) (+ y 14) (+ x 56) (+ y 16)))))
  #+END_SRC

  Напишем визуализатор, который рисует все переданные ему элементы на переданном ему
  холсте:

  #+NAME: viz
  #+BEGIN_SRC lisp
    (defun viz (canvas elts)
      (let ((ht (make-hash-table))
            (wires))
        (mapcar #'(lambda (elt)
                    (funcall (get-drawer elt) canvas)
                    (setf wires (append wires (inputs elt)))
                    (setf wires (append wires (outputs elt))))
                elts)
        (mapcar #'(lambda (x)
                    (setf (gethash (inout-wire x) ht)
                          (append (gethash (inout-wire x) ht)
                                  (list x))))
                wires)
        (maphash #'(lambda (wire inouts)
                     (format t "~% ~A : ~A" wire inouts)
                     (let ((first-inout nil))
                       (loop :for inout :in inouts :do
                          (if (null first-inout)
                              (progn
                                (setf first-inout inout)
                                (unless (equal 0 (search "WIRE-" (symbol-name wire)))
                                  (create-text canvas
                                               (if (inout-is-out inout)
                                                   (point-x (inout-coord inout))
                                                   (- (point-x (inout-coord inout)) 30))
                                               (if (inout-is-out inout)
                                                   (point-y (inout-coord inout))
                                                   (- (point-y (inout-coord inout)) 15))
                                               (format nil "~A=~A" (symbol-name wire)
                                                       (signal-value (symbol-value wire))))))
                              ;; else
                              (progn
                                (create-line canvas `(,(point-x (inout-coord first-inout))
                                                       ,(point-y (inout-coord first-inout))
                                                       ,(point-x (inout-coord inout))
                                                       ,(point-y (inout-coord inout))))
                                (setf first-inout inout))))))
                 ht)))
  #+END_SRC

  #+NAME: test
  #+BEGIN_SRC lisp
    (defmacro declare-wires ((&rest wires) &body body)
      `(let ,(loop :for wire :in wires :collect
                `(,wire (make-instance 'wire :name ',wire)))
         ,@(loop :for wire :in wires :collect
              `(declare (special ,wire)))
         ,@body))

    (defmacro ltk-show (elts width height scroll-width scroll-height)
      `(with-ltk ()
         (let* ((sc (make-instance 'scrolled-canvas :borderwidth 2 :relief :raised))
                (canvas (canvas sc)))
           (configure canvas :borderwidth 2 :relief :sunken :width ,width :height ,height)
           (pack sc :side :top :fill :both :expand t)
           (scrollregion canvas 0 0 ,scroll-width ,scroll-height)
           (viz canvas ,elts))))

    (declare-wires (d e a b s c)
      (let ((elts (half-adder a b s c 50 50 :d d :e e)))
        (set-signal a 1)
        (set-signal b 1)
        (propagate *the-agenda*)
        (ltk-show elts 300 200 300 200)))

    (declare-wires (d1 e1 d2 e2 s c1 c2 a b c sum c-out)
      (let ((elts (full-adder a b c sum c-out 50 50 :s s :c1 c1 :c2 c2 :d1 d1 :e1 e1 :d2 d2 :e2 e2)))
        (set-signal a 1)
        (set-signal c 1)
        (propagate *the-agenda*)
        (ltk-show elts 600 200 600 200)))
  #+END_SRC

* TODO Задача в общем виде

  Предположим наличие комбинационной схемы, у которой N входов и M выходов. Для всех
  необходимых комбинаций сигналов на входах даны соответствующие комбинации на
  выходах. Необходимо автоматически синтезировать по возможности оптимальную схему
  преобразования входов в выходы.

* TODO Частный случай

  Рассмотрим схему преобразования двоичного четырехразрядного входного кода в его
  семиразрядное значение для семисегментного индикатора.

  #+BEGIN_EXAMPLE
     -a-
    |   |
    f   b
    '-g-'
    |   |
    e   c
    '-d-'
  #+END_EXAMPLE

  Построим таблицу соответствий входных комбинаций - выходным:

  #+NAME: tbl
    | N | 3 | 2 | 1 | 0 | g | f | e | d | c | b | a |
    |---+---+---+---+---+---+---+---+---+---+---+---|
    | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 |
    | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 1 | 0 |
    | 2 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 1 |
    | 3 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 |
    | 4 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |
    | 5 | 0 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 1 |
    | 6 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 |
    | 7 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
    | 8 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
    | 9 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 |
    | A | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 1 |
    | B | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
    | C | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 |
    | D | 1 | 1 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 |
    | F | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 1 |
    | G | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 1 |

* TODO Тесты

  Для тестирования получившихся результатов необходимо сформировать по таблице
  соответствий тесты.

  Каждый тест принимает на вход комбинационную схему, ее входные и содержит внутри себя
  информацию о строчке таблицы соответствий, которую он проверяет.

  В простейшем случае тест может возвращать булево значение (пройден или не пройден),
  но нам также может пригодиться мера соответствия - количество ложно-положительных
  (сегменты горят, хотя не должны) и ложно-отрицательных (сегменты не горят, хотя
  должны) ошибок.

  Определим процедуру прогона теста и подсчета результата, ложно-положительных и
  ложно-отрицательных ошибок:

  #+NAME: run_test
  #+BEGIN_SRC lisp
    (defun run-test (scheme in out)
      (let* ((result (interpret scheme in))
             (false-positives 0)
             (false-negatives 0))
        (loop
           :for test-elt :in out
           :for result-elt :in result
           :do (progn
                 (when (and (equal result-elt 1) (equal test-elt 0))
                   (incf false-positives))
                 (when (and (equal result-elt 0) (equal test-elt 1))
                   (incf false-negatives))))
        (values
         (equal out result)
         false-positives
         false-negatives)))
  #+END_SRC

  Эта процедура зависит от функции =interptet=, которая должна применять значения
  входов =in= к комбинационной схеме =scheme=.

* TODO Распространение ограничений
* TODO Компоненты
* TODO Разводка

  В одном слое
* Литература
  http://www.bestreferat.ru/referat-273547.html
* Сборка

  #+BEGIN_SRC lisp :tangle karnaugh.lisp :noweb tangle :padline no :comments link
    ;; Макросы для корректного вывода ошибок
    (ql:quickload "ltk")
    (use-package :ltk)

    (defmacro bprint (var)
      `(subseq (with-output-to-string (*standard-output*)  (pprint ,var)) 1))

    (defmacro err (var)
      `(error (format nil "ERR:[~A]" (bprint ,var))))

    <<agenda_class>>

    <<wire_class>>

    <<time_segment_class>>

    <<queue_class>>

    <<vis_class>>

    <<elt_class_drivers>>

    <<viz>>


    <<init>>


    <<queue_empty>>

    <<queue_front>>

    <<queue_insert>>

    <<queue_del>>


    <<agenda_empty>>

    <<agenda_object>>

    <<agenda_add>>

    <<after_delay>>

    <<agenda_remove_first_item>>

    <<agenda_first_item>>

    <<propagate>>


    <<wire_get_signal>>

    <<wire_set_signal>>

    <<wire_add_action>>


    <<inverter>>

    <<and-gate>>

    <<or-gate>>


    <<half_adder>>

    <<full_adder>>


    <<probe>>

    <<components>>


    <<test>>
  #+END_SRC
