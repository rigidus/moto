#+HTML_HEAD: <!-- -*- fill-column: 87 -*- -->
#+HTML_HEAD: <!-- org-toggle-inline-images -->

#+TITLE: Karnaugh

#+INFOJS_OPT: view:overview toc:nil

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="/css/css.css" />
#+END_HTML

* Имитация цифровых электронных схем

  Цифровые электронные схемы строятся путем соединения простых элементов, таких как:
  - инвертор
  - и - элемент
  - или - элемент
  - или-не - элемент
  Хотя поведение этих составляющих элементов примитивно, сети, из них собранные, могут
  обладать весьма сложным поведением. Компьютерная имитация проектируемых электронных
  схем служит важным инструментом для инженеров-специалистов по цифровым системам.

  Cпроектируем систему для имитационного моделирования цифровых схем. Система эта будет
  служить примером программ особого вида, называемых =имитация, управляемая событиями=
  (event-driven simulation), в которых действия (события) вызывают другие события,
  которые происходят спустя некоторое время и при этом в свою очередь вызывают события,
  и так далее.

  Наша вычислительная модель цифровой схемы будет состоять из объектов, соответствующих
  элементарным компонентам, из которых строится схема. Имеются =провода=, несущие
  =цифровые сигналы=. В каждый момент цифровой сигнал может иметь только одно из двух
  возможных значений, 0 или 1.

  Кроме того, имеются различные виды =функциональных элементов=, которые соединяют
  провода, несущие входные сигналы, с выходными проводами. Такие элементы порождают
  выходные сигналы, вычисляя их на основе входных сигналов.

  Выходной сигнал задерживается на время, зависящее от типа функционального
  элемента. Мы не пренебрегаем задержкой в нашей функциональной модели, т.к. она не
  только отражает причинность реальности, но и служит защитой от зацикливания внутри
  вызывающих друг друга событий.

  Например, =инвертор= (inverter) — элементарный функциональный элемент, который
  обращает свой входной сигнал. Если входной сигнал инвертора становится 0, то на одну
  инверторную задержку позже сигнал на выходе станет равен 1. Если входной сигнал
  станет 1, то на инверторную задержку позже на выходе появится 0.

  #+BEGIN_EXAMPLE

    _________|\
             | \
             |  o----
    _________| /
             |/

  #+END_EXAMPLE

  =И-элемент= (and-gate) имеет два входа и один выход. Он обеспечивает на выходе
  сигнал, равный =логическому И= от входов. Это означает, что если оба входных сигнала
  становятся равными 1, то одну И-задержку спустя И-элемент заставит свой выходной
  сигнал стать 1; в противном случаена выходе будет 0.

  #+BEGIN_EXAMPLE
              ___
    _________|   `-.
             |      \_______
    _________|      /
             |___,-'

  #+END_EXAMPLE


  =ИЛИ-элемент= (or-gate) представляет собой подобный же элементарный функциональный
  элемент, который обеспечивает на выходе сигнал, равный =логическому ИЛИ= своих
  входов. А именно, выходной сигнал станет равен 1, если хотя бы один из входных
  сигналов окажется 1; в противном случае на выходе будет 0.

  #+BEGIN_EXAMPLE
            ___
    -------\   `-._
            \      `.______
            /     _,'
    -------/___,-'

  #+END_EXAMPLE

  Соединяя элементарные функции, можно получать более сложные. Для этого надо
  подсоединять выходы одних функциональных элементов ко в ходам других. Например, схема
  полусумматора (half-adder) состоит из ИЛИ-элемента, двух И-элементов и
  инвертора. Полусумматор получает два входа, A и B, и имеет два выхода, S и C.

  #+BEGIN_EXAMPLE

                ____
    A ----+-----\   `-._    D       ___
          |      \      `._________|   `-.
          |      /     _,'         |      \_______ S
    B ----|--+--/___,-'        E   |      /
          |  |               +-----|___,-'
          |  |               o
          |  |               |
          |  |              / \
          |  |   ___       /___\
          +--|--|   `-.      |
             |  |      \_____|____________________ C
             |  |      /
             +--|___,-'

  #+END_EXAMPLE


  S становится 1, когда ровно один из сигналов A и B равен 1, а C тогда, когда и A, и B
  равны 1. Из схемы можно видеть, что по причине задержек выходные сигналы могут
  генерироваться в разное время. Отсюда происходят многие сложности в проектировании
  цифровых схем.

  [[file:./img/half-adder.png]]

  Теперь мы построим программу для имитации цифровых логических схем, которые мы хотим
  изучать. Программа будет строить вычислительные объекты, моделирующие провода,
  которые "содержат" сигналы. Функциональные элементы будут моделироваться процедурами,
  которые обеспечивают нужное отношение между сигналами.

  Одним из базовых элементов нашей имитации будет процедура make-wire, которая
  порождает провода. Например, мы можем создать шесть проводов так:

  #+BEGIN_EXAMPLE
    (defparameter *a* (make-wire))
    (defparameter *b* (make-wire))
    (defparameter *c* (make-wire))
    (defparameter *d* (make-wire))
    (defparameter *e* (make-wire))
    (defparameter *s* (make-wire))
  #+END_EXAMPLE

  Мы подсоединяем функциональный элемент к проводу во время вызова процедуры, которая
  создает данный вид элемента. Аргументами порождающей процедуры служат про- вода,
  подсоединяемые к элементу. Например, если мы умеем создавать И-элементы, ИЛИ-элементы
  и инверторы, мы можем собрать полусумматор:

  #+BEGIN_EXAMPLE
    (or-gate *a* *b* *d*)
    (and-gate *a* *b* *c*)
    (inverter *c* *e*)
    (and-gate *d* *e* *s*)
  #+END_EXAMPLE

  Даже лучше того, можно присвоить этой операции имя, определив процедуру half-adder,
  конструирующую схему, используя четыре внешних провода, которые нужно подсоединить к
  полусумматору:

  #+NAME: half_adder
  #+BEGIN_SRC lisp
    (defun half-adder (a b s c)
      (let ((d (make-wire))
            (e (make-wire)))
        (or-gate a b d)
        (and-gate a b c)
        (inverter c e)
        (and-gate d e s)))
  #+END_SRC

  Преимущество этого определения в том, что теперь мы можем использовать =half-adder=
  как строительный блок при создании более сложных схем. Напр имер, сумматор
  (full-adder), состоящий из двух полусумматоров и ИЛИ-элемента.

  [[file:./img/full-adder.png]]

  Сумматор можно сконструировать так:

  #+NAME: full_adder
  #+BEGIN_SRC lisp
    (defun full-adder (a b c-in sum c-out)
      (let ((s (make-wire))
            (c1 (make-wire))
            (c2 (make-wire)))
        (half-adder b c-in s c1)
        (half-adder a s sum c2)
        (or-gate c1 c2 c-out)))
  #+END_SRC

Определив full-adder как процедуру, мы можем ее использовать как строительный блок для еще более сложных схем. В сущности, наша имитация дает инструмент, с помощью которого строится язык
описания схем. Принимая общую точку зрения на языки, с которой мы приступилик изучению Лиспа в разделе 1.1, можно сказать, что элементар
ные функциональные элементы являются примитивами языка, связывание их проводами
представляет собой средство комбинирования, а определение шаблонных схем в ви
де процедур служит сред

* Задача в общем виде

  Предположим наличие комбинационной схемы, у которой N входов и M выходов. Для всех
  необходимых комбинаций сигналов на входах даны соответствующие комбинации на
  выходах. Необходимо автоматически синтезировать по возможности оптимальную схему
  преобразования входов в выходы.

* Частный случай

  Рассмотрим схему преобразования двоичного четырехразрядного входного кода в его
  семиразрядное значение для семисегментного индикатора.

  #+BEGIN_EXAMPLE
     -a-
    |   |
    f   b
    '-g-'
    |   |
    e   c
    '-d-'
  #+END_EXAMPLE

  Построим таблицу соответствий входных комбинаций - выходным:

  #+NAME: tbl
    | N | 3 | 2 | 1 | 0 | g | f | e | d | c | b | a |
    |---+---+---+---+---+---+---+---+---+---+---+---|
    | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 |
    | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 1 | 0 |
    | 2 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 1 |
    | 3 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 |
    | 4 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |
    | 5 | 0 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 1 |
    | 6 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 |
    | 7 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
    | 8 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
    | 9 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 |
    | A | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 1 |
    | B | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
    | C | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 |
    | D | 1 | 1 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 |
    | F | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 1 |
    | G | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 1 |

* Тесты

  Для тестирования получившихся результатов необходимо сформировать по таблице
  соответствий тесты.

  Каждый тест принимает на вход комбинационную схему, ее входные и содержит внутри себя
  информацию о строчке таблицы соответствий, которую он проверяет.

  В простейшем случае тест может возвращать булево значение (пройден или не пройден),
  но нам также может пригодиться мера соответствия - количество ложно-положительных
  (сегменты горят, хотя не должны) и ложно-отрицательных (сегменты не горят, хотя
  должны) ошибок.

  Определим процедуру прогона теста и подсчета результата, ложно-положительных и
  ложно-отрицательных ошибок:

  #+NAME: run_test
  #+BEGIN_SRC lisp
    (defun run-test (scheme in out)
      (let* ((result (interpret scheme in))
             (false-positives 0)
             (false-negatives 0))
        (loop
           :for test-elt :in out
           :for result-elt :in result
           :do (progn
                 (when (and (equal result-elt 1) (equal test-elt 0))
                   (incf false-positives))
                 (when (and (equal result-elt 0) (equal test-elt 1))
                   (incf false-negatives))))
        (values
         (equal out result)
         false-positives
         false-negatives)))
  #+END_SRC

  Эта процедура зависит от функции =interptet=, которая должна применять значения
  входов =in= к комбинационной схеме =scheme=.

* Представление проводов

  Провод в нашей имитации будет объектом с двумя переменными:
  - значение сигнала =signal-value= (вначале равное 0)
  - набор процедур-действий =action-procedures=, подлежащих исполнению, когда сигнал
    изменяется.

  #+NAME: wire_object
  #+BEGIN_SRC lisp
    (defclass wire ()
      ((signal-value       :initarg :signal-value       :accessor signal-value)
       (action-procedures  :initarg :action-procedures  :accessor action-procedures)))
  #+END_SRC

  Метод =get-signal= возвращает текущее значение сигнала в проводе:

  #+NAME: wire_get_signal
  #+BEGIN_SRC lisp
    (defmethod get-signal ((obj wire))
      (signal-value obj))
  #+END_SRC

  Метод =set-signal= проверяет, отличается ли новое значение сигнала в проводе от
  старого. Если да, то она запускает все процедуры-действия:

  #+NAME: wire_set_signal
  #+BEGIN_SRC lisp
    (defmethod set-signal ((obj wire) new-value)
      (if (not (equal (signal-value obj) new-value))
          (progn
            (setf (signal-value obj) new-value)
            (loop :for procedure :in (action-procedures obj) :do (funcall procedure)))))
  #+END_SRC

  Метод =add-action= добавляет процедуру к списку действий, а затем один раз запускает
  добавленную процедуру, чтобы сделать инициализацию:

  #+NAME: wire_add_action
  #+BEGIN_SRC lisp
    (defmethod add-action ((obj wire) procedure)
      (setf action-procedures
            (append action-procedures (list procedure)))
      (funcall procedure))
  #+END_SRC

  Соберем все, что касается =wire= в один кодовый блок:

  #+NAME: wire
  #+BEGIN_SRC lisp
    <<wire_object>>
    <<wire_get_signal>>
    <<wire_set_signal>>
    <<wire_add_action>>
  #+END_SRC

* План действий

  Теперь для завершения модели нам остается только написать =after-delay=.

  Здесь идея состоит в том, чтобы организовать структуру данных под названием план
  действий (agenda), где будет храниться расписание того, что нам надо сделать. Для
  планов действий определены следующие операции:

  - =make-agenda= - возвращает новый пустой план действий.
  - =empty-agenda= - истинно, если план пуст.
  - =first-agenda-item= - возвращает первый элемент плана.
  - =remove-first-agenda-item= - модифицирует план, убирая из него первый элемент.
  - =add-to-agenda= модифицирует план, добавляя процедуру-действие, которую нужно
    запустить в указанное время.
  - current-time возвращает текущее время модели.

  Экземпляр плана, которым мы будем пользоваться, будет обоз начаться =the-agenda=

  Процедура =after-delay= добавляет новый элемент в план the-agenda:

  #+NAME: after_delay
  #+BEGIN_SRC lisp
    (defmethod after-delay ((obj agenda) delay action)
      (add-to-agenda obj
                     (+ delay (current-time obj))
                     action))
  #+END_SRC

  Имитация управляется процедурой =propagate=, которая работает с объектом, по очереди
  выполняяпроцедуры, содержащиеся в плане. В общем случае, при работе модели в план
  добавляются новые элементы, а =propagate= продолжает работу, пока план не становится
  пустым:

  #+NAME: propagate
  #+BEGIN_SRC lisp
    (defmethod propagate ((obj agenda))
      (if (empty-agenda obj)
          (return-from propagate nil)
          (let ((first-item (first-agenda-item obj)))
            (funcall first-item)
            (remove-first-agenda-item obj)
            (propagate))))
  #+END_SRC

  Наконец, мы описываем детали структуры данных плана действий, которая хранит
  процедуры, предназначенные для исполнения в будущем.

  План состоит из временных отрезков. Каждый временной отрезок является парой,
  состоящей из числа (значения времени) и очереди, которая содержит процедуры,
  предназначенные к исполнению в этот временной отрезок.

  #+NAME: time_segment
  #+BEGIN_SRC lisp
    (defun make-time-segment (time queue)
      (cons time queue))

    (defun segment-time (s)
      (car s))

    (defun segment-queue (s)
      (cdr s))
  #+END_SRC

  Сам по себе план действий является одномерной таблицей врем енных отрезков. Сегменты
  отсортированы в порядке возрастания времени. В дополнение к этому мы храним текущее
  время (current time) (т. е. время последнего исполненного действия) в голове
  плана. Свежесозданный план не содержит временных отрезков, а его текущее время равно
  нулю:

  #+NAME: agenda_segments_ops
  #+BEGIN_SRC lisp
    (defun make-agenda ()
      (list 0))

    (defun current-time (agenda)
      (car agenda))

    (defun set-current-time (agenda time)
      (setf (car agenda) time))

    (defun segments (agenda)
      (cdr agenda))

    (defun set-segments (agenda segments)
      (setf (cdr agenda) segments))

    (defun first-segment (agenda)
      (car (segments agenda)))

    (defun rest-segments (agenda)
      (cdr (segments agenda)))
  #+END_SRC

  План пуст, если в нем нет ни одного временного отрезка:

  #+NAME: agenda_empty
  #+BEGIN_SRC lisp
    (defun empty-agenda (agenda)
      (null (segments agenda)))
  #+END_SRC

  Для того, чтобы добавить в план новое действие, прежде всего мы проверяем, не пуст ли
  план. Если пуст, мы создаем для действия новый отрезок и вставляем его в план. Иначе
  мы просматриваем план, глядя на времена отрезков. Есл и мы находим отрезок с
  назначенным временем, мы добавляем действие к соответствующей очереди. Если же мы
  обнаруживаем время, большее, чем назначенное, мы вставляем новый отрезок перед
  текущим. Если мы доходим до конца плана, мы вставляем новый отрезок в конец.

  #+NAME: agenda_add
  #+BEGIN_SRC lisp
    (defun belongs-before (segments)
      (or (null segments)
          (< time (segment-time (car segments)))))

    (defun make-new-time-segment (time action)
      (let ((q (make-queue)))
        (insert-queue q action)
        (make-time-segment time q)))

    (defun add-to-segments (segments)
      (if (equal (segment-time (car segments)) time)
          (insert-queue (segment-queue (car segments))
                        action)
          ;; else
          (let ((rest (cdr segments)))
            (if (belongs-before rest)
                (set (cdr segments)
                     (cons (make-new-time-segment time action)
                           (cdr segments)))
                ;; else
                (add-to-segments rest)))))

    (defmethod add-to-agenda (agenda time action)
      (let ((segments (segment agenda)))
        (if (belongs-before segments)
            (set-segments agenda
                          (cons (make-new-time-segment time action)
                                segments))
            ;; else
            (add-to-segments segments))))
  #+END_SRC

  Процедура, которая убирает из плана первый элемент, уничто жает элемент в начале
  очереди первого отрезка времени. Если в результате отрезок становится пустым, мы
  изымаем его из списка отрезков.

  #+NAME: agenda_remove_first_item
  #+BEGIN_SRC lisp
    (defun remove-first-agenda-item (agenda)
      (let ((q (segment-queue (first-segment agenda))))
        (delete-queue q)
        (if (empty-queue q)
            (set-segments agenda (rest-segments agenda)))))
  #+END_SRC

  Первый элемент плана находится в начале очереди в первом временном отрезке. Каждый
  раз, когда мы обращаемся к такому элементу, мы обновляем текущее время. Таким
  образом, текущее время всегда будет совпадать с временем последнего обработанного
  действия.

  Благодаря тому, что это время хранится в голове плана, оно всегда доступно, даже если
  соответствующий отрезок времени был уничтожен:

  #+NAME: agenda_first_item
  #+BEGIN_SRC lisp
    (defun first-agenda-item (agenda)
      (if (empty-agenda agenda)
          (err "agenda empty")
          (let ((first-seg (first-segment agenda)))
            (set-current-time agenda (segment-time first-seg))
            (front-queue (segment-queue first-seg)))))
  #+END_SRC

* Распространение ограничений


* Компоненты
* Разводка

  В одном слое
* Литература
  http://www.bestreferat.ru/referat-273547.html
