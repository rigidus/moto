#+TITLE: moto
#+HTML_HEAD: <!-- -*- fill-column: 86 -*- -->

#+NAME: css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

* Введение
  Создаем самый посещаемый ресурс по мототематике. Сначала в С-Пб, потом в Москве.

  Задачи:
  - Определить интересы целевой аудитории. Клубы, тусовки, небходимые сервисы
  - Определить круг зарубежных ресурсов, с которых брать идеи
  - Выйти на рекламодателей, определить возможную окупаемость и схемы монетизации

  Отличия от других:
  - Более демократичный ресурс чем мотобратан:
    - модератор подписывается под баном
    - можно баны обсуждать
    - сообщество может отменить бан модератора!
  - Больше возможностей:
    - поиск людей (ник, имя, район)
    - разделы общения:
    - по районам - для совместных прохватов (север, юг, пригороды)
    - кварталы по классу мотоциклов (спорбайки, эндуро, etc)
      - новости, которые сегментирутся по кварталам.
      - пользователь может подписаться на разные кварталы и сформировать ленту, а также на
        разных людей (иерархические теги)
    - прохваты - календарь
    - карта с маршрутами прохватов
    - статистика дтп как на motositizen
    - отметить темы как прочитанные
    - личные сообщения сделать удобнее чем на мотобратане и с поиском
  - Больше полезной информации о мотоциклах
    - раздел с мануалами и поиском по мотоциклу
    - раздел с поиском по запчастям
    - раздел с "у кого спросить" по мотоциклу
    - мотосервисы и отзывы о ремонтах
  - Никакой надоедливой рекламы (баннеров)
  - Разделы
    - УСЛУГИ - в этом разделе пользователь должен увидеть, где какие гаражи можно
      арендовать, в каких мастерских можно починиться, где есть мотошколы, где
      зарегистрироваться или застраховаться и пр - то есть здесь надо собрать инфу обо всех
      услугах, которые могут пригодиться.
    - ЗАПЧАСТИ - поиск запчастей как у частных так и по магазинам, отзывы с инфой где
      покупал эту запчасть https://www.louis.de/rubrik/motorradbekleidung-motorradhelme/1
    - ПРОХВАТЫ
    - БЛОГИ - сортировка новостей для удобства поиска (мало ли людям
      пригодится). Сортировать по источникам, например - СМИ (то есть газеты и проч
      известные сми), блоги, новости сайта.
    - УГОНЫ
    - ДТП
    - ГАЛЕРЕЯ - как у харлея или тут http://www.dorna.com/dornacontents_wsbk.html
    - Гонки
    - Отчеты о путешествиях
    - Брендованные страницы сервисов http://www.cobrausa.com/
      https://www.louis.de/katalog/themen-welten/meine-werkstatt
    - Статьи с кармой как на байкпосте
  - Трансляции с мотобратана, байкпоста и других сайтов, например ру_чп, в части мотоциклистов
  - Мотофлирт с функционалом полноценного сайта знакомств.
  - Комментарии ко всему
  - Продажа мотоциклов с функицоналом авто.ру и синдикацией с авто.ру и авито
  - Юридическая помощь
  - Отслеживание камер и радаров (за карму) (по карте)
  - Карма
    - отслеживать за что
    - привлекать людей к оценке сколько дать за какое действие
  - Связь с админами
  - Система исправления орфографических (и не только) ошибок сначала для себя, а при
    подтверждении автором - и для других. С наглядностью диффа.
  - Заметки по юзерам:
    http://vk.com/ekaterina.klochkova
    На всякий пожарный.
    Ближайшую неделю меня не будет вконтактике.
    У меня есть телефон: +79218857023
    и почта: kait.klochkova@gmail.com.
  - Поиск друзей с кем покататься
    Вводишь время, место и радиус, система находит друзей, и пишешь им - давай катать!
  - Мототур "по бабам"

* Стартап
  идея. жизнь на пракачку, или как из омеги заальфаться для задротов.
  приложение на мобилку, которое раздает тебе очки за то что ты делаешь что-то
  душеспасительное и полезное.
  связано с форсквэром, считывалкой штрихкодов и прочей поебней.

  ты логгишься туда и тебе рисуют аватарку тупого дрыща, нихуя не умеющего в этой жизни. у
  тебя 0 уровень.

  ты получаешь очки, когда отслеживалка находит тебя в фитнес-клубах, центрах обучения и
  т.д. если ты там появляешься регулярно - очки удваиваются, пока не поломаешь цепь
  регулярности. то есть 20 посещений качалки дают 20 очков, если ходить как поппало, или 40,
  если не ломать периодичность 2 раза в неделю.
  небольшое количество баллов получаешь, когда покупаешь полезную жратву или развивающие
  книги, гантели. спорт товары, оплачиваешь услуги обучения, медицинские услуги и проч. для
  этого используется сканер штрихкодоов

  растет уровень - растет необходимое количество баллов для достижения следующего.
  более ценные баллы можно получить, предоставляя приложению докозательства успехов -
  сертификаты об окончании курсов на курсере, сдача нормативов по бегу или прочей хуйне,
  которую отмеряет шагометр, встроенный в мобилку, чекины с других концов планеты.

  задроты - они задроты везде, и зарабатывая баллы будут прокачивать свою жизнь.

  идея для коммерциализации - заключать контракты с магазинами спорт товаров/ресторанами
  здорового питания/ центрами обучения, что бы при оплате их услуг получать бонусные баллы

  Одоната
  по пути побочные квестики - прочитай вот эту книжку, ответь на вопросики по содержанию,
  получи полюсик
  сходи в такой музейчик, отметься - держи еще один плюсик.
  на этой неделе пройдет вот такое мероприятие, сходи, получи супер бонус, а мы денег за
  рекламу от организаторов
  ага. ток что бы этим заняться мне надо либо с работы уволиться либо бросить спать.
  я чо эт хуйню то придумала. я узнада что мой клуб очки начисляет за посещения. и
  обнаружила, что как только об этом узнала. частота моих посещений возрасла до 3х раз в
  неделю. мне эти балы не дают нихуя. не даж так. НИХУЯШЕНЬКИ
  но воспитанное годами мышление задрота не позволяет упустить возможность заработать баллы

  есть проблема, связанная с тем, что человеки - в общем-то ленивые скоты. а задроты еще и
  хитрые ленивые скоты и нужна система контроля.

  поэтому эту хуйню надо строить изначально с привязкой к кому-нибудь.
  идеальный вариант - начать с физического состояния задрота, т.к. это самая болезненная тема
  раз, измеряется проще всего два.
  берем в одну руку сеть качалок - тот же задрипанный алекс фитнес и привязываем всю эту
  лабуду туда.
  менеджменту говорим, что ща продажи вырастут так, что охуеете а так же у вас будет мощная
  обратная связь с клиентурой.
  чувак не только чекинится в зале, но так же имеет возможность раз в месяц подойти к тренеру
  и сказать "смари как я умею". тренер проверяет прогресс и говорит - молодца чувак. после
  чего на своей мобилке жамкает кнопулю, которая генерит qr-код. чувак считывает своей
  мобилой qr-код и переходит на след уровень.
  можно привязать персональные тренировки к этой лабуде. тренра жеж все равно дают роуд мап
  какй-то мол по понедельникам ты делаешь два притопа три прихлопа, во вторник дрочишь хуй, в
  четверг работаешь вот с такими мышцами вот такими упражнениями по столько подходов. для
  чувака который первый раз пришел в зал все это - китайская грамота и вылетает из ушей
  моментально (я вот в полном ахуе например была) - а тут тренер говорит, мол выполняешь
  программу с номером 15, вот те код - чувак его считывает мобилкой и имеет нормальное
  рассписание что и когда ему делать. и задно баллы получает.

  делает это вместе с тренером - получает от тренера код, баллы удваиваются, в зале растут
  продажи персональных тренировок.

  через нное количество времени получаем сеть посетителей сети клубов, которые радостно друг
  другу шлют фотаньки с бицухами и дают оценки тренерам (как бонус)

  и тогда топаем в сеть школ, ну например иностранных языков. та же лабуда. получаешь баллы
  за то что приходишь на уроки, после экзамена и перехода на новый уровень владения языком
  получаешь от препода код. + мильен баллов и бэйджик.
  школам говорим - ща к вам прибежит клиентура в 100500 чуваков из качалок.
  потом туда же постепенно добавляем другие напрваления. автошколы, университеты, курсы
  повышения квалификации, оздоровительные программы и проч.

  от всех организаций-участников получаем обратную связь по поводу того, как чувачки наши
  развиваются. каждый новый участник получает прирост клиентуры и охуенную рекламную
  площадку. участники игрули получают скидку на услугу компаний-участников. мы сидим и
  стрижем купоны. вин-вин

  так как все участники реальны и действительно ходят во все эти хуйни, то мы будем
  единственной площадкой, которая может доказать, что отзывы, складирующиеся у нас (а люди
  ж те же голуби, им везде срать надо своим мнением) на 100% реальны, а не написаны
  пиарщиками или роботами

  соответственно к нам начинают прибегать посторонние люди что бы получать объективную оченку
  мест в которые они хотят вписаться

* Что улучшать
  - Типы для полей state нужно задавать как перечисления
  - Добавить AJAX и Comet
  - Автоматизированная генерация интерфейса для просмотра и редактирования сущностей
  - Забираем пользователей с других ресурсов
  - Очищалка базы для каждого модуля должна лежать в модуле
  - И сущности тоже туда переложить
* Определения сущностей
** Функции для кодогенерации сущностей

   Эти функции будут кодогенерировать сущности и автоматы из таблиц с наименованием и
   типами полей внутри этого файла.

   Чтобы емакс не запрашивал подтверждение на каждое исполнение кода, установим эту
   настройку:

   #+NAME: gen_org_confirm
   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC

   Начнем с генерации кода из таблицы полей:

   #+NAME: gen_fields
   #+BEGIN_SRC emacs-lisp
     (defun gen-fields (rows)
       (let ((result))
         (push "\n" result)
         (push (format "  (%s\n" (butlast (car rows))) result)
         (mapcar #'(lambda (x)
                     (push (format "   %s\n" (butlast x)) result))
                 (butlast (cdr rows)))
         (push (format "   %s)" (butlast (car (last rows)))) result)
         (mapconcat 'identity (reverse result) "")))
   #+END_SRC

   Теперь напишем код, который генерирует код для состояний конечного автомата:

   #+NAME: gen_states
   #+BEGIN_SRC emacs-lisp
     (defun gen-states (rows)
       (let ((result)
             (hash (make-hash-table :test #'equal))
             (states))
         (dolist (elt rows nil)
           (puthash (cadr elt) nil hash)
           (puthash (cadr (cdr elt))  nil hash))
         (maphash (lambda (k v)
                    (push k states))
                  hash)
         (push "\n" result)
         (push "  (" result)
         (dolist (elt (butlast states))
           (push (format ":%s " elt) result))
         (push (format ":%s)" (car (last states))) result)
         (mapconcat 'identity (reverse result) "")))
   #+END_SRC

   И добавим к этом генератор действий - т.е. переходов между состояниями:

   #+NAME: gen_actions
   #+BEGIN_SRC emacs-lisp
     (defun gen-actions (rows)
       (let ((result))
         (push "\n" result)
         (let ((x (car rows)))
           (push (format "  ((:%s :%s :%s)" (cadr x) (cadr (cdr x)) (car x)) result))
         (if (equal 1 (length rows))
             (push ")" result)
           (progn
             (push "\n" result)
             (mapcar #'(lambda (x)
                         (push (format "   (:%s :%s :%s)\n" (cadr x) (cadr (cdr x)) (car x)) result))
                     (cdr (butlast rows)))
             (let ((x (car (last rows))))
               (push (format "   (:%s :%s :%s))" (cadr x) (cadr (cdr x)) (car x)) result))))
         (mapconcat 'identity (reverse result) "")))
   #+END_SRC

   Соберем все это в один файл, чтобы загружать перед кодогенерацией проекта:

   #+NAME: generators
   #+BEGIN_SRC emacs-lisp :tangle generators.el :noweb tangle :exports code :padline no :comments link
     ;; <<copyright>>

     <<gen_org_confirm>>

     <<gen_fields>>

     <<gen_states>>

     <<gen_actions>>
   #+END_SRC

   И загрузим его:

   #+NAME: generators
   #+BEGIN_SRC emacs-lisp
     (load-file "generators.el")
   #+END_SRC

   Теперь у нас есть все необходимое, чтобы написать вызываемые при
   tangle генераторы сущностей и автоматов:

   #+NAME: gen_entity
   #+BEGIN_SRC emacs-lisp :var name="" docstring="" flds='() :exports none
     (let ((result))
       (push (format "(define-entity %s \"Сущность %s\"" name docstring) result)
       (push (gen-fields flds) result)
       (push ")\n" result)
       (push "\n" result)
       (push (format "(make-%s-table)\n" name) result)
       (mapconcat 'identity (reverse result) ""))
   #+END_SRC

   #+NAME: gen_automat
   #+BEGIN_SRC emacs-lisp :var name="" docstring="" flds='() states='() :exports none
     (let ((result))
       (push (format "(define-automat %s \"Автомат %s\"" name docstring) result)
       (push (gen-fields flds) result)
       (push (gen-states states) result)
       (push (gen-actions states) result)
       (push ")\n" result)
       (mapconcat 'identity (reverse result) ""))
   #+END_SRC

** DONE Пользователи (user)

   Для начала надо определиться, какие данные мы собираемся хранить о пользователях, и
   какого типа будут эти данные. Типы данных задаем в формате [[http://marijnhaverbeke.nl/postmodern/postmodern.html][Postmodern]] чтобы потом
   сохранить данные в =PostgreSQL=

   #+CAPTION: Данные пользователя
   #+NAME: user_flds
     | field name | field type           | note                          |
     |------------+----------------------+-------------------------------|
     | id         | serial               | идентификатор                 |
     | name       | varchar              | имя пользователя              |
     | password   | varchar              | пароль                        |
     | email      | varchar              | емейл                         |
     | ts-create  | bigint               | время создания                |
     | ts-last    | bigint               | время когда был последний раз |
     | role-id    | (or db-null integer) | идентификатор роли            |

   В нашей системе пользователь может существовать (или не существовать) в одном их
   нескольких состояний:
    + Когда пользователь еще не зарегистрирован на сайте мы можем считать его
      незарегистрированным (=unregistred=)
    + После регистрации он автоматически становится залогиненным (=logged=)
    + Пользователь может покинуть сайт и перейти в состояние =unlogged=
    + Пользователь может забыть свой пароль, тогда мы должны выслать ему ссылку для
      восстановления пароля (=sended=)
    + И наконец, после восстановления пароля пользователь вновь становится залогиненным
      (=logged=)

   Все эти переходы и состояния сведем в единую таблицу:

   #+CAPTION: Состояния конечного автомата пользователя
   #+NAME: user_state
     | action         | from        | to          |
     |----------------+-------------+-------------|
     | registration   | unregistred | logged      |
     | unregistration | logged      | unregistred |
     | enter          | unlogged    | logged      |
     | leave          | logged      | unlogged    |
     | forgot         | unlogged    | sended      |
     | remember       | sended      | logged      |

   Теперь мы можем полностью описать поведение пользователя как конечный автомат:

   #+NAME: user_state_graph
   #+BEGIN_SRC emacs-lisp :var table=user_state :results output :exports none :cache yes
     (mapcar #'(lambda (x)
                 (princ (format "%s -> %s [label =\"%s\"];\n"
                                (second x) (third x) (first x))))
             (nthcdr 2 table))
   #+END_SRC

   #+BEGIN_SRC dot :file img/user-state.png :var input=user_state_graph :exports results :cache yes
     digraph G {
       rankdir = LR;
       $input
     }
   #+END_SRC

   Теперь определим функции, которые вызываются на переходах из одного
   состояния в другое

   #+NAME: user_actions_func
   #+BEGIN_SRC lisp
     (defun registration ()
       "unregistred -> logged"
       )

     (defun unregistration ()
       "logged -> unregistred"
       )

     (defun enter ()
       "unlogged -> logged"
       )

     (defun leave ()
       "logged -> unlogged"
       )

     (defun forgot ()
       "unlogged -> sended"
       )

     (defun remember ()
       "sended -> logged"
       )
   #+END_SRC

** DONE Роли (role)

   Роли определяют набор сценариев, которые пользователь выполняет на
   сайте. Функционал, который выполняют сценарии запрашивает
   разрешение на выполнение действий, которое опирается на роль,
   присвоенную пользователю. Пользователь может иметь только одну роль
   или не иметь ее вовсе.

   Роль является простой сущностью и не имеет состояния.

   #+CAPTION: Данные роли
   #+NAME: role_flds
     | field name | field type           | note          |
     |------------+----------------------+---------------|
     | id         | serial               | идентификатор |
     | name       | (or db-null varchar) | имя роли      |

   Создадим необходимые роли:

   #+NAME: create_roles
   #+BEGIN_SRC lisp
     (make-role :name "admin")
     (make-role :name "manager")
     (make-role :name "moderator")
     (make-role :name "editor")
     (make-role :name "robot")
   #+END_SRC

** DONE Группы (group, user2group)

   Группы пользователей определяют набор операций, которые
   пользователь может выполнять над объектами системы. В отличие от
   ролей, один пользователь может входить в несколько групп или не
   входить ни в одну из них.

   Группа является простой сущностью и не имеет состояния.

   #+CAPTION: Данные группы
   #+NAME: group_flds
     | field name | field type | note          |
     |------------+------------+---------------|
     | id         | serial     | идентификатор |
     | name       | varchar    | имя группы    |

   Создадим необходимые группы:

   #+NAME: create_groups
   #+BEGIN_SRC lisp
     (make-group :name "oldman")
     (make-group :name "newboy")
     (make-group :name "veteran")
     (make-group :name "traveler")
     (make-group :name "troll")
   #+END_SRC

   Теперь создадим таблицу связи, которая свяжет пользователей и группы:

   #+CAPTION: Данные таблицы связи пользователя и группы
   #+NAME: user2group_flds
     | field name | field type | note                       |
     |------------+------------+----------------------------|
     | id         | serial     | идентификатор              |
     | user-id    | integer    | идентификатор пользователя |
     | group-id   | integer    | идентификатор группы       |

** Сообщения (msg)

   О сообщениях мы знаем только от кого они посылаются, кому и собственно текст
   сообщения. Его наверно не стоит ограничивать. По идее как посылающий, так и принимающий
   может удалить сообщение (пометить как удаленное), для этого мы используем отдельные
   флаги.

   #+CAPTION: Данные сообщения
   #+NAME: msg_flds
     | field name  | field type | note                                     |
     |-------------+------------+------------------------------------------|
     | id          | serial     | идентификатор                            |
     | snd-id      | integer    | пользователь, который послал сообщение   |
     | rcv-id      | integer    | пользователь, который получает сообщение |
     | msg         | varchar    | сообщение                                |
     | ts-create   | bigint     | время создания                           |
     | ts-delivery | bigint     | время доставки                           |

   Еще сообщение может быть доставлено или недоставлено.

   #+CAPTION: Состояния конечного автомата сообщения
   #+NAME: msg_state
     | action   | from        | to        |
     |----------+-------------+-----------|
     | delivery | undelivered | delivered |


   Теперь определим функции, которые вызываются на переходах

   #+NAME: msg_actions_func
   #+BEGIN_SRC lisp
     (defun delivery ()
       "undelivered -> delivered"
       )
   #+END_SRC

** Очереди (que, quelt)

   Очереди используются для фолловинга и прочей подписки на обновления.

   Нам нужна некоторая инфраструктура чтобы абстрагироваться от операций управления
   очередями, подписчиками и посылки сообщений. Потом ее можно будет изменить для поддержки
   RabbitMQ, Mbus или ZMQ или даже использовать все их одновременно для разных целей.

   Очередь является простой сущностью и не имеет состояния.

   #+CAPTION: Данные очереди
   #+NAME: que_flds
     | field name | field type | note          |
     |------------+------------+---------------|
     | id         | serial     | идентификатор |
     | name       | varchar    | имя очереди   |

   Нам понадобится сущность элемента очереди, назовем его =quelt=. Элемент очереди является
   простой сущностью и не имеет состояния.

   #+CAPTION: Данные элемента очереди
   #+NAME: quelt_flds
     | field name | field type | note                  |
     |------------+------------+-----------------------|
     | id         | serial     | идентификатор         |
     | que-id     | integer    | идентификатор очереди |
     | text       | varchar    | содержимое            |

   Создадим необходимые очереди:

   #+NAME: que_contents
   #+BEGIN_SRC lisp
     ;; (make-que :name "admin")
     ;; (make-que :name "manager")
     ;; (make-que :name "moderator")
     ;; (make-que :name "robot")
   #+END_SRC

** Аватары (avatar)

   Пользователи имеют неопределенное кол-во аватарок, разного размера, для которых мы
   осуществляем хранение в оригинальном размере, масштабирование и хранение
   отмасштабированных превьюшек.

   #+CAPTION: Данные аватарки
   #+NAME: avatar_flds
     | field name | field type | note                               |
     |------------+------------+------------------------------------|
     | id         | serial     | идентификатор                      |
     | user-id    | integer    | идентификатор пользователя         |
     | name       | varchar    | имя пользователя                   |
     | origin     | varchar    | путь к файлу оригинального размера |
     | ts-create  | bigint     | время создания                     |

   Одна из автарок может быть активной в данный момент.

   #+CAPTION: Состояния конечного автомата пользователя
   #+NAME: avatar_state
     | action     | from     | to       |
     |------------+----------+----------|
     | avatar-off | active   | inactive |
     | avatar-on  | inactive | active   |


   Теперь определим функции, которые вызываются на переходах

   #+NAME: avatar_actions_func
   #+BEGIN_SRC lisp
     (defun avatar-off ()
       "active -> inactive"
       )

     (defun avatar-on ()
       "inactive -> active"
       )
   #+END_SRC

** Мотоциклы (moto)

   Здесь все, что относится к мотоциклам пользователей. Мы хотим, чтобы пользователи не
   только могли рассказать о своих мотоциклах, но и купить/продать их, убедившись в
   легальности и нескрученном пробеге, изучив историю и динамику цен.

   В начале и конце сезона можно организовывать акции по контролю пробега например, за
   которые начислять карму.

   Для начала, стандартные поля - марка, модель, цвет и год выпуска.

   У каждого мотоцикла также есть цена за которую владелец готов его продать.

   Поля, которые пользователь может заполнить по желанию - описание мотоцикла, описание
   тюнинга.

   Поля, которые не показываются всем подряд: номерной знак, номер рамы, номер двигателя -
   все это может пригодиться для проверки мотоцикла на легальность.

   #+CAPTION: Данные мотоцикла
   #+NAME: moto_flds
     | field name | field type           | note                             |
     |------------+----------------------+----------------------------------|
     | id         | serial               | идентификатор                    |
     | vendor-id  | (or db-null integer) | идентификтор фирмы-производителя |
     | model-id   | (or db-null integer) | идентификтор модели              |
     | color-id   | (or db-null integer) | идентификтор цвета               |
     | year       | (or db-null integer) | год выпуска                      |
     | price      | (or db-null integer) | цена                             |
     | plate      | (or db-null varchar) | номерной знак                    |
     | vin        | (or db-null varchar) | vin-номер                        |
     | frame-num  | (or db-null varchar) | номер рамы                       |
     | engine-num | (or db-null varchar) | номер двигателя                  |
     | pts-data   | (or db-null varchar) | данные птс (раскрыть)            |
     | desc       | (or db-null varchar) | описание мотоцикла               |
     | tuning     | (or db-null varchar) | описание тюнинга                 |

   В нашей системе мотоцикл может существовать (или не существовать) в одном их
   нескольких состояний:
    + =используется= Мотоцикл на ходу, может быть выставлен на продажу, разбит, сломан или угнан.
    + =продается= Мотоцикл может быть продан. В этом состоянии мотоцикл находится в
      поиске. Хозяин может отменить продажу мотоцикла, если его слишком достали звонками,
      например. Хозяин может осуществить продажу, в этом случае, мотоцикл переходит в
      состояние =продан=.
    + =продан=. Продавец ставит этот статус, расставаясь с мотоциклом.
    + =куплен=. Покупатель ставит этот статус, получая мотоцикл
    + =сломан= Поломан настолько, что поломка препятствует эксплуатации. Отсюда есть только
      путь в сервис или на разборку. Конечно ломаный мотоцикл могут еще украсть или
      продать, но мы не продаем ломаные мотоциклы, это уже в раздел запчастей.
    + =угнан= Украден (в угоне). Дальше в дневнике может быть только где его видели. Может
      быть возвращен владельцу, а также сломан или разбит ворами.
    + =чинится= (в сервисе - эксплуатация невозможна). Этот статус устанавливает
      =service-man= при получени мотоцикла. При переводе мотоцикла обратно в эксплуатацию
      по идее должен занести в дневник список выполненных работ и сумму оплаты. Однако
      иногда починить мотоцикл не удается, тогда он остается сломанным, однако в сервисной
      книжке появляется запись о попытке починить. Иногда в процессе ремонта оказывается,
      что дешевле объявить мотоцикл хламом, чем чинить.
    + =хлам= Разбит (и восстановлению не подлежит)

   Все эти состояния и переходы между ними сведем в единую таблицу:

   #+CAPTION: Состояния конечного автомата мотоцикла
   #+NAME: moto_state
     | action                        | from         | to           |
     |-------------------------------+--------------+--------------|
     | выставление.на.продажу        | используется | продается    |
     | сломался                      | используется | сломан       |
     | крэш                          | используется | хлам         |
     | угон                          | используется | угнан        |
     | воры.повредили                | угнан        | сломан       |
     | воры.разбили                  | угнан        | хлам         |
     | отмена.выставления.на.продажу | продается    | используется |
     | отвоз.в.ремонт                | сломан       | чинится      |
     | доломал                       | сломан       | хлам         |
     | неосилил.починить             | чинится      | сломан       |
     | починил                       | чинится      | используется |
     | здесь.не.починишь             | чинится      | хлам         |
     | продажа                       | продается    | продан       |
     | покупка                       | продан       | куплен       |
     | ввод.в.эксплуатацию           | куплен       | используется |
     | возврат.с.угона               | угнан        | используется |

   Теперь мы можем полностью описать поведение мотоцикла как конечный автомат:

   #+NAME: moto_state_graph
   #+BEGIN_SRC emacs-lisp :var table=moto_state :results output :exports none :cache yes
     (mapcar #'(lambda (x)
                 (princ (format "%s -> %s [label =\"%s\"];\n"
                                (second x) (third x) (first x))))
             table)
   #+END_SRC

   #+BEGIN_SRC dot :file img/moto-state.png :var input=moto_state_graph :exports results :cache yes
     digraph G {
       rankdir = LR;
       $input
     }
   #+END_SRC

   Теперь определим функции, которые вызываются на переходах

   #+NAME: moto_actions_func
   #+BEGIN_SRC lisp
     (defun |выставление.на.продажу| ()
       "используется -> продается")
     (defun |сломался| ()
       "используется -> сломан")
     (defun |крэш| ()
       "используется -> хлам")
     (defun |угон| ()
       "используется -> угнан")
     (defun |воры.повредили| ()
       "угнан -> сломан")
     (defun |воры.разьебали| ()
       "угнан -> хлам")
     (defun |отмена.выставления.на.продажу| ()
       "продается -> используется")
     (defun |отвоз.в.ремонт| ()
       "сломан -> чинится")
     (defun |доломал| ()
       "сломан -> хлам")
     (defun |неосилил.починить| ()
       "чинится -> сломан")
     (defun |починил| ()
       "чинится -> используется")
     (defun |здесь.не.починишь| ()
       "чинится -> хлам")
     (defun |продажа| ()
       "продается -> продан")
     (defun |покупка| ()
       "продан -> куплен")
     (defun |ввод.в.эксплуатацию| ()
       "куплен -> используется")
     (defun |возврат.с.угона| ()
       "угнан -> используется")
   #+END_SRC

   Не забываем про аватар, который показывается на страничке пользователя и про набор фоток
   этого мотоцикла, доступный через таблицу связи =moto2motophoto=. Аватаром является фотка
   мотоцикла, со статусом =active=.

   Поскольку у мотоцикла может быть несколько владельцев, и один пользователь может владеть
   несколькими мотоциклами, то мы связываем мотоцикл и его владельца через таблицу связи с
   диапазоном дат - =moto2user=, при этом, если даты пересекаются - то два пользователя,
   очевидно, владеют мотоциклами вместе. Таким образом мы можем отследить историю
   мотоцикла, с момента его появления, до разборки. Учитывая планируемую "технологическую
   репутацию" пользователей это поможет сделать вывод о том, как с мотоциклом обращались.

   Дневник мотоцикла. Что случалось с мотоциклом - поломки, участие в прохватах,
   поездках-путешествиях, ремонт в сервисах - все это привязывается из =motodiary=. Это
   позволяет еще и отслеживать траты на мотоцикл.

   Также у каждого мотоцикла есть wish-list - то, что хозяин хотел бы приобрести для
   него. Мы храним это в таблице =motowish=, которая содержит ссылку на мотоцикл и его
   владельца, а также на товар, если он существует в базе товаров.

   #+NAME: moto_actions_func
   #+BEGIN_SRC lisp
     (in-package #:moto)

     ;; (loop :for item :in (with-connection *db-spec*
     ;;                        (query
     ;;                         (:limit
     ;;                          (:select 'motos
     ;;                                   :from 'bratan
     ;;                                   :where (:not (:like "" 'motos)))
     ;;                                  999999999999))) :do
     ;;    (format t "~%~A"
     ;;             (ppcre:split "\\s+" (car item))))
   #+END_SRC

** Цвет (color)

   Цвета мотоциклов - простая сущность и не имеет состояния.

   #+CAPTION: Данные цвета
   #+NAME: color_flds
     | field name | field type | note          |
     |------------+------------+---------------|
     | id         | serial     | идентификатор |
     | name       | varchar    | имя цвета     |

** Производитель (vendor)

   Цвета мотоциклов - простая сущность и не имеет состояния.

   #+CAPTION: Данные производителя
   #+NAME: vendor_flds
     | field name | field type | note              |
     |------------+------------+-------------------|
     | id         | serial     | идентификатор     |
     | name       | varchar    | имя производителя |

** Братан (bratan)

   Наш пользователь может быть зарегистрирован на http://motobratan.ru

   Чтобы предоставлять ему разнообразные сервисы, отсутстующие на на мотобратане, мы
   отражаем профили пользователя мотобратана у себя. Наш пользователь может связать свой
   профиль с профилем на мотобратане.

   Братан является простой сущностью и не имеет состояния.

   #+CAPTION: Данные роли
   #+NAME: bratan_flds
     | field name  | field type           | note                               |
     |-------------+----------------------+------------------------------------|
     | id          | serial               | идентификатор                      |
     | bratan-id   | (or db-null integer) | идентификтор на мотобратане        |
     | ts-last-upd | (or db-null bigint)  | время последнего обновления данных |
     | name        | varchar              | имя                                |
     | fio         | (or db-null varchar) | ФИО                                |
     | last-seen   | (or db-null varchar) | последнее посещение мотобратана    |
     | addr        | (or db-null varchar) | район и город                      |
     | ts_reg      | (or db-null varchar) | время регистрации                  |
     | age         | (or db-null varchar) | возраст                            |
     | birthday    | (or db-null varchar) | день рождения                      |
     | blood       | (or db-null varchar) | группа крови                       |
     | moto-exp    | (or db-null varchar) | стаж мотовождения                  |
     | phone       | (or db-null varchar) | телефон                            |
     | activityes  | (or db-null varchar) | активность                         |
     | interests   | (or db-null varchar) | интересы                           |
     | photos      | (or db-null varchar) | фотографии                         |
     | avatar      | (or db-null varchar) | аватар                             |
     | motos       | (or db-null varchar) | мотоциклы                          |

* События

  Мы используем события, чтобы отслеживать и логгировать изменения в системе, которые
  происходят в ответ на действия внешних сил.

   #+NAME: events
   #+BEGIN_SRC lisp :tangle src/events.lisp :noweb tangle :exports code :padline no :comments link
     ;;;; <<copyright>>
     ;;;; events.lisp

     (in-package #:moto)

   #+END_SRC

* Модули
** Cущности, автоматы и их тесты

   Опишем из чего состоит модуль, это описание станет частью asd-файла:

   #+NAME: mod_entity
   #+BEGIN_SRC lisp
     (:module "entity"
              :serial t
              :pathname "mod"
              :components ((:file "entity")))
   #+END_SRC

   Собственно описание модуля вынесено в файл [[file:entity.org]]

** Авторизация

   Опишем из чего состоит модуль, это описание станет частью asd-файла:

   #+NAME: mod_auth
   #+BEGIN_SRC lisp
     (:module "auth"
              :serial t
              :pathname "mod/auth"
              :components ((:static-file "auth-tpl.htm")
                           (:file "auth")))
   #+END_SRC

   Как пользователь, я хочу иметь возможность ввести логин и пароль чтобы получить доступ к
   закрытому от неавторизованных пользователей функционалу.

   Собственно описание модуля вынесено в файл [[file:auth.org]]

** Очереди
   Опишем из чего состоит модуль, это описание станет частью asd-файла:

   #+NAME: mod_que
   #+BEGIN_SRC lisp
     (:module "que"
              :serial t
              :pathname "mod/que"
              :components ((:file "que")))
   #+END_SRC

   Как пользователь, я хочу иметь возможность ввести логин и пароль чтобы получить доступ к
   закрытому от неавторизованных пользователей функционалу.

   Собственно описание модуля вынесено в файл [[file:que.org]]

** Сообщения

   Опишем из чего состоит модуль, это описание станет частью asd-файла:

   #+NAME: mod_msg
   #+BEGIN_SRC lisp
     (:module "msg"
              :serial t
              :pathname "mod/msg"
              :components ((:static-file "msg-tpl.htm")
                           (:file "msg-prepare")
                           (:file "msg")))
   #+END_SRC

   Собственно описание модуля вынесено в файл [[file:msg.org]]

** Trend

   Опишем из чего состоит модуль, это описание станет частью asd-файла:

   #+NAME: mod_trend
   #+BEGIN_SRC lisp
     ;; (:module "trend"
     ;;          :serial t
     ;;          :pathname "mod/trend"
     ;;          :components ((:static-file "trend-tpl.htm")
     ;;                       (:file "trend-prepare")
     ;;                       (:file "entityes")
     ;;                       (:file "loader")
     ;;                       (:file "trend")
     ;;                       (:file "iface")))
   #+END_SRC

   Собственно описание модуля вынесено в файл [[file:trend.org]]

** HeadHunter

   #+NAME: mod_hh
   #+BEGIN_SRC lisp
     (:module "hh"
              :serial t
              :pathname "mod/hh"
              :components ((:file "f-util")
                           (:file "util")
                           (:file "globals")
                           (:file "entityes")
                           (:file "hh")
                           (:file "iface")))
   #+END_SRC

   Собственно описание модуля вынесено в файл [[file:hh.org]]

** Граббер пользователей мотобратана

   Опишем из чего состоит модуль, это описание станет частью asd-файла:

   #+NAME: mod_bratan
   #+BEGIN_SRC lisp
     (:module "bratan"
              :serial t
              :pathname "mod/bratan"
              :components ((:file "bratan")))
   #+END_SRC

   Собственно описание модуля вынесено в файл [[file:bratan.org]]

** TODO Граббер тем мотобратана
** TODO Посты
** TODO Багзилла
** TODO Шаринг
* Сборка
** Утилиты
   #+NAME: utility_file
   #+BEGIN_SRC lisp :tangle src/util.lisp :noweb tangle :exports code  :padline no :comments link
        ;;;; <<copyright>>
        ;;;; util.lisp

     (in-package #:moto)

     ;; Превращает инициализированные поля объекта в plist
     (defun get-obj-data (obj)
       (let ((class (find-class (type-of obj)))
             (result))
         (loop :for slot :in (closer-mop:class-direct-slots class) :collect
            (let ((slot-name (closer-mop:slot-definition-name slot)))
              (when (slot-boundp obj slot-name)
                (setf result
                      (append result (list (intern (symbol-name slot-name) :keyword)
                                           (funcall slot-name obj)))))))
         result))

     ;; Assembly WHERE clause
     (defun make-clause-list (glob-rel rel args)
       (append (list glob-rel)
               (loop
                  :for i
                  :in args
                  :when (and (symbolp i)
                             (getf args i)
                             (not (symbolp (getf args i))))
                  :collect (list rel i (getf args i)))))

     ;; Макросы для корректного вывода ошибок
     (defmacro bprint (var)
       `(subseq (with-output-to-string (*standard-output*)  (pprint ,var)) 1))

     (defmacro err (var)
       `(error (format nil "ERR:[~A]" (bprint ,var))))

     ;; Отладочный вывод
     (defparameter *dbg-enable* t)
     (defparameter *dbg-indent* 1)

     (defun dbgout (out)
       (when *dbg-enable*
         (format t (format nil "~~%~~~AT~~A" *dbg-indent*) out)))

     (defmacro dbg (frmt &rest params)
       `(dbgout (format nil ,frmt ,@params)))

     ;; (macroexpand-1 '(dbg "~A~A~{~A~^,~}" "zzz" "34234" '(1 2 3 4)))

     (defun anything-to-keyword (item)
       (intern (string-upcase (format nil "~a" item)) :keyword))

     (defun alist-to-plist (alist)
       (if (not (equal (type-of alist) 'cons))
           alist
           ;;else
           (loop
              :for (key . value)
              :in alist
              :nconc (list (anything-to-keyword key) value))))

     ;; Враппер управляет сесииями и выводит все в основной (root-овый) шаблон
     ;; Если необходимо вывести ajax-данные, использует специальный тип ошибки

     (define-condition ajax (error)
       ((output :initarg :output :reader output)))

     (defmacro with-wrapper (&body body)
       `(progn
          (hunchentoot:start-session)
          (let* ((*current-user* (hunchentoot:session-value 'current-user))
                 (retval))
            (declare (special *current-user*))
            (handler-case
                (let ((output (with-output-to-string (*standard-output*)
                                (setf retval ,@body))))
                  (tpl:louis
                   (list :title "title"
                         :header (tpl:header)
                         :content retval
                         :footer (tpl:footer (list :dbg (format nil "<pre>~A</pre>" output))))))
              (ajax (ajax) (output ajax))))))

     ;; Для того чтобы генерировать и выводить элементы форм, напишем хелперы:

     (defun input (type &key name value other)
       (format nil "~%<input type=\"~A\"~A~A~A/>" type
               (if name  (format nil " name=\"~A\"" name) "")
               (if value (format nil " value=\"~A\"" value) "")
               (if other (format nil " ~A" other) "")))

     ;; (input "text" :name "zzz" :value 111)
     ;; (input "submit" :name "submit-btn" :value "send")

     (defmacro select ((name &optional attrs) &body options)
       `(format nil "~%<select name=\"~A\"~A>~{~%~A~}~%</select>"
                ,name
                (aif ,attrs (format nil " ~A" it) "")
                (loop :for (name value selected) :in ,@options :collect
                   (format nil "<option value=\"~A\"~A>~A</option>"
                           value
                           (if selected (format nil " ~A" selected) "")
                           name))))

     (defun fld (name &optional (value ""))
       (input "text" :name name :value value))

     (defun btn (name &optional (value ""))
       (input "button" :name name :value value))

     (defun hid (name &optional (value ""))
       (input "hidden" :name name :value value))

     (defun submit (&optional value)
       (if value
           (input "submit" :value value)
           (input "submit")))

     (defun act-btn (act data title)
       (format nil "~%~{~%~A~}"
               (list
                (hid "act"  act)
                (hid "data" data)
                (submit title))))

     (defmacro row (title &body body)
       `(format nil "~%<tr>~%<td>~A</td>~%<td>~A~%</td>~%</tr>"
                ,title
                ,@body))

     ;; (row "thetitrle" (submit))

     (defun td (dat)
       (format nil "~%<td>~%~A~%</td>" dat))

     (defun tr (&rest dat)
       (format nil "~%<tr>~%~{~A~}~%</tr>"
               dat))

     ;; (tr "wfewf")
     ;; (tr "wfewf" 1111)

     (defun frm (contents &key name (method "POST") action)
       (format nil "~%<form method=\"~A\"~A~A>~{~A~}~%</form>"
               method
               (if name (format nil " name=\"~A\"" name) "")
               (if action (format nil " action=\"~A\"" action) "")
               (if (consp contents)
                   contents
                   (list contents))))

     ;; (frm "form-content" :name "nnnnn")

     (defun tbl (contents &key name border)
       (format nil "~%<table~A~A>~{~A~}~%</table>"
               (if name (format nil " name=\"~A\"" name) "")
               (if border (format nil " border=\"~A\"" border) "")
               (if (consp contents)
                   contents
                   (list contents))))

     ;; (tbl (list "zzz") :name "table")

     ;; (frm (tbl (list (row "username" (fld "user")))))

     ;; Макрос создает маршрут и маршрут-контроллер, таким образом,
     ;; чтобы связать действия контроллера и кнопки
     (defmacro define-page (name url (&body body) &rest rest)
       (let ((name-ctrl (intern (format nil "~A-CTRL" (symbol-name name)))))
         `(symbol-macrolet (,@(loop :for (act exp body) :in rest :collect
                                 `(,(intern (format nil "%~A%" (symbol-name act))) ,exp)))
            (restas:define-route ,name (,url)
              (with-wrapper
                ,body))
            (restas:define-route ,name-ctrl (,url :method :post)
              (with-wrapper
                (let* ((p (alist-to-plist (hunchentoot:post-parameters*))))
                  (cond
                    ,@(append
                       (loop :for (act exp body) :in rest :collect
                          `((string= ,(symbol-name act) (getf p :act))
                            ,body))
                       `((t (format nil "unk act : ~A" (bprint p))))))))))))


     ;; Макрос создает интерфейс для удаления и добавления сущностей
     (defmacro define-iface-add-del-entity (name url h1 h2 content all-entity-func url-elt fields new-form new del)
       `(define-page ,name ,url
          (concatenate
           'string "<h1>" ,h1 "</h1>" ,content "<br /><br />"
           (tbl
            (with-collection (i (funcall ,all-entity-func))
              (tr
               (td (format nil "<a href=\"/~A/~A\">~A</a>" ,url-elt (id i) (id i)))
               ,@(loop :for fld :in fields :collect
                    `(td (,fld i)))
               (td (frm %del%))))
            :border 1)
           "<h2>" ,h2 "</h2>"
           ,new-form)
          ,new
          ,del))

     ;; Чтобы выводить коллекции напишем макрос

     (defmacro with-collection ((item collection) &body body)
       `(loop :for ,item :in ,collection :collect
           ,@body))

     ;; Чтобы выводить элемент коллекции напишем макрос

     (defmacro with-element ((item elt) &body body)
       `(let ((,item ,elt))
          (list
           ,@body)))

     (defun replace-all (string part replacement &key (test #'char=))
       "Returns a new string in which all the occurences of the part
           is replaced with replacement."
       (with-output-to-string (out)
         (loop with part-length = (length part)
            for old-pos = 0 then (+ pos part-length)
            for pos = (search part string
                              :start2 old-pos
                              :test test)
            do (write-string string out
                             :start old-pos
                             :end (or pos (length string)))
            when pos do (write-string replacement out)
            while pos)))

     (defun explore-dir (path)
       (let ((raw (directory path))
             (dirs)
             (files))
         (mapcar #'(lambda (x)
                     (if (cl-fad:directory-pathname-p x)
                         (push x dirs)
                         (push x files)))
                 raw)
         (values dirs files raw)))

     ;; clear-db
     (defun drop (tbl-lst)
       (let ((tables tbl-lst))
         (flet ((rmtbl (tblname)
                  (when (with-connection *db-spec*
                          (query (:select 'table_name :from 'information_schema.tables :where
                                          (:and (:= 'table_schema "public")
                                                (:= 'table_name tblname)))))
                    (with-connection *db-spec*
                      (query (:drop-table (intern (string-upcase tblname))))))))
           (loop :for tblname :in tables :collect
              (rmtbl tblname)))))
   #+END_SRC

** Глобальные определения

   #+NAME: globals
   #+BEGIN_SRC lisp :tangle src/globals.lisp :noweb tangle :exports code :padline no :comments link
     ;;;; <<copyright>>
     (in-package #:moto)

     ;; One thing we have to do is make sure that CL-WHO and Parenscript
     ;; use different string delimiters so that literal strings will
     ;; work as intended in JavaScript code inlined in HTML element properties.
     (setf *js-string-delimiter* #\")

     ;; без этого происходит ошибка при компиляции в js
     (defparameter PARENSCRIPT::SUPPRESS-VALUES nil)

     ;; Подключение к базе данных
     (defvar *db-name* "ylg_new")
     (defvar *db-user* "ylg")
     (defvar *db-pass* "6mEfBjyLrSzlE")
     (defvar *db-serv* "localhost")

     (defvar *db-spec* (list "ylg_new" "ylg" "6mEfBjyLrSzlE" "localhost"))

     ;; clear db
     (drop '("user" "role" "group" "user2group" "avatar" "msg"
             "que" "quelt" "bratan" "cmpx" "plex" "crps" "flat"
             "city" "district" "metro" "deadline"))
   #+END_SRC

** Каркас проекта

   Для генерации "с чистого листа" необходимы функции генерации сущностей, они лежат в
   файле =generators.el=

   Чтобы их подключить - можно сделать M-x load-file generators.el в emacs-е.

   Эти функции помещаются в =generators.el= при =tangle= и редактировать их можно в
   соответствующем разделе этого файла. Для успешной генерации сущностей, они должны быть
   загружены в emacs.

   Файл =prepare= должен идти до файла =util= и остальных, так как в нем компилируются
   шаблоны, от которых зависит =util=

   Файл =globals= должен идти до файла =entity= так как в нем происходит подключение к базе
   данных, которое используют тесты сущностей и автоматов.

   #+NAME: defsystem
   #+BEGIN_SRC lisp :tangle moto.asd :noweb tangle :exports code :padline no :comments link
          ;;;; <<copyright>>
          ;;;; moto.asd

     (asdf:defsystem #:moto
       :serial t
       :pathname "src"
       :depends-on (#:closer-mop
                    #:postmodern
                    #:anaphora
                    #:cl-ppcre
                    #:restas
                    #:restas-directory-publisher
                    #:closure-template
                    #:cl-json
                    #:cl-base64
                    #:drakma
                    #:split-sequence
                    #:cl-html5-parser
                    #:cl-who
                    #:parenscript
                    #:cl-fad
                    #:optima
                    #:fare-quasiquote-extras
                    )
       :description "site for bikers"
       :author "rigidus"
       :version "0.0.3"
       :license "GNU AGPLv3"
       :components ((:file "package")    ;; файл пакетов
                    (:static-file "templates.htm")
                    (:file "prepare")    ;; подготовка к старту
                    (:file "util")       ;; файл с утилитами
                    (:file "globals")    ;; файл с глобальными определеями
                    ;; Модуль сущностей, автоматов и их тестов
                    <<mod_entity>>
                    (:file "entityes")   ;; Сущности и автоматы
                    (:file "moto")       ;; стартовый файл
                    ;; Модуль авторизации (зависит от определения сущностей в стартовом файле)
                    <<mod_auth>>
                    ;; Модуль очередей
                    <<mod_que>>
                    ;; Модуль сообщений
                    <<mod_msg>>
                    ;; Модуль trend
                    <<mod_trend>>
                    ;; Модуль мотобратан
                    <<mod_bratan>>
                    ;; Модуль HeadHunter
                    <<mod_hh>>
                    (:file "events")     ;; события системы
                    (:file "iface")      ;; файл веб-интерфейса
                    ))
   #+END_SRC

** Пакеты

   Соберем весь код в пакет:

   #+NAME: package
   #+BEGIN_SRC lisp :tangle src/package.lisp :noweb tangle :exports code :padline no :comments link
     ;;;; <<copyright>>
     ;;;; package.lisp

     (restas:define-module #:moto
       (:use  #:cl #:closer-mop #:postmodern #:anaphora #:hunchentoot #:cl-who #:parenscript #:cl-fad #:optima)
       (:shadowing-import-from #:closer-mop
                               #:defclass
                               #:defmethod
                               #:standard-class
                               #:ensure-generic-function
                               #:defgeneric
                               #:standard-generic-function
                               #:class-name))
   #+END_SRC

** Сущности и автоматы

   Соберем все сущности и автоматы

   #+NAME: entity_and_automates
   #+BEGIN_SRC lisp :tangle src/entityes.lisp :noweb tangle :exports none :padline no :comments link
     ;;;; <<copyright>>
     (in-package #:moto)

     <<gen_automat("user", "пользователя", user_flds, user_state)>>

     <<user_actions_func>>

     <<create_user>>


     <<gen_entity("role", "роли", role_flds)>>

     <<create_roles>>


     <<gen_entity("group", "группы", group_flds)>>

     <<create_groups>>

     <<gen_entity("user2group", "связи пользователя и группы", user2group_flds)>>


     <<gen_automat("msg", "сообщения", msg_flds, msg_state)>>

     <<msg_actions_func>>


     <<gen_entity("que", "очереди", que_flds)>>

     <<que_contents>>

     <<gen_entity("quelt", "элемента очереди", quelt_flds)>>

     <<quelt_contents>>


     <<gen_automat("avatar", "аватара", avatar_flds, avatar_state)>>

     <<avatar_actions_func>>

     <<create_avatar>>


     <<gen_automat("moto", "мотоцикла", moto_flds, moto_state)>>

     <<moto_actions_func>>

     <<create_moto>>


     <<gen_entity("color", "цвета", color_flds)>>

     <<gen_entity("vendor", "производителя", vendor_flds)>>

     <<gen_entity("bratan", "братана", bratan_flds)>>
   #+END_SRC

** Подготовка к старту

   Подготовка включает в себя загрузку всех необходимых библиотек, компиляцию шаблонов, и,
   возможно, инициализацию окружения.

   #+NAME: prepare
   #+BEGIN_SRC lisp :tangle src/prepare.lisp :noweb tangle :exports code :exports none :padline no :comments link
     ;;;; <<copyright>>
     ;;;; prepare.lisp

     (in-package #:moto)

     (defparameter *repo-folder* "repo")
     (defparameter *prj-folder* "moto")

     ;; Базовый путь, от которого будем все считать
     (defparameter *base-path*
       (format nil "~A~A"
               (namestring (user-homedir-pathname))
               (format nil "~A/~A/src/"
                       ,*repo-folder*
                       ,*prj-folder*)))

     ;; Путь к данным
     (defparameter *data-path*
       (format nil "~A~A"
               (namestring (user-homedir-pathname))
               (format nil "~A/~A/data/"
                       ,*repo-folder*
                       ,*prj-folder*)))

     ;; Путь к стилям
     (defparameter *css-path*
       (format nil "~A~A"
               (namestring (user-homedir-pathname))
               (format nil "~A/~A/css/"
                       ,*repo-folder*
                       ,*prj-folder*)))

     ;; Путь к картинкам
     (defparameter *img-path*
       (format nil "~A~A"
               (namestring (user-homedir-pathname))
               (format nil "~A/~A/img/"
                       ,*repo-folder*
                       ,*prj-folder*)))
     (defparameter *pic-path*
       (format nil "~A~A"
               (namestring (user-homedir-pathname))
               (format nil "~A/~A/pic/"
                       ,*repo-folder*
                       ,*prj-folder*)))

     ;; Путь к шрифтам
     (defparameter *font-path*
       (format nil "~A~A"
               (namestring (user-homedir-pathname))
               (format nil "~A/~A/fonts/"
                       ,*repo-folder*
                       ,*prj-folder*)))

     ;; Путь к скриптам
     (defparameter *js-path*
       (format nil "~A~A"
               (namestring (user-homedir-pathname))
               (format nil "~A/~A/js/"
                       ,*repo-folder*
                       ,*prj-folder*)))


     ;; Компилируем шаблоны
     (closure-template:compile-template
      :common-lisp-backend (pathname (concatenate 'string *base-path* "templates.htm")))

     ;; submodules

     (restas:mount-module -css- (#:restas.directory-publisher)
       (:url "/css/")
       (restas.directory-publisher:*directory* *css-path*))

     (restas:mount-module -img- (#:restas.directory-publisher)
       (:url "/img/")
       (restas.directory-publisher:*directory* *img-path*))

     (restas:mount-module -pic- (#:restas.directory-publisher)
       (:url "/pic/")
       (restas.directory-publisher:*directory* *pic-path*))

     (restas:mount-module -font- (#:restas.directory-publisher)
       (:url "/font/")
       (restas.directory-publisher:*directory* *font-path*))

     (restas:mount-module -js- (#:restas.directory-publisher)
       (:url "/js/")
       (restas.directory-publisher:*directory* *js-path*))

     ;; (restas:mount-module -resources- (#:restas.directory-publisher)
     ;;   (:url "/resources/")
     ;;   (restas.directory-publisher:*directory* "/resources/")
     ;;   (restas.directory-publisher:*autoindex* t))
   #+END_SRC

** Точка входа
   #+NAME: enter_point
   #+BEGIN_SRC lisp :tangle src/moto.lisp :noweb tangle :exports code :padline no :comments link
     ;;;; <<copyright>>
     ;;;; moto.lisp

     (in-package #:moto)

     (defun main ()
       ;; start
       (restas:start '#:moto :port 9997)
       (restas:debug-mode-on)
       ;; (restas:debugg-mode-off)
       (setf hunchentoot:*catch-errors-p* t))

     (main)
   #+END_SRC

** Readme
   #+NAME: enter_point
   #+BEGIN_SRC org :tangle README.org :noweb tangle :exports code

     ,*Внимание!*

     Если вы просто хотите посмотреть пример исходника, написанного в стиле
     литературного программирования - то вам сюда: [[./hh.org]]

     Этот документ отвечает на вопросы:
     - Что нужно сделать чтобы собрать проект
     - Что нужно сделать чтобы запустить собранный проект
     - Как установить и настроить Postgres
     - Зачем это все

     Можно запустить проект, не собирая его, если вы просто хотите
     попробовать. Но в этом нет фана, потому что все интересное именно в
     литературном программировании и генерации кода.

     ,* Сборка

       На момент, когда вы начнете это делать, у вас должны стоять:
       - emacs (http://www.gnu.org/software/emacs/)
       - git (http://git-scm.com/)
       - sbcl (http://sbcl.org/)
       - quicklisp (http://quicklisp.org/)
       - postgresql (http://www.postgresql.org/)
       Их установка, как правило, тривиальна, поэтому не будет здесь
       описываться.

       Перед тем, как начать сборку, создаем каталог, где будет все лежать
       и переходим в него:

       =mkdir ~/repo=

       =cd ~/repo=

     ,** Orgmode

        Находясь в каталоге =~/repo=, скачиваем последнюю версию
        =org-mode= - расширения, которое уже стоит в емаксе, но, к
        сожалению, часто не самой свежей версии. В той версии, которую я
        использую, поменялся способ работы с org-tables, поэтому я
        рекомендую забирать версию с моего репозитория:

        =git-clone https://github.com/rigidus/org-mode.git=

        Переходим в появившийся каталог и собираем:

        =cd org-mode/lisp=

        =make autoloads=

        Открываем файл конфигурации emacs =~/.emacs.d/init.el= и
        прописываем собранный org-mode:

        =;; OrgMode http://orgmode.org/manual/Installation.html=

        =(add-to-list 'load-path "/home/rigidus/repo/org-mode/lisp")=

        =(require 'org-install)=

        Возвращаемся в исходный каталог:

        =cd ~/repo=

     ,** Проект

        Скачиваем последнюю версию проекта:

        =cd ~/repo=

        =git-clone https://github.com/rigidus/moto.git=

        Открываем =~/repo/moto/doc.org= в emacs-e

        Загружаем генераторы:

        =M-x load-file= =~/repo/moto/generators.el=

        Без этого шага при генерации не найдутся некоторые необходимые
        функции, что вызовет ошибку генерации.

        Выполняем генерацию кода (org-babel-tangle) в открытом в emacs-е
        файле =~/repo/moto/doc.org=, нажимая комбинацию клавишь =C-c C-v t=

        Сгенерируется множество файлов проекта, в основном, в каталоге
        =~/repo/moto/src=

        Выполняем генерацию документации в формате html (org-export) в
        открытом в emacs-е файле =~/repo/moto/doc.org=, нажимая комбинацию
        клавиш =C-c C-e h=

        Сгенерируется файл документации =~/repo/moto/doc.html=

        Аналогичным образом можно поступать со всеми файлами модулей - это
        файлы с расширением =org=, которые лежат в корневом каталоге
        =~/repo/moto/=

        Если понадобится изменить процесс генерации, то функции, которые за
        него отвечают, лежат в "Определения сущностей" -> "Функции для
        кодогенерации сущностей"

     ,* Запуск

       Чтобы запустить проект, необходимо иметь:
       - sbcl
       - quicklisp

         Необходимо, чтобы quicklisp мог найти систему проекта. Для этого
         в =~/.sbclrc= дописываем следущий код

         ,#+BEGIN_SRC lisp
           ,#+quicklisp
           (mapcar #'(lambda (x)
                       (pushnew x ql:*local-project-directories*))
                  (list
                        #P"~/repo/moto/"
                        ))
         ,#+END_SRC

       - postgres

         Эти данные для входа лежат в ~/repo/moto/doc.org в разделе
         "Глобальные определения"
         - Пользователь postgres
         - Базу данных

       Обеспечив выполнение этих условий, заходим в =emacs=, набираем =M-x
       slime= и в открывшемся буфере =(ql:quickload "moto")=

       Все должно заработать. Если нет - связывайтесь со мной.

       Чуть не забыл, веб-интерфейс размещен на порту 9997

     ,* Установка и настройка Postgres

       ,#+BEGIN_COMMENT
           TODO сделать линки на получение значений с глобальных определений doc.org, если возможно
       ,#+END_COMMENT

       В =~/repo/moto/doc.org= в секции "Глобальные определения" написаны имя базы данных, логин и пароль

       Для систем Ubuntu/Debian:

       ,#+BEGIN_SRC bash
          sudo apt-get install postgresql postgresql-contrib postgresql-client
          sudo -i -u postgres

          postgres$ createuser --interactive
          ....
          postgres$ createdb DB_NAME
          postgres$ psql -d DB_NAME
       ,#+END_SRC

       В консоль postrges ввести:

       ,#+BEGIN_SRC psql
          ALTER USER ylg PASSWORD '...';
          \q
       ,#+END_SRC

       См. туториал https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-14-04

     ,* Зачем это все

       Это все было задумано и написано (и пишется в данный момент) как
       исследование ряда подходов в программировании в применении к
       конкретным практическим задачам. Ну и ради общественной пользы,
       понимаемой очень широко, включая как пользу от самого продукта, так
       и пользу от исследуемых технологий и приемов их применения.

       Весь код лицензируется под свободной лицензией GPLv3 и вы вправе
       реализовывать все связанные с этим свободы. Контрибьюторы
       приветствуются, не только в написании кода, но и в привлечении
       пользователей, изучении технологий, тестировании и критике идей.

       Если есть какой-то вопрос или непонятный момент - не стесняйтесь
       писать прямо в гитхаб.


   #+END_SRC

** Copyright

   Из-за того что есть множество людей, стремящихся нарушить лицензию,
   добавляем копирайт.

   #+NAME: copyright
   #+BEGIN_SRC lisp
     Copyright © 2014 Glukhov Mikhail. All rights reserved.
     Licensed under the GNU AGPLv3
   #+END_SRC

* Идеи

  Необходимы заметки одного пользователя о другом. И шаринг их для группы лиц

  http://www.motobratan.ru/motoprogress/230.html
  Флип-чарт - как чопперасты видят: спортбайкеров, эндурастов етц
  Только отслеживаемые люди (веб-камера, документ етц)

  Что такое Кодекс чести Coursera?

    Я зарегистрирую только одну учётную запись.
    Все мои ответы на задания, включая опросы и экзамены будут моей собственной работой (за
    исключением заданий, которые недвусмысленно допускают возможность совместной работы).
    Я не буду выкладывать в открытый доступ ответы на вопросы домашних работ, опросов или
    экзаменов. Это включает как написанные мною лично ответы на вопросы, так и любые
    официальные ответы, предоставленные сотрудниками курса.
    Я не буду прибегать к каким-либо уловкам, с помощью которых обманным путём могут быть
    улучшены мои результаты или улучшены/ухудшены результаты других.

    Курсы по ремонту мотоциклов

    Умный поиск с привязкой к местонахождению. Ищу то-то - поиск по товарам с ценами и расстоянием

    Технологическая репутация пользователей - кто как относится к своим мотоциклам. Может
    заполняться сервис-менами.

  Специальная система приглашений - ты можешь завести друга, а потому передать ему его
  аккаунт

  Не забыть адреса травмпунктов и контакты хороших врачей и юристов

** Обозначения и маркировка мотошин

Рассмотрим данный вопрос на конкретном примере. Например, на боковине #шины имеется
обозначение 140/80 - 18 M/C 70M TL

№1 Производитель или название бренда
№2 Выражение максимальной нагрузки на шину при указанном давлении (psi).
№3 Название модели #мотошины
№4 Стрелка, указывающая направление вращения колеса.Обозначение относится к дополнительной
маркировке
№5 Ширина профиля покрышки в миллиметрах. В данном случае - 140 №6 Высота профиля в
процентах от ширины.В данном случае - 80. Это значение не указывается, если ширина выражена
в дюймах. Например, 3,5-18.
№7 Индекс обозначающий конструкцию шины. В данном случае "-" - диагональная
конструкция. Индекс "R"- радиальная конструкция шины. №8 Посадочный размер внутреннего
кольца покрышки в дюймах. На нашей шине он равен 18. Буквы М/С - аббревиатура от motorcycle
. Означает, что шины относятся к категории мотоциклетных шин. Встречается на мотошинах,
имеющих "автомобильные" размеры.
№9 Индекс нагрузки ( в рассматриваем случае 70). Число , соответствующее нагрузке, которую
способна выдержать шина при максимальном внутреннем давлении воздуха. Существует таблица
индексов нагрузок, по которой определяется ее максимальное значение. №10 M - индекс
скорости. Читайте подробнее о индексах скорости.
№11 TT - тип шины ТТ - аббревиатура от Tube Type (камерный тип) - обозначение для покрышек,
предназначенных для использования только вместе с камерой. Обозначение TL - аббревиатура от
Tubeless.(бескамерная) - указывает на то, что шину следует использовать без
камеры. Герметичность обеспечивает слой особой резины, нанесенный на внутреннее
кольцо. Должная фиксация шины на ободе достигается за счет хампов – особых конструктивным
элементам колесного диска.
№12 Номер согласно ECE R 75
№13 Наименование типа протектора. №14 Аббревиатура DOT.
№15 Дата изготовления шины - три или четыре цифры в овале на одной из боковин. У некоторых
производителей – три или четыре последние цифры в индивидуальном номере покрышки. Например,
(178) - 17-я неделя 1998 г.. С 2000 года введено 4-х значное число обозначение. К примеру
(1105) – 11 неделя 2005 года

Обозначение и маркировка шин

Обозначение и маркировка шин, выпускаемых в Европе, соответствует Евростандарту, а в США -
требованиями Транспортного управления этой страны. Следует отметить, что обозначения и
маркировка отечественных и импортных шин по отдельным позициям совпадают, хотя среди них
имеются характерные различия. Прежде всего рассмотрим маркировки шин, действующих в Европе:
1 - Пример: 185/65 R15 87Т - размер шины и ее техническая характеристика: 185 - ширина
профиля шины в мм.; 65 - отношение высоты профиля к ее ширине, выраженное в процентах; R -
радиальная конструкция шины; 15 - посадочный диаметр обода в дюймах; 87 - индекс
грузоподъемности.

Ряд зарубежных фирм указывают максимальную нагрузку (MAX LOAD) в кг. и английских фунтах;
Т - индекс максимальной скорости, на которую рассчитана шина - надпись "Radial" - указывает
на радиальную конструкцию шины; - "Tubeless" - маркировка бескамерной шины. Камерная шина
обозначается "TUBE TYPE";
- "M+S" (Mud+Snow -грязь+снег) - тип рисунка протектора. Маркировка обозначает, что шина
  предназначена для эксплуатации в зимний период года и по грязи. - цифры 376 - дата выпуска
  шины: изготовлена на 37-й недели 1996 года - знак Е одним цифровым индексом (на других
  шинах может быть двух цифровой индекс) указывает, что шина проверена на соответствие
  европейскому стандарту безопасности - Правилу N 30 Европейской экономической комиссии
  ООН. Индекс в кружке - условный номер страны, где назначенная правительством комиссия
  провела проверку. Например, Е - проверено в Швеции. Пятизначный (может быть и
  шестизначный) индекс, нанесенный рядом с кружком, означает номер сертификата,
  свидетельствующий о положительных результатах проверки, и выданного страной,
  осуществлявшей проверку; - страна, в которой находится предприятие-изготовитель шин (Made
  in Germany -сделано в Германии, Made in Europe - сделано в Европе и т.д.);

Дополнительные маркировки, действующие в США: - DOT - знак, который означает, что шина
отвечает нормативным требованиям Транспортного управления США; - DM AB CD EFG - код,
означающий место изготовления, размер и тип шины; - максимально допустимые в США нагрузка и
внутреннее давление воздуха в шине: max Load 545kg (1202 lbs) - 545кг (1202 фунта), max
Pressure 300 кПа (44psi) - 3,0 кгс/см2 (44 фунта на квадратный дюйм); - Plies Tread area:1
Rayon + 2 Steel + 1 Nylon Sidewall: 1 Rayon - особенности конструкции шины: в брекере один
слой вискозного корда; два слоя стального и один слой нейлонового корда; в боковине один
слой вискозного корда; - TWI (Tread Wear Indiration) -указатели индикаторов износа
(минимально допустимая глубина) рисунка протектора шины.Указатели располагаются равномерно в
шести- восьми местах по окружности. Маркировка TWI может быть со стрелкой. Индикатор износа
иногда изображается одной стрелкой.Индикатор выполняется в виде выступа высотой 1.6 мм (для
легких автомобилей) и располагается в углублении протектора;

- Treadwear 180 - относительная износоустойчивость рисунка протектора.Отвечает специальным
  стандартным тестам США; - Traction A - оценка влажных условий А, В или С ( специальный
  тест США); - Temperatyre B - температурная устойчивость на больших скоростях движения А, В
  или С (специальный тест США);
- Safetywarning - требование техники безопасности при монтаже шины на обод и при
  использовании шины. На некоторых моделях шин нового поколения для легковых автомобилей
  введена дополнительная маркировка.На боковине шин фирмы "Pirelli" ставится стрелка,
  указывающая направление вращения колеса. На боковых шинах других фирм наносятся две
  стрелки с надписью "Rotation" (направление вращения). При сборке колеса необходимо
  учитывать рекомендации маркировки: направление вращения колеса при движении автомобиля
  вперед должно совпадать с направлением, указанным стрелкой (стрелками).

Индекс грузоподъемности, кг/ #колесо
60 - 250
62 - 265
64 - 280
66 - 300
68 - 315
70 - 335
72 - 355
74 - 375
76 - 400
78 - 425
80 - 450
82 - 475
84 - 500
86 - 530
88 - 560
90 - 600

Индекс максимальной скорости, км/ч
I - 100
K - 110
L - 120
M - 130
N - 140
P - 150
Q - 160
R - 170
S - 180
T - 190
H - 210
V - 240
VR - 210-240
ZR - от 240
** Очень интересный способ добавлять фичи
   Сначала мы отталкиваемся от фич и описываем их
   Описание фич сопровождаются кодом, который генерирует структуры данных, которые являются
   источником для генераторов сущностий.
** Способ вести обсуждение графически

   В ряде случаев, в ответ на одно утверждение к нему возникает
   множество вопросов. Было бы здорово оформлять их в виде отдельных
   кружков, которые раскрываются в собственно текст, тогда никакие
   ветви не будут упущены. Я представляю это в виде древа жизни из
   кабаллы, где ветви обсуждений могут соединяться и расходиться.
** Фейнмановский подход

В средние века процветало множество нелепых идей, вроде того, что рог
носорога повышает потенцию. Затем люди придумали метод, как отделить
плодотворные идеи от неплодотворных. Метод состоял в проверке того,
работает идея или нет. Этот метод, конечно, перерос в науку, которая
развивалась настолько успешно, что теперь мы живем в век науки. И,
живя в век науки, мы уже с трудом понимаем, как вообще могли
существовать знахари, если ничего из того, что они предлагали, не
действовало или действовало очень слабо.
      Но даже в наши дни приходится встречать множество людей, которые
рано или поздно втягивают тебя в обсуждение НЛО или астрологии, или
какой-то формы мистицизма, или расширения границ сознания, новых типов
мышления, экстрасенсорного восприятия и т.п. Я пришел к выводу, что
все это не относится к науке.

У тихоокеанских островитян есть религия самолетопоклонников. Во время
войны они видели, как приземляются самолеты, полные всяких хороших
вещей, и они хотят, чтобы так было и теперь. Поэтому они устроили
что-то вроде взлетно-посадочных полос, по сторонам их разложили
костры, построили деревянную хижину, в которой сидит человек с
деревяшками в форме наушников на голове и бамбуковыми палочками,
торчащими как антенны - он диспетчер, - и они ждут, когда прилетят
самолеты. Они делают все правильно. По форме все верно. Все выглядит
так же, как и раньше, но все это не действует. Самолеты не садятся. Я
называю упомянутые науки науками самолетопоклонников, потому что люди,
которые ими занимаются, следуют всем внешним правилам и формам
научного исследования, но упускают что-то главное, так как самолеты не
приземляются.

Теперь мне, конечно, надлежит сообщить вам, что именно они
упускают. Но это почти так же трудно, как и объяснить тихоокеанским
островитянам, что им следует предпринять, чтобы как-то повысить
благосостояние своего общества. Здесь не отделаешься чем-то простым,
вроде советов, как улучшить форму наушников. Но я заметил отсутствие
одной черты во всех науках самолетопоклонников. То, что я собираюсь
сообщить, мы никогда прямо не обсуждаем, но надеемся, что вы все
вынесли это из школы: вся история научных исследований наводит на эту
мысль. Поэтому стоит назвать ее сейчас со всей определенностью. Это
научная честность, принцип научного мышления, соответствующий
полнейшей честности, честности, доведенной до крайности. Например,
если вы ставите эксперимент, вы должны сообщать обо всем, что, с вашей
точки зрения, может сделать его несостоятельным. Сообщайте не только
то, что подтверждает вашу правоту. Приведите все другие причины,
которыми можно объяснить ваши результаты, все ваши сомнения,
устраненные в ходе других экспериментов, и описания этих
экспериментов, чтобы другие могли убедиться, что они действительно
устранены.

Если вы подозреваете, что какие-то детали могут поставить под сомнение
вашу интерпретацию, - приведите их. Если что-то кажется вам не
правильным или предположительно не правильным, сделайте все, что в
ваших силах, чтобы в этом разобраться. Если вы создали теорию и
пропагандируете ее, приводите все факты, которые с ней не согласуются
так же, как и те, которые ее подтверждают. Тут есть и более сложная
проблема. Когда много разных идей соединяется в сложную теорию,
следует убедиться, что теория объясняет не только те факты, которые
явились начальным толчком к ее созданию. Законченная теория должна
предсказывать и что-то новое, она должна иметь какие-то дополнительные
следствия.
      Короче говоря, моя мысль состоит в том, что надо стараться
опубликовать всю информацию, которая поможет другим оценить значение
вашей работы, а не одностороннюю информацию, ведущую к выводам в
заданном направлении.

Проще всего эта мысль объясняется, если сравнить ее, например, с
рекламой. Вчера вечером я услышал, что подсолнечное масло "Вессон" не
проникает в пищу. Что ж, это действительно так. Это нельзя назвать
нечестным; но я говорю сейчас не о честности и нечестности, а о
научной цельности, которая представляет совсем другой уровень. К этому
рекламному объявлению следовало добавить то, что ни одно подсолнечное
масло не проникает в пищу, если ее готовить при определенной
температуре. Если же ее готовить при другой температуре, то в нее
будет проникать любое масло, включая и масло "Вессон". Таким образом,
правдивым был смысл, который передавался, но не факт, а с разницей
между ними нам и приходиться иметь дело.

Весь наш опыт учит, что правду не скроешь. Другие экспериментаторы
повторят ваш эксперимент и подтвердят или опровергнут ваши
результаты. Явления природы будут соответствовать или противоречить
вашей теории. И хотя вы, возможно, завоюете временную славу и
создадите ажиотаж, вы не заработаете хорошей репутации как ученый,
если не были максимально старательны в этом отношении. И вот эта
честность, это старанье не обманывать самого себя и отсутствует
большей частью в научных исследованиях самолетопоклонников.

Их основная трудность происходит, конечно, из сложности самого
предмета и неприменимости к нему научного метода. Однако надо
заметить, что это не единственная трудность. Как бы то ни было, но
самолеты не приземляются.
      На множестве опытов мы научились избегать некоторых видов
самообмана. Один пример: Милликен измерял заряд электрона в
эксперименте с падающими масляными каплями. И получил несколько
заниженный, как мы теперь знаем, результат. Его незначительная ошибка
объяснялась тем, что использовалось неверное значение для вязкости
воздуха. Интересно проследить историю измерений заряда электрона после
Милликена. Если построить график этих измерений как функцию времени,
видно, что каждый следующий результат чуть выше предыдущего, и так до
тех пор, пока результаты не остановились на некотором более высоком
уровне.
      Почему же сразу не обнаружили, что число несколько больше?
Ученые стыдятся этой истории, так как очевидно, что происходило
следующее: когда получалось число слишком отличающееся от результата
Милликена, экспериментаторы начинали искать у себя ошибку. Когда же
результат не очень отличался от величины, полученной Милликеном, он не
проверялся так тщательно. И вот слишком далекие числа исключались и
т.п. Теперь мы знаем про все эти уловки и больше не страдаем таким
заболеванием.
      К сожалению, долгая история того, как люди учились не дурачить
сами себя и руководствоваться полнейшей научной честностью, не
включена ни в один известный мне курс. Мы надеемся, что вы усвоили ее
из самого духа науки.
      Итак, главный принцип - не дурачить самого себя. А себя как раз
легче всего одурачить. Здесь надо быть очень внимательным. А если вы
не дурачите сами себя, вам легко будет не дурачить других ученых. Тут
нужна просто обычная честность.

Велосипедизация

Но еще более характерны для плохой науки другие виды ошибок. В
Корнелле я часто беседовал со студентами и преподавателями
психологического факультета. Одна студентка рассказала мне, какой она
хочет провести эксперимент. Кто-то обнаружил, что при определенных
условиях, X, крысы делают что-то, A. Она хотела проверить, будут ли
крысы по-прежнему делать A, если изменить условия на Y. Она собиралась
поставить эксперимент при условиях Y и посмотреть, будут ли крысы
делать A.
      Я объяснил ей, что сначала необходимо повторить в ее лаборатории
тот, другой, эксперимент - посмотреть, получит ли она при условиях X
результат A, а потом изменить X на Y и следить, изменится ли A. Тогда
она будет уверена, что единственное изменение в условия эксперимента
внесено ею самой и находится под ее контролем.
      Ей очень понравилась эта новая идея, и она отправилась к своему
профессору. Но он ответил: "Нет, делать этого не надо. Эксперимент уже
поставлен, и Вы будете терять время". Это было году в 1947-м или около
того, когда общая политика состояла в том, чтобы не повторять
психологические эксперименты, а только изменять условия и смотреть,
что получится.

Но и в психологии не все эксперименты так плохи. Например, было
поставлено множество экспериментов, в которых крысы бегали по
разнообразным лабиринтам, но они почти не давали результатов. И вот в
1937 г. человек по фамилии Янг поставил очень интересный опыт. Он
устроил длинный коридор с дверьми по обе стороны. С одной стороны
впускали крыс, а с другой стороны находилась пища. Янг хотел узнать,
можно ли научить крыс всегда входить в третью по счету дверь от того
места, где их впустили в коридор. Нет. Крысы сейчас же бежали к той
двери, за которой еда была в прошлый раз. Возник вопрос: как крысы
узнают дверь? Ведь коридор был прекрасно изготовлен и весь был
совершенно однообразный. Очевидно, что-то отличало эту дверь от
других. Янг очень аккуратно выкрасил все двери, так что поверхность их
стала абсолютно одинаковой. Крысы все равно различали двери.
      Потом Янг подумал, что крысы ориентируются по запаху, и при
помощи химических средств стал менять запах после каждого опыта. Крысы
все равно находили дверь. Потом он решил, что крысы, как и всякие
разумные существа, могут ориентироваться по свету и расположению вещей
в лаборатории. Он изолировал коридор, но крысы находили
дверь. Наконец, он понял, как крысы это делают: они узнавали дорогу по
тому, как под их лапами звучит пол. Этому он смог помешать, установив
свой коридор на песке. Таким образом он закрывал одну за другой все
лазейки и, в конце концов, перехитрил крыс и научил их входить в
третью дверь. И ни одним из условий нельзя было пренебречь.
      С научной точки зрения это первоклассный эксперимент. Такой
эксперимент придает смысл всей деятельности с бегающими крысами, так
как выявляет истинные ключи к разгадке их поведения. Кроме того, этот
эксперимент показывает, какие условия надо соблюдать, чтобы добиться
точности и строгости в экспериментах с крысами.
      Я изучил дальнейшую историю этих исследований. В следующих
экспериментах не было ссылок на Янга. Никто не использовал его
приемов - коридор не ставился на песок, и вообще никто не принимал
таких мер предосторожности. Просто по-старому продолжали запускать
крыс, не обращая внимания на великие открытия Янга, а на его работы не
ссылались, так как он не открыл ничего нового в поведении крыс. На
самом деле он открыл все, что надо делать, чтобы узнать что-то о
крысах. Но не замечать подобных экспериментов - типично для науки
самолетопоклонников.
** MUMPS

   Обьединение идей MUMPS и вероятностного программирования
   http://habrahabr.ru/post/242993/ может обещать некоторые интересные
   результаты...
* Исследования
** Graphviz

   Чтобы сохранять позиции элементов commanline должна быть такой:

   neato -Tpng -otester.png -n test.dot

   А файл:

   #+BEGIN_SRC dot :file zzz.png :cmd neato :cmdline -Tpng -n
     /**
      ,* Graph /home/rigidus/repo/moto/test Generated by Emacs/SRecode on 20:22:21.
      ,*/
     digraph structs {
         node [shape=record fontsize=12 fontname=Courier];

         "Name3" [  shape="box" label="Name3" pos="306,36" ];
         "Name4" [  shape="box" label="Name4" pos="246,216" ];
         "Name3" -> "Name4" [  arrowhead="none" arrowtail="none" ];
         "Name1" [  shape="box" label="Name1" pos="180,132" ];
         "Name2" [  shape="box" label="Name2" pos="360,120" ];
         "Name2" -> "Name1" [  arrowhead="none" arrowtail="none" ];
     }
   #+END_SRC

   #+results:
   [[file:zzz.png]]

** Дракон и sqlite

   Чтобы использовать ДРАКОН для облегчения имеративного
   программирования, необходимо

   - Поставить tcl/tk (sudo apt-get install tcl8.6 tk8.6 tcllib libsqlite3-tcl libtk-img)
   - Поставить drakon_editor (http://drakon-editor.sourceforge.net/editor.html#downloads)
   - Поставить sqlite3 (apt-get install sqlite3)
   - Использовать sqlite из elisp-a следующим образом:
     #+BEGIN_SRC emacs-lisp
       (add-to-list 'load-path "~/repo/sqlite.el/")

       (require 'sqlite)

       (setq s3d (sqlite-init "~/repo/moto/drakon.drn"))

       (let ((descriptor (sqlite-init "~/repo/moto/drakon.drn")))
         (setq res (sqlite-query descriptor "SELECT * FROM items"))
         (sqlite-bye descriptor)
         res)
     #+END_SRC

     #+results:
     | item_id | diagram_id | type       | text                           | selected |    x |   y |    w |   h |    a | b | aux_value | color | format | text2 |
     |       1 |          1 | beginend   | "Управление замком"            |        0 |  170 |  60 |   80 |  20 |   60 | 0 | ,""       | ,""   |        |       |
     |       2 |          1 | beginend   | "Конец"                        |        0 | 1900 | 510 |   50 |  20 |   60 | 0 | ,""       | ,""   |        |       |
     |       3 |          1 | vertical   | ""                             |        0 |  170 | 120 |    0 | 490 |    0 | 0 | ,""       | ,""   |        |       |
     |       4 |          1 | vertical   | ""                             |        0 | 1660 | 120 |    0 | 490 |    0 | 0 | ,""       | ,""   |        |       |
     |       5 |          1 | vertical   | ""                             |        0 | 1900 | 120 |    0 | 380 |    0 | 0 | ,""       | ,""   |        |       |
     |       6 |          1 | horizontal | ""                             |        0 |  170 | 120 | 1730 |   0 |    0 | 0 | ,""       | ,""   |        |       |
     |       7 |          1 | arrow      | ""                             |        0 |   20 | 120 |  150 | 490 | 1640 | 1 | ,""       | ,""   |        |       |
     |       8 |          1 | branch     | "Инициализация"                |        0 |  170 | 170 |  120 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |       9 |          1 | address    | "Закрывается"                  |        0 |  170 | 550 |  120 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |      10 |          1 | branch     | "Закрывается"                  |        0 | 1660 | 170 |   80 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |      11 |          1 | branch     | "Отключение"                   |        0 | 1900 | 170 |   50 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |      12 |          1 | address    | "Закрыто"                      |        0 | 1660 | 550 |   80 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |      13 |          1 | action     | "Инициализировать процессор"   |        0 |  170 | 250 |  120 |  20 |    0 | 0 | ,         | ,     |        |       |
     |      14 |          1 | branch     | "Закрыто"                      |        0 |  670 | 170 |  130 |  30 |   60 | 0 | ,         | ,     |        |       |
     |      15 |          1 | vertical   | ""                             |        0 |  670 | 120 |    0 | 490 |    0 | 0 | ,         | ,     |        |       |
     |      16 |          1 | address    | "Открывается"                  |        0 |  670 | 550 |  130 |  30 |   60 | 0 | ,         | ,     |        |       |
     |      17 |          1 | branch     | "Открыто"                      |        0 | 1350 | 170 |  130 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |      18 |          1 | vertical   | ""                             |        0 | 1350 | 120 |    0 | 490 |    0 | 0 | ,""       | ,""   |        |       |
     |      19 |          1 | address    | "Закрыто"                      |        0 | 1350 | 550 |  130 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |      20 |          1 | branch     | "Открывается"                  |        0 | 1030 | 170 |   80 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |      21 |          1 | vertical   | ""                             |        0 | 1030 | 120 |    0 | 490 |    0 | 0 | ,""       | ,""   |        |       |
     |      22 |          1 | address    | "Открыто"                      |        0 | 1030 | 550 |   80 |  30 |   60 | 0 | ,""       | ,""   |        |       |
     |      23 |          1 | if         | "Нажата кнопка?"               |        0 |  670 | 290 |  130 |  20 |   40 | 1 | ,         | ,     |        |       |
     |      24 |          1 | arrow      | ""                             |        1 |  870 | 230 |  200 |  60 |   30 | 0 | ,         | ,     |        |       |
     |      25 |          1 | action     | "Включить мотор на открывание" |        0 |  670 | 380 |  130 |  20 |    0 | 0 | ,         | ,     |        |       |
     |      26 |          1 | if         | "Ригель открыт?"               |        0 | 1030 | 290 |   80 |  20 |   30 | 0 | ,         | ,     |        |       |
     |      27 |          1 | arrow      | ""                             |        0 | 1150 | 230 |  120 |  60 |   30 | 0 | ,         | ,     |        |       |
     |      28 |          1 | action     | "Выключить мотор"              |        0 | 1030 | 380 |   80 |  20 |    0 | 0 | ,         | ,     |        |       |
     |      29 |          1 | if         | "Нажата кнопка?"               |        0 | 1350 | 290 |  130 |  20 |   50 | 1 | ,""       | ,""   |        |       |
     |      30 |          1 | arrow      | ""                             |        0 | 1530 | 230 |  180 |  60 |   30 | 0 | ,""       | ,""   |        |       |
     |      31 |          1 | action     | "Включить мотор на закрывание" |        0 | 1350 | 380 |  130 |  20 |    0 | 0 | ,""       | ,""   |        |       |
     |      32 |          1 | if         | "Ригель закрыт?"               |        0 | 1660 | 290 |   80 |  20 |   30 | 0 | ,""       | ,""   |        |       |
     |      33 |          1 | arrow      | ""                             |        0 | 1780 | 230 |  120 |  60 |   70 | 0 | ,""       | ,""   |        |       |
     |      34 |          1 | action     | "Выключить мотор"              |        0 | 1660 | 380 |   80 |  20 |    0 | 0 | ,""       | ,""   |        |       |
     |      35 |          1 | if         | "Успешная инициализация?"      |        0 |  170 | 330 |  120 |  20 |   80 | 1 | ,         | ,     |        |       |
     |      36 |          1 | vertical   | ""                             |        0 |  370 | 330 |    0 | 280 |    0 | 0 | ,         | ,     |        |       |
     |      37 |          1 | address    | "Отключение"                   |        0 |  370 | 550 |   50 |  30 |   60 | 0 | ,         | ,     |        |       |

   Таким образом мы получим таблицу элементов. Далее нам нужно

     | item_id | diagram_id | type       | text                           | selected |    x |   y |    w |   h |    a | b | aux_value | color | format | text2 |
     |      35 |          1 | if         | "Успешная инициализация?"      |        0 |  170 | 330 |  120 |  20 |   80 | 1 | ,         | ,     |        |       |
     |      37 |          1 | address    | "Отключение"                   |        0 |  370 | 550 |   50 |  30 |   60 | 0 | ,         | ,     |        |       |


   определить пересечения веток и других элементов. Начнем с начала,
   где началом будем считать элемент =beginend= который не называется
   "Конец"

   #+BEGIN_SRC emacs-lisp :output table
     (sqlite-query s3d "SELECT item_id, text, x, y, w, h, a, b FROM items WHERE type LIKE 'beginend' AND text NOT LIKE 'Конец'")
   #+END_SRC

   #+results:
   | item_id | text                |   x |  y |  w |  h |  a | b |
   |       1 | "Управление замком" | 170 | 60 | 80 | 20 | 60 | 0 |

   Однако нам это мало поможет, так как это название диаграммы. Более
   интересно узнать все ветви и расположить их в порядке слева-направо

   #+BEGIN_SRC emacs-lisp :output table
     (sqlite-query s3d "SELECT item_id, text, x, y, w, h, a, b FROM items WHERE type LIKE 'branch' ORDER BY x")
   #+END_SRC

   #+results:
   | item_id | text            |    x |   y |   w |  h |  a | b |
   |       8 | "Инициализация" |  170 | 170 | 120 | 30 | 60 | 0 |
   |      14 | "Закрыто"       |  670 | 170 | 130 | 30 | 60 | 0 |
   |      20 | "Открывается"   | 1030 | 170 |  80 | 30 | 60 | 0 |
   |      17 | "Открыто"       | 1350 | 170 | 130 | 30 | 60 | 0 |
   |      10 | "Закрывается"   | 1660 | 170 |  80 | 30 | 60 | 0 |
   |      11 | "Отключение"    | 1900 | 170 |  50 | 30 | 60 | 0 |

   Теперь для каждой ветви нам необходимо получить лежащие на ней
   элементы. В нашем простом случае все ветви очевидно имеют
   одинаковую высоту и расположены строго вертикально, поэтому нам
   достаточно найти блоки, координата X которых совпадает с
   координатой X ветви. Таким образом, мы можем получить все блоки,
   координаты которых лежат на ветви, упорядочив их сверху-вниз:

   #+BEGIN_SRC emacs-lisp :output table
     (defun get-blocks-of-vertical (x from-y to-y)
       (sqlite-query
        s3d
        (format "SELECT item_id,type,text,x,y,w,h,a,b FROM items WHERE (x = %s) AND (y >= %s) AND (y <= %s) AND type NOT LIKE 'horizontal' AND type NOT LIKE 'vertical' AND type NOT LIKE 'branch' ORDER BY y"
                x
                from-y
                to-y)))

     (get-blocks-of-vertical 170 0 1000)
   #+END_SRC

   #+results:
   | item_id | type     | text                         |   x |   y |   w |  h |  a | b |
   |       1 | beginend | "Управление замком"          | 170 |  60 |  80 | 20 | 60 | 0 |
   |      13 | action   | "Инициализировать процессор" | 170 | 250 | 120 | 20 |  0 | 0 |
   |      35 | if       | "Успешная инициализация?"    | 170 | 330 | 120 | 20 | 80 | 1 |
   |       9 | address  | "Закрывается"                | 170 | 550 | 120 | 30 | 60 | 0 |

   Здесь мы впервые встречаемся с узлом типа =if=, у которого две
   ветви. По умолчанию ветвь "да" - побочная, если нет, в поле =b=
   устанавливается флаг "1". Мы должны выяснить, с чем соединяется
   побочная ветвь, а для этого необходимо вычислить координаты
   возможных точек пересечения, которые лежат в диапазоне от окончания
   блока if до длины ответвления. Сразу найдем те элементы, с которым
   пересекается ответвление, при этом учитываем, что возвратные
   стрелки - случай особый, так как их координаты считаются
   относительно верхнего правого угла. Поэтому точка пересечения у них
   должны быть вычислена как { x = x - a | y = y + h }

   #+BEGIN_SRC emacs-lisp :output table
     (defun get-lateral-if (item-id)
       (let* ((res (sqlite-query
                    s3d
                    (format "SELECT x,y,w,h,a,b FROM items WHERE item_id = %s" item-id)))
              (val (cadr res))
              (from-x (+ (string-to-number (car val)) (string-to-number (nth 2 val))))
              (to-x   (+ from-x (string-to-number (nth 4 val))))
              (y      (string-to-number (cadr val)))
              (where-not-arrow
               (format "((x >= %s) AND (x <= %s) AND (y = %s) AND type NOT LIKE 'arrow')"
                       from-x
                       to-x
                       y))
              (where-arrow
               (format "((x-a >= %s) AND (x-a <= %s) AND (y+h = %s) AND type LIKE 'arrow')"
                       from-x
                       to-x
                       y)))
         (sqlite-query
          s3d
          (format "SELECT item_id,type,text,x,y,w,h,a,b FROM items WHERE %s OR %s "
                  where-not-arrow
                  where-arrow))))

     (get-lateral-if 35)
   #+END_SRC

   #+results:
   | item_id | type     | text |   x |   y | w |   h | a | b |
   |      36 | vertical | ""   | 370 | 330 | 0 | 280 | 0 | 0 |

   Здесь мы получили объект =vertical=, по котором уже определенной
   функцией получаем все расположенные на нем объекты

   #+BEGIN_SRC emacs-lisp :output table
     (let* ((res (get-lateral-if 35))
            (val (cadr res))
            (center-x (nth 3 val))
            (from-y   (nth 4 val))
            (to-y     (+ (string-to-number from-y) (string-to-number (nth 6 val)))))
       ;; (list center-x from-y to-y))
       (get-blocks-of-vertical center-x from-y to-y))
   #+END_SRC

   #+results:
   | item_id | type    | text         |   x |   y |  w |  h |  a | b |
   |      37 | address | "Отключение" | 370 | 550 | 50 | 30 | 60 | 0 |

   Таким образом мы можем строить разбор основных элементов дракон
   схемы. Для уверенности проделаем эти операции с другим типом
   ветвей:

   #+BEGIN_SRC emacs-lisp
     (get-blocks-of-vertical 670  0 1000)
   #+END_SRC

   #+results:
   | item_id | type    | text                           |   x |   y |   w |  h |  a | b |
   |      23 | if      | "Нажата кнопка?"               | 670 | 290 | 130 | 20 | 40 | 1 |
   |      25 | action  | "Включить мотор на открывание" | 670 | 380 |  90 | 20 |  0 | 0 |
   |      16 | address | "Открывается"                  | 670 | 550 | 130 | 30 | 60 | 0 |

   #+BEGIN_SRC emacs-lisp :output table
     (get-lateral-if 23)
   #+END_SRC

   #+results:
   | item_id | type  | text |   x |   y |   w |  h |  a | b |
   |      24 | arrow | ""   | 860 | 230 | 180 | 60 | 30 | 0 |

   Ну а дальше - дело техники - получить точку куда указывает стрелка,
   элемент выше нее и ниже, чтобы определить переход

   Следующая задача = построение графа управления по полученным данным
** tkl

   Исчерпывающая документация
   http://www.peter-herth.de/ltk/ltkdoc/node52.html

   О генерации кода для дракон-схем:
   http://drakon-editor.sourceforge.net/howto.html
