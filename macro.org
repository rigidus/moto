
Макросы. Наброски к докладу.

* WTF Macro?

  Наиболее общее определение: Правило или шаблон, определяющий, как
  некую подпоследовательность, поступающую на "вход" следует
  превратить в подпоследовательность на "выходе".

  Таким образом макрос - это отображение. Как правило, выходная
  подпоследовательность больше входной, поэтому процесс отображения
  часто называют "раскрытием", macroexpansion.

  Простейший способ сделать макрос - это перед компиляцией пропустить
  сорцы через препроцессор на регексах, но - это плохой негодный
  способ. Однако рабочий :)

  Почему же он плох? Потому что:
  - Препроцессор работает вне контекста исходника, что ограничивает
    его возможности. Можно конечно накрутить лексер и парсер и дать
    ему этот контекст, но... см. 10-е правило Гринспена.
  - Препроцессор работает со входом и выходом на языке символьных
    подстановок, в то время как эффективнее было бы делать структурные
    подстановки - т.е. заниматься трансформациями AST
  - Препроцессор - это как правило специальный язык (DSL) с
    отличающейся семантикой и синтаксисом. Это вызывает некоторые
    когнитивные сложности у слабых духом иди волей программистов :)
    Кроме того часто отдельные утилитарные куски приходится
    реализовывать как на основном языке так и на языке препроцессора -
    а это как-то некругло - мы же хотим сократить себе работу а не
    увеличивать ее.

** Примеры макросистем позднего голоцена
*** Директива #define (C/C++)

    Закат солнца вручную.

    #+BEGIN_SRC c
      #define MAX(x,y) ((x)>(y))?(x):(y)

      t=MAX(i,s[i]);

      =>

      t=((i)>(s[i])?(i):(s[i]);
    #+END_SRC

*** Макропроцессор m4

    Макроопределения и макровызовы (с параметрами):

    #+BEGIN_EXAMPLE
      define(name [, expansion])

      define('exch', '$2, $1')
      =>
      exch('arg1', 'arg2')
      => arg2, arg1
    #+END_EXAMPLE

    Макросы аналогичны директивам препроцессора #define в C и в то же
    время аналогичны eval. Отличие от #define состоит в том, что для
    #define доступны 3-4 операции (арифметические действия над
    константами, вызов других макросов и две конкатенации).

    Что может m4?
    - Назначение/удаление переменных/макросов (define/undefile)
    - И в стеке тоже (pushdef/popdef)
    - Условное раскрытие (ifdef)
    - Цикл и рекурсия (shift, forloop)
    - Управление 10 виртуальными потоками вывода
    - Вычисление выражений (eval)
    - Операции со строками (substr, len, regexp, patsubst)
    - Подстановка содержимого файлов (include)
    - Выполнение shell-команд (syscmd)
    - Коссвенные вызовы макросов (indir), в т.ч. встроенных (buildin)
    - Трассировка раскрытия (traceon/traceoff)

    Что им можно сделать?
    - Генерация кода из декларативной спецификации
    - Генерация SQL во время компиляции
    - Документирование
    - Администрирование (конфиги)

* Макропроцессор Lisp для чайников

  Макрос в лиспе — это своего рода функция, которая получает в
  качестве аргументов лисповские формы или объекты и, как правило,
  генерирует код, который затем будет скомпилирован и выполнен. Это
  происходит до выполнения программы, во время фазы, которая
  называется развёрткой макросов (macroexpansion). Макросы могут
  выполнять какие-то вычисления во время развёртки, используя полные
  возможности языка.

  Макроопределения и макроподстановки:

  #+BEGIN_SRC lisp
    (defparameter *dbg-enable* t)
    (defparameter *dbg-indent* 1)

    (defun dbgout (out)
      (when *dbg-enable*
        (format t (format nil "~~%~~~AT~~A" *dbg-indent*) out)))

    (defmacro dbg (frmt &rest params)
      `(dbgout (format nil ,frmt ,@params)))

    (macroexpand-1 '(dbg "~A~A~{~A~^,~}" "this is debug message " "15:57:02 " (list 1 2 3 4)))

    => (DBGOUT
        (FORMAT NIL "~A~A~{~A~^,~}" "this is debug message " "15:57:02 "
                (LIST 1 2 3 4))), T

    (dbg "~A~A~{~A~^,~}" "this is debug message " "15:57:02 " (list 1 2 3 4))

    => this is debug message 15:57:02 1,2,3,4
  #+END_SRC

** Преобразование AST макросами

   Если вы облицовываете пол плиткой, размер которой с ноготь, вы не
   тратите излишних усилий – Пол Грэм

   В то время, как в других языках у вас есть небольшие квадратные
   плиточки, в Lisp вы можете выбрать плитку любого размера и любой
   формы.

   Здесь надо добавить какой-нибудь элегантный макрос, который
   выполняет преобразования над AST: Как нам прохавать AST - патчим
   граф выполнения - типичные примеры - профайлинг, логгинг, аспекты.

   Вот тут будет сложно... Это кусок моего проекта по
   автоматизированному поиску работы. Он трансформирует, упрощаяя
   DOM-дерево страницы с вакансиями так, чтобы по нему можно было
   собрать информацию о собственно размещенных вакансиях и компаниях,
   их разместивших.

   Первая функция получает на вход DOM-дерево и функцию
   трансформер-предикат. Если полученное дерево матчится с
   трансформером-предикатом, то возвращается преобразованное дерево, в
   противном случае возвращаем входное дерево "как есть".

   Таким образом можно последовательно прогонять одно и то же
   DOM-дерево не просто через цепочку упрощающих преобразований, а
   через граф с if-ветвлениями.

   Второй макрос - это просто синтаксический сахар, чтобы вызывать
   первую функцию покомпактнее. Содержит гигиену :) Ну а дальше идет
   собственно преобразование - и оно настолько объемное, что я прямо
   не знаю, как я бы справился без этого самонаписанного
   синтаксического сахара... Ну и результат полного макрораскрытия
   смотрится настолько эпично, что у меня даже редактор зависает при
   попытке захайлайтить такую гору кода

   #+BEGIN_SRC lisp
     (in-package #:moto)

     (ql:quickload "split-sequence")

     ;; Это аналог maptree-if, но здесь одна функция и ищет и трансформирует узел дерева
     (defun maptree (predicate-transformer tree)
       (multiple-value-bind (t-tree control)
           (aif (funcall predicate-transformer tree)
                it
                (values tree #'mapcar))
         (if (and (consp t-tree)
                  control)
             (funcall control
                      #'(lambda (x)
                          (maptree predicate-transformer x))
                      t-tree)
             t-tree)))

     ;; maptree-transformer - синтаксический сахар для maptree
     (defmacro mtm (transformer tree)
       (let ((lambda-param (gensym)))
         `(maptree #'(lambda (,lambda-param)
                       (values (match ,lambda-param ,transformer)
                               #'mapcar))
                   ,tree)))


     (print
      (SB-CLTL2:MACROEXPAND-ALL
       '(mtm (`("div" (("class" "search-result") ("data-qa" "vacancy-serp__results")) ,@rest) rest)
         (mtm (`("div" (("data-qa" ,_) ("class" ,(or "search-result-item search-result-item_premium  search-result-item_premium"
                                                     "search-result-item search-result-item_standard "
                                                     "search-result-item search-result-item_standard_plus "))) ,@rest)
               (let ((in (remove-if #'(lambda (x) (or (equal x 'z) (equal x "noindex") (equal x "/noindex"))) rest)))
                 (if (not (equal 1 (length in)))
                     (progn (print in)
                            (err "parsing failed, data printed"))
                     (car in))))
          (mtm (`("a" (("class" _) ("href" _) ("data-qa" "vacancy-serp__vacancy-interview-insider"))
                      "Посмотреть интервью о жизни в компании") 'Z)
           (mtm (`("a" (("href" ,_) ("target" "_blank") ("class" "search-result-item__label search-result-item__label_invited")
                        ("data-qa" "vacancy-serp__vacancy_invited")) "Вы приглашены!") 'Z)
                (mtm (`("a" (("href" ,_) ("target" "_blank") ("class" "search-result-item__label search-result-item__label_discard")
                             ("data-qa" "vacancy-serp__vacancy_rejected")) "Вам отказали") 'Z)
                     (mtm (`("a" (("href" ,_) ("target" "_blank") ("class" "search-result-item__label search-result-item__label_discard")
                                  ("data-qa" "vacancy-serp__vacancy_rejected")) "Вам отказали") 'Z)
                          (mtm (`("a" (("title" "Премия HRBrand") ("href" ,_) ("rel" "nofollow")
                                       ("class" ,_)
                                       ("data-qa" ,_)) " ") 'Z)
                               (mtm (`("div" (("class" "search-result-item__image")) ,_) 'Z)
                                    (mtm (`("script" (("data-name" "HH/VacancyResponseTrigger") ("data-params" ""))) 'Z)
                                         (mtm (`("a" (("href" ,_) ("target" "_blank") ("class" ,_)
                                                      ("data-qa" "vacancy-serp__vacancy_responded")) "Вы откликнулись") 'Z)
                                              (mtm (`("div" (("class" "search-result-item__star")) ,@_) 'Z)
                                                   (mtm (`("div" (("class" "search-result-item__description")) ,@rest)
                                                          (loop :for item :in rest :when (consp item) :append item))
                                                        (mtm (`("div" (("class" "search-result-item__head"))
                                                                      ("a" (("class" ,(or "search-result-item__name search-result-item__name_standard"
                                                                                          "search-result-item__name search-result-item__name_standard_plus"
                                                                                          "search-result-item__name search-result-item__name_premium"))
                                                                            ("data-qa" "vacancy-serp__vacancy-title") ("href" ,id) ("target" "_blank")) ,name))
                                                               (list :id (parse-integer (car (last (split-sequence:split-sequence #\/ id)))) :name name))
                                                             (mtm (`("a" (("class" "interview-insider__link                   m-interview-insider__link-searchresult")
                                                                          ("href" ,href)
                                                                          ("data-qa" "vacancy-serp__vacancy-interview-insider"))
                                                                         "Посмотреть интервью о жизни в компании")
                                                                    (list :interview href))
                                                                  (mtm (`("div" (("class" "b-vacancy-list-salary") ("data-qa" "vacancy-serp__vacancy-compensation"))
                                                                                ("meta" (("itemprop" "salaryCurrency") ("content" ,currency)))
                                                                                ("meta" (("itemprop" "baseSalary") ("content" ,salary))) ,salary-text)
                                                                         (list :currency currency :salary (parse-integer salary) :salary-text salary-text))
                                                                       (mtm (`("div" (("class" "search-result-item__company")) ,emp-name)
                                                                              (list :emp-name emp-name))
                                                                            (mtm (`("div" (("class" "search-result-item__company"))
                                                                                          ("a" (("href" ,emp-id)
                                                                                                ("class" "search-result-item__company-link")
                                                                                                ("data-qa" "vacancy-serp__vacancy-employer"))
                                                                                               ,emp-name))
                                                                                   (list :emp-id (parse-integer (car (last (split-sequence:split-sequence #\/ emp-id)))
                                                                                                                :junk-allowed t)
                                                                                         :emp-name emp-name))
                                                                                 (mtm (`("div" (("class" "search-result-item__info")) ,@rest)
                                                                                        (loop :for item :in rest :when (consp item) :append item))
                                                                                      (mtm (`("span" (("class" "searchresult__address")
                                                                                                      ("data-qa" "vacancy-serp__vacancy-address")) ,city ,@rest)
                                                                                             (let ((metro (loop :for item in rest :do
                                                                                                             (when (and (consp item) (equal :metro (car item)))
                                                                                                               (return (cadr item))))))
                                                                                               (list :city city :metro metro)))
                                                                                           (mtm (`("span" (("class" "metro-station"))
                                                                                                          ("span" (("class" "metro-point") ("style" ,_))) ,metro)
                                                                                                  (list :metro metro))
                                                                                                (mtm (`("span" (("class" "b-vacancy-list-date")
                                                                                                                ("data-qa" "vacancy-serp__vacancy-date")) ,date)
                                                                                                       (list :date date))
                                                                                                     (mtm (`("span"
                                                                                                             (("class" "vacancy-list-platform")
                                                                                                              ("data-qa" "vacancy-serp__vacancy_career"))
                                                                                                             "  •  " ("span" (("class" "vacancy-list-platform__name"))
                                                                                                                             "CAREER.RU"))
                                                                                                            (list :platform 'career.ru))
                                                                                                          (block subtree-extract
                                                                                                            (mtm (`("div"
                                                                                                                    (("class" "search-result")
                                                                                                                     ("data-qa" "vacancy-serp__results"))
                                                                                                                    ,@rest)
                                                                                                                   (return-from subtree-extract rest))
                                                                                                                 ""))))))))))))))))))))))))))

     => 2200 строк раскрытия...
   #+END_SRC

** Макроc пишет код - раскрываем факториал

   #+BEGIN_SRC lisp
     (defmacro !1 (x)
       (if (= x 1)
           1
           `(* ,x (!1 ,(1- x)))))

     (macroexpand-all '(!1 5))

     (SB-CLTL2:MACROEXPAND-ALL '(!1 5))

     => (* 5 (* 4 (* 3 (* 2 1))))
   #+END_SRC

** We need to go deeeeeper - макросы, которые определяют макросы

   #+BEGIN_SRC lisp
     (defmacro defsynonym (old-name new-name)
       "Define OLD-NAME to be equivalent to NEW-NAME when used in the first position of a Lisp form."
       `(defmacro, new-name (&rest args)
          `(,',old-name ,@args)))
     => DEFSYNONYM

     (macroexpand-1 '
      (defsynonym cons make-pair))
     =>(DEFMACRO MAKE-PAIR (&REST ARGS) `(CONS ,@ARGS)), T

     (defsynonym cons make-pair)
     =>MAKE-PAIR

     (make-pair 'a 'b)
     => (A . B)
   #+END_SRC

* TODO Что если делать то же самое, но не обязательно до компиляции.

  Когда можно раскрывать макросы - read-time, compile-time,
  load-time. Что такое eval-when и какую пользу оно может нанести

* TODO Специальные макросы чтения
* TODO Практичекская применимость - Оптимизация кода на лету
  (по swizard-у - http://swizard.info/articles/solitaire/article.html)

  Note(Mary): Не со всем согласна. Например, очень странная
  мысль: "Действительно, какая разница: будет проект
  компилироваться десять секунд или десять минут?" - он явно
  не занимался интенсивной разработкой.

  Note(Rigidus): А проект не должен вообще компилироваться - он должен
  разрабатываться в репле. All compilation must be incremental!

  Q(Mary): А где именно там пример оптимизации кода на лету?

  A(Rigidus): А тут пока [TODO]
* В продолжение предыдущего - создание DSL на макросах
  Note(Mary): Если ты хочешь на базе статьи рассказывать про
  DSL, то не рекомендую, там слишком долго объяснять
  придётся, либо никто ничего не поймёт.

  R: Да, но рассказать то надо..
* Немного о гигиене и анафорических макросах

  Идея гигиены - отделить окружение макроса от окружения его
  продукции, и таким образом избежать возможных пересечений
  определяемых переменных.

  В Scheme эта идея прижиалась, но она мешает анафорическим макросам

  Самый простой пример анафорического макроса: АIF (или IF-IT),
  который тестирует первый аргумент на истинность и одновременно
  привязывает его значение к переменной IT, которую, соответственно,
  можно использовать в THEN-clause:

  #+BEGIN_SRC lisp
    (defmacro aif (var then &optional else)
      `(let ((it ,var))
        (if it ,then ,else)))
  #+END_SRC

  Однако на самом деле и в Scheme не так уж сложно добиться
  аналогичных макросов
  (см. http://www.greghendershott.com/fear-of-macros/Syntax_parameters.html).
  Ключевое отличие в том, что в Scheme макросы по умолчанию
  гигиеничны (но гигиену можно обойти, если очень хочется),
  а в Lisp - нет.

  Да, но тут метод добивания совершенно иной! И весь процесс
  добивания - это какой-то костыль "получите те же результаты, но
  контринтуитивно".

** Как сделать гигиену в Lisp

   Использование (gensym)

   #+BEGIN_SRC lisp
     (defmacro swap (pl1 pl2)
       "Macro to swap two places"
       (let ((temp1-name (gensym))
             (temp2-name (gensym)))
         `(let ((,temp1-name ,pl1)
                (,temp2-name ,pl2))
            (setf ,pl1 ,temp2-name)
            (setf ,pl2 ,temp1-name))))

     (defparameter *var1* 123)
     (defparameter *var2* 456)

     (swap *var1* *var2*)

     ,*var1*
     =>456

     ,*var1*
     =>123
   #+END_SRC

* TODO Как нам вооружившись макросами исправить мир?
  Или немного о том, как плохие люди, собрались вместе и испортили
  интернет :) По материалам статьи http://habrahabr.ru/post/269565/ и
  того факта, что javascript раньше был схемой
* TODO Программа, которая меняет саму себя - mutation engine на макросах
  (не уверен осилю ли я это и осилит ли это кто-нибудь понять)

  Q(Mary): а есть ли пример того, когда это действительно нужно?

  Честно говоря - нет. Но если ты пишешь "Самоходное программное
  обеспечение" - то это может пригодиться... Или вот пример - анализ
  обфусцированного кода, или автоматическое написание
  виртуализированной среды по коду-источнику - все, в общем, весьма
  специфичные идеи :)
* Макросы в других языках и сравнение подходов

  (галопом, без погружения)

*** Scheme/Racket
    Note(Mary): ИМХО, нет смысла их различать, второе - прямой
    потомок первого.
    Окей :)
*** Nemerle
*** Scala
*** Dylan

* Нетрадиционно ориентированное программирование:
*** Инструментированный код
*** Jптимизация черного ящика,
*** исполняемые спецификации
*** Динамическое программирование на макросах (swizard)
* Ссылки
  http://swizard.info/articles/functional-data-structures.html
  http://swizard.livejournal.com/157521.html
  http://habrahabr.ru/post/143490/
  http://fprog.ru/2010/issue5/vsevolod-dyomkin-lisp-philosophy/
  http://rus-linux.net/MyLDP/algol/LISP/lisp09.html
  http://lisp2d.net/rus/teach/q.php
  http://cyberleninka.ru/article/n/analiz-vozmozhnostey-sistemy-makroopredeleniy-yazyka-common-lisp-dlya-sozdaniya-novyh-upravlyayuschih-konstruktsiy
  https://books.google.ru/books?id=jaoDX9-e_McC&pg=PA738&lpg=PA738&dq=%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80+%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81+%D0%BB%D0%B8%D1%81%D0%BF&source=bl&ots=lHfSI5iKbj&sig=sLvsICw1e7p9ehee3zMpKHqT6Kk&hl=ru&sa=X&ved=0CFkQ6AEwCTgUahUKEwidzOn12eDIAhXK_3IKHdliDm8#v=onepage&q=%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81%20%D0%BB%D0%B8%D1%81%D0%BF&f=false
  http://linux.yaroslavl.ru/docs/prog/m4.html
