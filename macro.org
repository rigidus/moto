
Макросы. Наброски к докладу.

* WTF Macro?
** Краткий пересказ википедии - макросы, это ваще что?
** Как появилась необходимость делать подстановку в исходном коде до трансляции сорцов в машкод
*** Макропроцессор m4
**** Когда обычного ЯВУ недостаточно..
     Как оно работает - основные принципы препроцессинга

     Макроопределения и макровызовы (с параметрами):

     #+BEGIN_EXAMPLE
       define('exch', '$2, $1')
       ⇒
       exch('arg1', 'arg2')
       ⇒ arg2, arg1
     #+END_EXAMPLE

**** Что может m4?
     - Назначение/удаление переменных (define/undefile)
     - B в стеке тоже (pushdef/popdef)
     - Подстановка в зависимости от переменной (ifdef)
     - Управление 10 виртуальными потоками вывода
     - Вычисление выражений (eval)
     - Операции со строками (substr)
     - Подстановка содержимого файлов (include)
     - Выполнение shell-команд (syscmd)
**** Что им можно сделать?
     - Генерация кода из декларативной спецификации
     - Генерация SQL во время компиляции
     - Документирование
     - Администрирование (конфиги)

*** TODO Макроподстановки в С/С++
    Закат солнца вручную. Короче, такой хоккей нам не нужен, надо не
    токенами жонглировать, а выходить на уровень AST. Oh, shi...,
    s-expessions - это же AST в текстовой форме!!!
*** Макропроцессор Lisp для чайников

    Макрос в лиспе — это своего рода функция, которая получает в
    качестве аргументов лисповские формы или объекты и, как правило,
    генерирует код, который затем будет скомпилирован и выполнен. Это
    происходит до выполнения программы, во время фазы, которая
    называется развёрткой макросов (macroexpansion). Макросы могут
    выполнять какие-то вычисления во время развёртки, используя полные
    возможности языка.

    Макроопределения и макроподстановки:

    #+BEGIN_SRC lisp
      (defparameter *dbg-enable* t)
      (defparameter *dbg-indent* 1)

      (defun dbgout (out)
        (when *dbg-enable*
          (format t (format nil "~~%~~~AT~~A" *dbg-indent*) out)))

      (defmacro dbg (frmt &rest params)
        `(dbgout (format nil ,frmt ,@params)))

      (macroexpand-1 '(dbg "~A~A~{~A~^,~}" "this is debug message " "15:57:02 " (list 1 2 3 4)))

      => (DBGOUT
          (FORMAT NIL "~A~A~{~A~^,~}" "this is debug message " "15:57:02 "
                  (LIST 1 2 3 4))), T

      (dbg "~A~A~{~A~^,~}" "this is debug message " "15:57:02 " (list 1 2 3 4))

      => this is debug message 15:57:02 1,2,3,4
    #+END_SRC

*** TODO Преобразование AST макросами

    Здесь надо добавить какой-нибудь элегантный макрос, который
    выполняет преобразования над AST

    Как нам прохавать AST - патчим граф выполнения - типичные примеры -
    профайлинг, логгинг, аспекты

* Что если делать то же самое, но не обязательно до компиляции. Когда
   можно раскрывать макросы - read-time, compile-time, load-time. Что
   такое eval-when и какую пользу оно может нанести (edited)
* Специальные макросы чтения
* We need to go deeeeeper - макросы, которые создают макросы
* Практичекская применимость - Оптимизация кода на лету (по
   swizard-у)
* В продолжение предыдущего - создание DSL на макросах
* Немного о гигиене
* Программа, которая меняет саму себя - mutation engine на макросах
   (не уверен осилю ли я это и осилит ли это кто-нибудь понять
* Макросы в других языках и сравнение подходов (галопом, без
   погружения)
* Нетрадиционно ориентированное программирование:
    Инструментированный код, оптимизация черного ящика, исполняемые
    спецификации и прочее
